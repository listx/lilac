:PROPERTIES:
:HTML_CONTAINER_CLASS: title
:END:
#+title: Lilac Developer Guide
#+setupfile: lilac.theme

#+property: header-args :noweb no-export
#+options: H:5

#+bibliography: ./citations.bib

All source code is generated by /tangling/ this Org file
(=developer-guide.org=). This file is the single source of truth for basically
everything. Some other things like COPYRIGHT and LICENSE do not come from this
file, but they are exceptions.

Tangling is done by loading this file into Emacs and then running
=(org-babel-tangle)=. This file is also part of the /woven/ HTML documentation
as =developer-guide.html=, which is referenced by the introductory docs at
=README.html=. The HTML is generated by invoking =(lilac-publish)=. The outputs
of both tangling and weaving are checked into version control.

The =Makefile= in this repo is used as the main "driver" for both tangling and
weaving. Typically, you would have a browser pointed to =README.html= or
=developer-guide.html= (whichever one you are working on) and refresh it after
editing the corresponding Org file. After every change to the Org file, you can
run =make= to tangle, weave, and run unit tests.

* Development environment (Nix shell)

This is the main development shell and brings in all of our dependencies to
build all of our code. Taken from [[https://github.com/tweag/haskell-stack-nix-example/blob/b9383e35416a2b0e21fbc97ed079538f9f395b6a/shell.nix#L1][here]]. The =Makefile= is meant to be executed
from within this environment.

#+name: shell.nix
#+caption: shell.nix
#+begin_src nix :tangle shell.nix :eval no
let
  # Nixpkgs snapshot.
  sources = import ./package/nix/sources.nix;
  # The final "pkgs" attribute.
  pkgs = import sources.nixpkgs {};
in

# This is our development shell.
pkgs.mkShell ({
  buildInputs = [
    # Tangling and weaving for Literate Programming.
    pkgs.emacs29-nox

    # Spell checking.
    pkgs.typos

    # Update Nix dependencies in package/nix/sources.nix.
    pkgs.niv

    # Misc.
    pkgs.git
    pkgs.less
  ];
})
#+end_src

For Emacs, we use the "nox" version to avoid GUI dependencies (because we always
invoke Emacs in batch mode in the terminal without ever using it in an
interactive manner).

* Makefile

We have a top-level =Makefile= so that we can run some =make= commands on the
command line. The overall idea is to tangle and weave, while also running any
associated tests.

Note that we make use of the fake file =tangle=, so that we can write the
top-level =test= rule as =test: tangle=, which reads more naturally than the
equivalent =test: Makefile= or =test: lilac.el=.

#+name: Makefile
#+caption: Makefile
#+begin_src makefile :tangle Makefile :eval no
all: test weave
.PHONY: all

test: tangle
	LILAC_ROOT=$(LILAC_ROOT) emacs --quick --batch --kill --load ert \
		--load lilac.el \
		--load lilac-tests.el \
		--funcall ert-run-tests-batch-and-exit
.PHONY: test

__NREF__Makefile-weave
__NREF__Makefile-tangle
__NREF__Makefile-run_emacs
__NREF__Makefile-lint
__NREF__Makefile-update-deps
#+end_src

Weaving just depends on the main =README.html= and =developer-guide= files being
generated. Before we call =(lilac-publish)=, we have to first call
=(lilac-gen-css-and-exit)= because otherwise the source code blocks do not get
any syntax highlighting.

#+name: __NREF__Makefile-weave
#+begin_src makefile
weave: lint README.html developer-guide.html
.PHONY: weave

README.html syntax-highlighting.css &: README.org
	$(call run_emacs,(lilac-gen-css-and-exit),$<)
	$(call run_emacs,(lilac-publish),$<)

developer-guide.html syntax-highlighting.css &: developer-guide.org
	$(call run_emacs,(lilac-gen-css-and-exit),$<)
	$(call run_emacs,(lilac-publish),$<)
#+end_src

Tangling is pretty straightforward --- we just need to call
=(org-babel-tangle)= on =developer-guide.org= (the =README.org= does not contain
any code we need to run to make this work). This generates a number of files,
such as the =Makefile= and =shell.nix=.

The key here is to enumerate these generated files, because we need to tell the
=make= utility that it should run the rule if =developer-guide.org= has a newer
modification timestamp than any of the generated files. Technically speaking,
because all of the tangled files are tangled together at once with
=(org-babel-tangle)=, we could just list one of them such as =Makefile= (instead
of enumerating all of them). However we still enumerate them all here for
completeness.

#+name: __NREF__Makefile-tangle
#+begin_src makefile
# tangled_output are all files that are generated by tangling developer-guide.org.
tangled_output = \
	citations.bib \
	lilac.css \
	lilac.el \
	lilac-tests.el \
	lilac.js \
	lilac.theme \
	.gitattributes \
	.gitignore \
	Makefile \
	shell.nix

tangle $(tangled_output) &: developer-guide.org
	# Generate the toplevel Makefile (this file) and others as described in
	# tangled_output. In a way this bootstraps the whole literate-programming
	# pipeline.
	$(call run_emacs,(org-babel-tangle),developer-guide.org)
	touch tangle
#+end_src

The =run_emacs= function is used for both weaving and tangling. The main thing
of interest here is that it loads the =lilac.el= (tangled) file before
evaluating the given expression.

#+name: __NREF__Makefile-run_emacs
#+begin_src makefile
define run_emacs
	LILAC_ROOT=$(LILAC_ROOT) emacs $(2) --quick --batch --kill \
		--load $(LILAC_ROOT)/lilac.el --eval="$(1)"
endef

LILAC_ROOT := $(shell git rev-parse --show-toplevel)
#+end_src

We use [[https://github.com/nmattia/niv][=niv=]] to update the dependencies sourced by [[shell.nix][=shell.nix=]]. Niv uses two
sources of truth: the niv repository itself on GitHub, and a branch of nixpkgs.
The former tracks the =master= branch, and the latter tracks the stable channels
(example: =nixos-23.05= branch). Whenever we run =niv update=, =niv= will update
the HEAD commit SHA of these branches.

One problem with the nixpkgs stable channel is that it will eventually become
obsolete as newer stable channels get created. So we have to manually track
these channels ourselves.

#+name: __NREF__Makefile-update-deps
#+begin_src makefile
nixpkgs_stable_channel := nixos-23.05
update-deps: package/nix/sources.json package/nix/sources.nix
	cd package && niv update nixpkgs --branch $(nixpkgs_stable_channel)
	cd package && niv update
	touch update-deps
#+end_src

** Linting

*** Spell checker

We use [[https://crates.io/crates/typos-cli][typos-cli]] to check for spelling errors. Below we configure it to only
check the original source material --- Org files.

#+name: _typos.toml
#+caption: _typos.toml
#+begin_src toml :tangle _typos.toml :eval no
[files]
extend-exclude = [
    "*.html",
    "deps/*",
]
#+end_src

Here we have the Makefile rules for linting, which include this spellchecker.

#+name: __NREF__Makefile-lint
#+begin_src makefile
lint: spellcheck
.PHONY: lint

spellcheck: README.org developer-guide.org
	typos
.PHONY: spellcheck
#+end_src

* Tangling (generating the source code)

Tangling is simply the act of collecting the =#+begin_src ... #+end_src= blocks
and arranging them into the various target (source code) files. Every source
code block is given a unique name.

We simply tangle the =developer-guide.org= file to get all the code we need.

The only thing that we customize in terms of tangling is how we define Noweb
references inside source code blocks.

** Custom Noweb delimiters

By default, Org mode requires Noweb source code references to be delimited with
double angled brackets (=<<= and =>>=). This presents two problems:

1. The biggest problem with this is that it interferes with syntax highlighting,
   especially because different programming languages treat these brackets in a
   different manner (it may be a particular type of token in one language, but a
   different one in another).
1. It's also slightly annoying because when searching inside an editor such as
   Vim (or even Emacs with the Org mode on), the angle brackets are not
   considered part of the word being searched. This means that if the source
   code block shares the same name as another (unrelated) string, the search
   results for both are combined into one.

To avoid these problems, we simply make Noweb references use a =__NREF__=
prefix. We also define a suffix group such that the reference can take an
argument to the code block itself. See the example in FIXME.

Note that because this is a customization, we cannot run ~C-c C-v t~ to tangle
code blocks properly in an interactive manner from an Emacs editing session of
this Org file, without first evaluating the bits of code in the following code
block.

#+name: __NREF__lilac_dot_el-custom-noweb-delimiters
#+begin_src emacs-lisp :noweb no
(setq org-babel-noweb-wrap-start "__NREF__")
(setq org-babel-noweb-wrap-end "")

(defun lilac-nref-rx (match-optional-params)
  (rx-to-string
   (lilac-nref-rx-primitive match-optional-params)))

(defun lilac-nref-rx-primitive (match-optional-params)
  (if match-optional-params
   `(group
           "__NREF__"
          ;; Noweb reference must start with a letter...
          (any alpha)
          ;; ...and must be followed by
          ;; letters,numbers,dashes,underscores,periods...
          (* (or (any alnum) "-" "_" "."))
          ;; ...and may terminate with a "(...)" where the "..." may be an empty
          ;; string, or some other argument.
          (* (or "()"
                 (and "("
                      (* (not ")"))
                      ")"))))
   `(group
          "__NREF__"
          (any alpha)
          (* (or (any alnum) "-" "_" ".")))))

;; Customize noweb delimiters. Unlike traditional << and >> delimiters, we just
;; use the "__NREF__" prefix as our only delimiter. This has the advantage of
;; being encoded the same way into HTML, which makes our HTML modifications
;; easier and more consistent across different source code languages.
;; See https://emacs.stackexchange.com/a/73720/13006.
(defun org-babel-noweb-wrap (&optional regexp)
  "Return regexp matching a Noweb reference.

Match any reference, or only those matching REGEXP, if non-nil.
When matching, reference is stored in match group 1."
  (lilac-nref-rx t))
#+end_src

** Allow evaluation of code blocks

Some code blocks are generated by evaluating code in other blocks. This way, you
can use all the power of Org mode (as well as any supported programming
language) as a kind of meta-programming system.

Orgmode by default disables automatic evaluation of source code blocks, because
it is a big security risk. For us, we know that we want to allow code
evaluation, so we disable the evaluation confirmation check. This way,
evaluation can still work even in batch mode.

#+header: :noweb-ref __NREF__lilac_dot_el-allow-code-evaluation
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

The following is needed to evaluate the example for source code block evaluation
in [[file:README.org::#h-Monoblock--evaluation-result-s-value][Monoblock (evaluation result's value)]], which evaluates Python. We don't
need to add in Emacs lisp here because it's already supported by default (which
we take advantage of in [[* Create =lilac.theme= file]]).

#+header: :noweb-ref __NREF__lilac_dot_el-allow-code-evaluation
#+begin_src emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages
                             (append org-babel-load-languages
                              '((python     . t))))
#+end_src

* Weaving (generating the HTML)

Weaving is conceptually simpler than tangling because there is no extra step ---
the output is an HTML page and that is something that we can use directly
(unlike program source code, which may require additional compilation into a
binary, depending on the language). We limit ourselves to HTML output because
HTML support is ubiquitous; plus we don't have to worry about page breaks such
as in PDF output.

Although weaving is conceptually simple, most of the code in [[file:lilac.el][=lilac.el=]] have to
do with weaving because the default infrastructure that ships with Org mode is
too rigid for our needs. For example, we make heavy use of Noweb-style
[cite:@ramsey_1994] references, but also add in extensive HTML links to allow
the reader to jump around code easily because Org does not cross-link these
references by default.

Weaving currently requires the following dependencies:

| Dependency | Why                      |
|------------+--------------------------|
| [[https://www.gnu.org/software/make/][GNU Make]]   | to run "make"            |
| [[https://www.gnu.org/software/emacs/][GNU Emacs]]  | for tangling and weaving |

Note that all of the above can be brought in by using the [[https://github.com/NixOS/nix][Nix package manager]].
This is why we provide a [[shell.nix][=shell.nix=]] [[file:shell.nix][file]] in this repo.

** Emacs customizations (=lilac.el=)

Below is the overall structure of [[file:lilac.el][=lilac.el=]]. The =gc-cons-threshold=
setting is to prevent =emacs= from entering garbage collection pauses, because
we invoke =emacs= from the command line in a non-interactive manner.

#+name: lilac.el
#+caption: lilac.el
#+begin_src emacs-lisp :tangle lilac.el :eval no
; Set garbage-collection threshold to 16 GiB.
(setq gc-cons-threshold #x400000000)
__NREF__lilac_dot_el-imports
__NREF__lilac_dot_el-fix-nondeterminism
__NREF__lilac_dot_el-custom-noweb-delimiters
__NREF__lilac_dot_el-allow-code-evaluation
__NREF__lilac_dot_el-lilac-publish
__NREF__lilac_dot_el-lilac-publish-helpers
__NREF__lilac_dot_el-search-replace
__NREF__lilac_dot_el-autogenerate-css
__NREF__lilac_dot_el-misc
(provide 'lilac)
#+end_src

** Fix non-determinism

Nondeterminism is problematic because it results in a different HTML file
every time we run =org-babel-tangle=, /even if the Org files have not changed/.
Here we take care to set things right so that we can have reprducible, stable
HTML output.

*** Do not insert current time as HTML comment

Org mode also injects an HTML comment (not visible to the user) to record the
time that the HTML was generated. We disable this because it breaks
deterministic output. See [[https://emacs.stackexchange.com/questions/50117/how-to-disable-commented-date-in-org-mode-html-export][this link]] for more info.

#+header: :noweb-ref __NREF__lilac_dot_el-fix-nondeterminism
#+begin_src emacs-lisp
(setq org-export-time-stamp-file nil)
#+end_src

*** Do not insert current Org mode version

By default Org mode appends visible metadata at the bottom of the HTML document,
including the Org version used to generate the document. We suppress this
information.

#+header: :noweb-ref __NREF__lilac_dot_el-fix-nondeterminism
#+begin_src emacs-lisp
(setq org-html-postamble nil)
#+end_src

*** Do not use random numbers for the HTML =id= attribute

Stop randomized IDs from being generated every time. Instead count from 0 and
work our way up.

See https://www.reddit.com/r/orgmode/comments/aagmfh/comment/hk6upbf.

#+header: :noweb-ref __NREF__lilac_dot_el-fix-nondeterminism
#+begin_src emacs-lisp
(defun org-export-deterministic-reference (references)
  (let ((new (length references)))
     (while (rassq new references) (setq new (1+ new)))
     new))
(advice-add #'org-export-new-reference
            :override #'org-export-deterministic-reference)
#+end_src

** Toplevel publishing function (=lilac-publish=)

The toplevel function is =lilac-publish=. This actually publishes to HTML twice,
with two separate calls to =org-html-export-to-html=. The reason we publish
twice is because we need to examine the HTML output twice in order to build up a
database of parent/child source code block links (which is then used to link
between these parent/child source code blocks).

Also note that we do some modifications to the Org buffer directly before
exporting to HTML. The main reason is so that the source code blocks that are
named =__NREF__...= get an automatic =#+caption: ...= text to go along with it
(because for these Noweb-style blocks, the captions should always look uniform).

The full code listing for =lilac-publish= is below.

#+caption: lilac-publish
#+begin_src emacs-lisp :noweb yes
__NREF__lilac_dot_el-lilac-publish
#+end_src

Now let's go through =lilac-publish= in detail.

#+header: :noweb-ref __NREF__lilac_dot_el-lilac-publish
#+begin_src emacs-lisp
(defun lilac-publish ()
  (interactive)
  (setq org-html-htmlize-output-type 'css)
#+end_src

Do not hardcode colors into the HTML. Instead refer to CSS class names, to be
stylized by an external CSS file.

#+header: :noweb-ref __NREF__lilac_dot_el-lilac-publish
#+begin_src emacs-lisp
  (setq org-export-before-parsing-hook
   '(lilac-UID-for-all-src-blocks
     lilac-insert-noweb-source-code-block-captions
     lilac-UID-for-all-headlines))
#+end_src

Here we modify the Org mode buffer, by using =org-export-before-parsing-hook=.
This takes a list of functions that are free to modify the Org mode buffer
before each Org element in the buffer gets converted into HTML.

As for the actual modifications, see:

- =lilac-UID-for-all-src-blocks= ([[* Give all source code blocks a =#+name: ...= field (HTML ID)]])
- =lilac-insert-noweb-source-code-block-captions= ([[* Automatic captions for Noweb source code blocks]])
- =lilac-UID-for-all-headlines= ([[* Human-readable UIDs (Headings, aka headlines)]])

In brief, the =lilac-UID-for-all-*= functions make it so that the links to
headlines and source code blocks are both deterministic and human-readable. The
=lilac-insert-noweb-source-code-block-captions= function

Now we start modifying the HTML.

This is useful for adding in final tweaks to the HTML that is difficult to
accomplish at the Org-mode buffer level.

Phase 1: In the first phase, we use the generated HTML data to populate the
=lilac-child-HTML_ID-hash-table=. This data structure is used to link to child
blocks from parent blocks. We also populate the
=lilac-org_id-human_id-hash-table= which is used to convert HTML IDs to be more
human-readable.

#+header: :noweb-ref __NREF__lilac_dot_el-lilac-publish
#+begin_src emacs-lisp
  (setq org-export-filter-src-block-functions
   '(lilac-populate-child-HTML_ID-hash-table
     lilac-populate-org_id-human_id-hash-table))

  (org-html-export-to-html)
#+end_src

In between these phases we have to call

#+header: :noweb-ref __NREF__lilac_dot_el-lilac-publish
#+begin_src emacs-lisp
  (clrhash lilac-polyblock-names-totals)
#+end_src

because of some internal housekeeping we have to do.

Phase 2: In this phase we perform the linking from parent blocks to child blocks
(=lilac-link-to-children-from-parent-body=), and also convert the child source
code captions to look prettier (=lilac-prettify-source-code-captions=).

#+header: :noweb-ref __NREF__lilac_dot_el-lilac-publish
#+begin_src emacs-lisp
  (setq org-export-filter-src-block-functions
   '(lilac-link-to-children-from-parent-body
     lilac-prettify-source-code-captions))
  (setq org-export-filter-final-output-functions
   '(lilac-replace-org_ids-with-human_ids))

  (org-html-export-to-html)
#+end_src

After publishing to HTML, we have to clear the intermediate hashtables used for
the export, because we could be invoking =lilac-publish= multiple times from the
same emacs session (such as during unit tests).

#+header: :noweb-ref __NREF__lilac_dot_el-lilac-publish
#+begin_src emacs-lisp
  (clrhash lilac-polyblock-names)
  (clrhash lilac-polyblock-names-totals)
  (clrhash lilac-org_id-human_id-hash-table)
  (clrhash lilac-human_id-count-hash-table)
  (clrhash lilac-human_id-org_id-hash-table)
#+end_src

The final bits are

1. the deletion of the "Table of Contents" text from the autogenerated
   Table of Contents section, which we'll [[* Table of contents sidebar][convert into a sidebar]]; and
2. the cleaning up of some inline CSS styles that get injected into the HTML as
   part of citation styles.

#+header: :noweb-ref __NREF__lilac_dot_el-lilac-publish
#+begin_src emacs-lisp
  __NREF__lilac-publish-delete-toc-text
  __NREF__lilac-publish-fix-mathjax-version
  __NREF__lilac-publish-fix-inline-styles
  __NREF__lilac-publish-fix-bibliography-ids
  __NREF__lilac-publish-fix-description-lists
  __NREF__lilac-publish-inject-custom-html-head)
#+end_src

*** Helper functions

These are for modifying the Org buffer.

#+header: :noweb-ref __NREF__lilac_dot_el-lilac-publish-helpers
#+begin_src emacs-lisp
__NREF__UID-for-all-src-blocks
__NREF__smart-source-code-block-captions
__NREF__UID-for-all-headlines
#+end_src

These are for modifying the HTML.

#+header: :noweb-ref __NREF__lilac_dot_el-lilac-publish-helpers
#+begin_src emacs-lisp
__NREF__lilac-link-to-child-blocks-from-parent
__NREF__lilac-prettify-source-code-captions
__NREF__lilac-human-readable-src-block-ids
#+end_src

** Org modifications

*** Give all source code blocks a =#+name: ...= field (HTML ID)

Only source code blocks that have a =#+name: ...= field (org name field) get an
HTML ID (org ID) assigned to it. The problem with polyblocks is that they are
not assigned an org name field by default.

Of course, we still want all polyblock to have an HTML ID, which can then be
extracted by [[(lilac-get-src-block-HTML_ID)][=lilac-get-src-block-HTML_ID=]] to build up the
=lilac-child-HTML_ID-hash-table= in [[* Link noweb references (link to child block
from parent block)]]. If we don't do this then parent source code blocks won't
be able to link to the polyblock at all (or vice versa).

Monoblocks with a =#+name: ...= field get a unique HTML ID assigned to it in
the form =orgN= where =N= is a hexadecimal number. By default Org generates a
random number for =N=, but we use a simple counter that increments, starting
from 0 (see [[*Do not use random numbers for the HTML =id= attribute]]).

Some source code blocks may not even be monoblocks, because a =#+name: ...=
field may simply be missing.

What we can do is inject a =#+name: ___anonymous-src-block-N= line (where =N= is
an incrementing number) into the beginning of the source code section of all
source code blocks that need it. Then we can construct an HTML link to any
source code block.

Note that the actual name =__anonymous-src-block-N= is not important, because it
gets erased and replaced with an =orgN= ID during HTML export. At that point we
make these =orgN= strings human-readable in [[* Use human-readable HTML IDs for
source code links]].

#+name: __NREF__UID-for-all-src-blocks
#+begin_src emacs-lisp
(defun lilac-UID-for-all-src-blocks (_backend)
  (let* ((all-src-blocks
           __NREF__all-src-blocks)
         (counter 0)
         (auto-names
           (-remove 'null
             (cl-loop for src-block in all-src-blocks collect
               (let* ((pos (org-element-property :begin src-block))
                      (parent-name-struct (lilac-get-src-block-name src-block))
                      (direct-name (org-element-property :name src-block))
                      (no-direct-name (s-blank? direct-name))
                      (prefix
                        (cond ((s-blank? (car parent-name-struct))
                               "___anonymous-src-block")
                              (t
                               (car parent-name-struct))))
                      (name-final
                       (format "#+name: %s-%x\n" prefix counter)))
                 (setq counter (1+ counter))
                 (when no-direct-name
                   (cons pos name-final)))))))
    (lilac-insert-strings-into-buffer auto-names)))
#+end_src

*** Automatic captions for Noweb source code blocks

For the parent/child source code blocks, we simply build these up by having
blocks named =#+name: __NREF__foo= or =#+header: :noweb-ref __NREF__foo=. Each
of these blocks can also reference other blocks by having a line =__NREF__bar=
inside its body. When defining such blocks, we really don't want to define the
=#+caption: ...= part manually because it gets tedious rather quickly. Yet we
still have to have these =#+caption: ...= bits (/for every =__NREF__...=
block!/) because that's the only way that Org's HTML exporter knows how to label
these blocks.

The code in this section automatically generates =#+caption: ...= text for these
=__NREF__...= blocks.

We want each =#+caption: ...= text to have the following items:

- [[(NSCB_NAME)][=NSCB_NAME=]] :: name of the Noweb source code block,
- [[(NSCB_POLYBLOCK_INDICATOR)][=NSCB_POLYBLOCK_INDICATOR=]] :: an indicator to show whether this block is
  broken up over multiple blocks, and
- [[(NSCB_LINKS_TO_PARENTS)][=NSCB_LINKS_TO_PARENTS=]] :: a link back up to a parent block (if any) where
  this block is used; can contain more than 1 parent if multiple parents refer
  to this same child block

/NSCB/ here means /Noweb source code block/. We loop through every source code
block and insert a =#+caption: ...= text into the buffer. This modified buffer
(with the three bits of information from above) is what is sent down the
pipeline for final export to HTML (i.e., the buffer modification does not affect
the actual buffer (=*.org= file)).

So assume that we already have the smart captions in a sorted [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][association list]]
(aka alist), where the KEY is the integer buffer position where this caption
should be inserted, and the VALUE is the caption itself (a string), like this:

#+caption: Caption locations
#+begin_src elisp
'((153  . "#+caption: ...")
  (384  . "#+caption: ...")
  (555  . "#+caption: ...")
  (684  . "#+caption: ...")
  (1051 . "#+caption: ..."))
#+end_src

We can use the KEY to go to that buffer position and insert the caption. However
the insertion operation mutates the buffer. This means if we perform the
insertions top-to-bottom, the subsequent KEY values will become obsolete. The
trick then is to just do the insertions in reverse order (bottom-to-top), so
that the remaining KEY values remain valid. This is what we do below, where
=smart-captions= is an alist like the one just described.

#+name: __NREF__smart-source-code-block-captions
#+begin_src emacs-lisp
(defun lilac-insert-noweb-source-code-block-captions (_backend)
  (let* ((parent-blocks
           __NREF__parent-blocks)
         (child-parents-hash-table
           __NREF__child-parents-hash-table)
         (all-src-blocks
           __NREF__all-src-blocks)
         (smart-captions
           __NREF__smart-captions))
    (lilac-insert-strings-into-buffer smart-captions)))

__NREF__smart-source-code-block-captions-helpers
#+end_src

(We'll get to the helper functions =smart-source-code-block-captions-helpers=
later as they obscure the big picture.)

Now we just have to construct =smart-captions=. The main difficulty is the
construction of [[(NSCB_LINKS_TO_PARENTS)][=NSCB_LINKS_TO_PARENTS=]], so most of the code will be concerned
about child-parent associations.

Why do we even need these source code blocks to link back to their parents? The
point is to make things easier to navigate. For example, if we have

#+caption: Sample Org-mode Noweb-style references
#+begin_src org
,#+name: parent-block
,#+begin_src bash
echo "Hello from the parent block"
__NREF__child-block-1
__NREF__child-block-2
,#+end_src

...

,#+name: __NREF__child-block-1
,#+begin_src bash
echo "I am child 1"
,#+end_src

...

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo -n "I am "
,#+end_src

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo "child 2"
,#+end_src
#+end_src

and we export this to HTML, ideally we would want both =__NREF__child-block-1=
and each of the =__NREF__child-block-2= blocks to include an HTML link back up
to =parent-block=. This would make it easier to skim the document and not get
too lost (any time you are looking at any particular source code block, you
would be able to just click on the link back to the parent (if there is one) to
see a higher-level view).

The key idea here is to build a hash table (=child-parents-hash-table=) where
the KEY is a child source code block and the VALUE is the parent block(s). Then
in order to construct [[(NSCB_LINKS_TO_PARENTS)][=NSCB_LINKS_TO_PARENTS=]] we just do a lookup against this
hash table to find the parent(s), if any.

The first thing we need is a list of parent source code blocks. We consider a
source code block a parent block if it has any Noweb references within its body.

#+name: __NREF__parent-blocks
#+begin_src emacs-lisp
(lilac-get-parent-blocks)
#+end_src

Then we construct the =child-parents-hash-table=. For each parent block, we get
all of its children (=child-names=), and use this data to construct a
child-parent association. Note that we use =cl-pushnew= instead of =push= to
deduplicate parents (i.e., when a single parent refers to the same child more
than once we do not want to link back to this same parent more than once from
the child block's caption).

#+name: __NREF__child-parents-hash-table
#+begin_src emacs-lisp
(lilac-mk-child-parents-hash-table parent-blocks)
#+end_src

Now that we have the child-parent associations, we have to look at all source
code blocks and check if

1. this source code block's name shows up at all in =child-parents-hash-table=,
   and if so
2. add a link to the parent ([[(NSCB_LINKS_TO_PARENTS)][=NSCB_LINKS_TO_PARENTS=]]).

Let's grab all source code blocks:

#+name: __NREF__all-src-blocks
#+begin_src emacs-lisp
(org-element-map (org-element-parse-buffer) 'src-block 'identity)
#+end_src

And now we can finally construct =smart-captions=:

#+name: __NREF__smart-captions
#+begin_src emacs-lisp
(lilac-mk-smart-captions child-parents-hash-table)
#+end_src

We used some helper functions up in [[__NREF__smart-source-code-block-captions][=__NREF__smart-source-code-block-captions=]];
let's examine them now.

=lilac-is-parent-block= checks whether a source code block is a parent (contains
noweb references to other child blocks in the form =__NREF__child-name=).

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-is-parent-block (src-block)
  (let ((body (org-element-property :value src-block)))
    (lilac-get-noweb-children body)))
#+end_src

=lilac-get-parent-blocks= retrieves all source code blocks that are parents
(which have =__NREF__...= references).

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-get-parent-blocks ()
  (org-element-map (org-element-parse-buffer) 'src-block
    (lambda (src-block)
       (if (lilac-is-parent-block src-block) src-block))))
#+end_src

=lilac-mk-child-parents-hash-table= takes all parent source code blocks and
generates a hash table where the KEY is the child block name and the VALUE is
the list of parents that refer to the child. When we loop through
=parent-blocks= below, we have to first =reverse= it because the function
=cl-pushnew= grows the list by prepending to it.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-mk-child-parents-hash-table (parent-blocks)
  (let ((hash-table (make-hash-table :test 'equal)))
    (mapc
     (lambda (parent-block)
      (let* ((parent-name (org-element-property :name parent-block))
             (parent-body (org-element-property :value parent-block))
             (child-names (lilac-get-noweb-children parent-body)))
        (mapc (lambda (child-name)
                (let* ((parents (gethash child-name hash-table)))
                  (if parents
                    (puthash child-name
                             (cl-pushnew parent-name parents)
                             hash-table)
                    (puthash child-name (list parent-name) hash-table))))
              child-names)))
     (reverse parent-blocks))
    hash-table))
#+end_src

=lilac-mk-smart-captions= generates an alist of buffer positions (positive
integer) and the literal =#+caption: ...= text that needs to be inserted back
into the buffer.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp -r -l ";ref:%s"
(defun lilac-mk-smart-captions (child-parents-hash-table)
  (-remove 'null
    (cl-loop for src-block in __NREF__all-src-blocks collect
      (let* ((child (lilac-get-src-block-name src-block))
             (child-name (car child))
             (NSCB_NAME (format "=%s= " child-name))                  ;ref:NSCB_NAME
             (NSCB_POLYBLOCK_INDICATOR                                ;ref:NSCB_POLYBLOCK_INDICATOR
               (if (lilac-get-noweb-ref-polyblock-name src-block)
                   "(polyblock)"
                 ""))
             (polyblock-counter
              (gethash child-name lilac-polyblock-names-totals 0))
             (polyblock-counter-incremented
              (puthash child-name (1+ polyblock-counter)
                       lilac-polyblock-names-totals))
             (parents (gethash child-name child-parents-hash-table))
             (parents-zipped (lilac-enumerate parents))
             (pos (org-element-property :begin src-block))
             (NSCB_LINKS_TO_PARENTS                                   ;ref:NSCB_LINKS_TO_PARENTS
              (mapconcat (lambda (parent-with-idx)
                           (format " [[%s][%d]]"
                                   (nth 1 parent-with-idx)
                                   (1+ (nth 0 parent-with-idx))))
                         parents-zipped " "))
             (smart-caption
              (concat
                "#+caption: "
                NSCB_NAME
                NSCB_POLYBLOCK_INDICATOR
                NSCB_LINKS_TO_PARENTS
                "\n")))
        (when parents (cons pos smart-caption))))))
#+end_src

=lilac-insert-strings-into-buffer= takes an alist of buffer positions and
strings and inserts them all into the buffer.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-insert-strings-into-buffer (pos-strings)
  (cl-loop for pos-string in (reverse pos-strings) do
        (let ((pos (car pos-string))
              (str (cdr pos-string)))
          (goto-char pos)
          (insert str))))
#+end_src

=lilac-get-noweb-children= extracts all Noweb references in the form
"=__NREF__foo=" from a given multiline string, returning a list of all such
references. This function expects at most 1 Noweb reference per line. The return
type is a list of strings.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-get-noweb-children (s)
  (let* ((lines (split-string s "\n"))
         (refs (-remove 'null
                 (mapcar
                  (lambda (line)
                   (if (string-match (lilac-nref-rx nil) line)
                       (match-string-no-properties 1 line)))
                  lines))))
    refs))
#+end_src

=lilac-get-noweb-ref-polyblock-name= gets the string =__NREF__foo= in a
=#+header: :noweb-ref __NREF__foo= line for a source code block.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-get-noweb-ref-polyblock-name (source-code-block)
  (let* ((headers (org-element-property :header source-code-block))
         (noweb-ref-name
          (nth 0
           (-remove 'null
            (mapcar
             (lambda (header)
               (if (string-match ":noweb-ref \\(.+\\)" header)
                   (match-string-no-properties 1 header)))
             headers)))))
    noweb-ref-name))
#+end_src

Note that a child source block can have two ways of defining its name. The first
is with the direct =#+name: __NREF__foo= style ([[glossary: monoblock][monoblock]]), and the second way
is with a line like =#+header: :noweb-ref __NREF__foo= ([[glossary: polyblock][polyblock]]). Here
=lilac-get-src-block-name= grabs the name of a (child) source code block, taking
into account these two styles. For polyblock names, we mark it as such with a
=(polyblock)= string, which is used later for the [[(NSCB_POLYBLOCK_INDICATOR)][=NSCB_POLYBLOCK_INDICATOR=]].

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-get-src-block-name (src-block)
  (let* ((name-direct (org-element-property :name src-block))
         (name-indirect (lilac-get-noweb-ref-polyblock-name src-block)))
    (if name-indirect
        `(,name-indirect "(polyblock)")
        `(,name-direct ""))))
#+end_src

Next we have some helpers to enumerate through a list just like in Python. The
index starts at 0 (same as Python).

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-enumerate (lst &optional start)
  (let ((ret ()))
    (cl-loop for index from (if start start 0)
           for item in lst
           do (push (list index item) ret))
    (reverse ret)))

; See https://emacs.stackexchange.com/a/7150.
(defun lilac-matches (regexp s &optional group)
  "Get a list of all regexp matches in a string"
  (if (= (length s) 0)
      ()
      (save-match-data
        (let ((pos 0)
              (matches ()))
          (while (string-match regexp s pos)
            (push (match-string (if group group 0) s) matches)
            (setq pos (match-end 0)))
          (reverse matches)))))
#+end_src

*** Human-readable UIDs (Headings, aka headlines)

By default Org does a terrible job of naming HTML =id= fields for headings. By
default it uses a randomly-generated number. In [[* Do not use random numbers for
the HTML =id= attribute]] we tweak this behavior to use a deterministic,
incrementing number starting from 0. However while this solution gets rid of the
nondeterminism, it still results in human-unfriendly =id= attributes because
they are all numeric (e.g. =org00000a1=, =org00000f3=, etc).

For headings, we can do better because in practice they already mostly have
unique contents, which should work most of the time to act as an =id=. In other
words, we want all headings to have HTML IDs that are patterned after their
contents. This way we can have IDs like =some-heading-name-1= (where the
trailing =-1= is only used to disambiguate against another heading of the same
name) instead of =org00000a1= (numeric hex).

For each heading, we insert a =CUSTOM_ID= property. This makes Org refer to this
=CUSTOM_ID= instead of the numeric =org...= link names. We append this headline
property just below every headline we find in the buffer. The actual
construction of the =CUSTOM_ID= (=headline-UID= in the code below) is done by
=lilac-get-unique-id=.

#+Name: __NREF__UID-for-all-headlines
#+begin_src emacs-lisp
(defun lilac-UID-for-all-headlines (_backend)
  (let* ((all-headlines
           (org-element-map (org-element-parse-buffer) 'headline 'identity))

         (headline-uid-hash-table (make-hash-table :test 'equal))
         (headline-UIDs
           (-remove 'null
             (cl-loop for headline in all-headlines collect
               (let* ((headline-UID
                       (lilac-get-unique-id headline headline-uid-hash-table))
                      ;; Get the position just after the headline (just
                      ;; underneath it).
                      (pos (progn
                             (goto-char (org-element-property :begin headline))
                             (re-search-forward "\n"))))
                 (cons pos (concat
                            ":PROPERTIES:\n"
                            ":CUSTOM_ID: " headline-UID "\n"
                            ":END:\n")))))))
    (lilac-insert-strings-into-buffer headline-UIDs)))

__NREF__get-unique-id
#+end_src

=lilac-get-unique-id= converts a given headline to its canonical form (every
non-word character converted to a dash) and performs a lookup against the hash
table. If the entry exists, it looks up a =entry-N= value in a loop with =N=
increasing until it sees that no such key exists (at which point we know that we
have a unique ID).

#+name: __NREF__get-unique-id
#+begin_src emacs-lisp
(defun lilac-get-unique-id (headline hash-table)
  (let* ((name (org-element-property :raw-value headline))
         (disambiguation-number 0)
         (key (concat "h-" (lilac-normalize-string name)))
         (val (gethash key hash-table)))
    ;; Discard the key if a value already exists. This drives up the
    ;; disambiguation number.
    (while val
      (setq disambiguation-number (1+ disambiguation-number))
      (setq key (concat "h-"
                        (lilac-normalize-string
                         (format "%s-%s" name disambiguation-number))))
      (setq val (gethash key hash-table)))
    (puthash key t hash-table)
    key))

(defun lilac-normalize-string (s)
  (string-trim
    (replace-regexp-in-string "[^A-Za-z0-9]" "-" s)
    "-"
    "-"))
#+end_src

** HTML modifications

*** Use human-readable HTML IDs for source code links

Recall that there are 2 types of source code blocks: [[glossary: monoblock][monoblocks]] and [[glossary: polyblock][polyblocks]].

Polyblocks do get a name field attached to them during the [[*Give all source code blocks a =#+name: ...= field (HTML ID)][Org
modification stage]], in the format =___anonymous-src-block-N=. These names are
for HTML link generation only, because the user won't see them --- they will
instead just see =org000012= or some such. In fact, all monoblocks are also
given these random-looking (and unstable) =org...= HTML IDs.

And therein lies the problem: if a user decides to bookmark a particular source
code block, whether a monoblock or polyblock, they will link to an
=org...=-style ID and chances are that this link will break over time.

This is exactly the same problem we have for headlines. For headlines we solved
the problem with a [[* Human-readable UIDs (Headings, aka headlines)][hash table]], and we need to do the same thing here. The major
difference, though, is that unlike headlines which can accept a =CUSTOM_ID= Org
property, source code blocks have no such facility. So instead of modifying the
buffer (as we do for headlines), we have to modify the final HTML output
instead.

The solution is to simply look at all source code block links, then modify the
~id=...~ part so that it looks like a more human-readable ID. We can extract the
human-readable ID by looking at the smart captions inside the
=<label>...</label>= area for both monoblocks and polyblocks. And then it's just
a matter of doing a basic search-and-replace across the entire buffer (HTML
file).

We have to do a search-and-replace across the entire file because we may also
have manual links to source code blocks (although --- maybe it's just not worth
it because we can't refer to polyblocks anyway by name).

#+name: __NREF__lilac-human-readable-src-block-ids
#+begin_src emacs-lisp -r -l ";ref:%s"
(setq lilac-org_id-human_id-hash-table (make-hash-table :test 'equal))
(setq lilac-human_id-count-hash-table (make-hash-table :test 'equal))
(setq lilac-human_id-org_id-hash-table (make-hash-table :test 'equal))

(defun lilac-populate-org_id-human_id-hash-table (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let* ((block-name (lilac-get-src-block-name-from-html src-block-html))
           (block-name-count (gethash block-name
                                      lilac-human_id-count-hash-table
                                      0))
           (orgid (lilac-get-src-block-HTML_ID src-block-html)))
      (when orgid
        (puthash block-name
                 (1+ block-name-count)
                 lilac-human_id-count-hash-table)
        (cond ((= block-name-count 0)
                (progn
                  (puthash orgid
                           block-name
                           lilac-org_id-human_id-hash-table)
                  (puthash block-name
                           orgid
                           lilac-human_id-org_id-hash-table)))
              ((= block-name-count 1)
                (let* ((orgid-first-block
                        (gethash block-name lilac-human_id-org_id-hash-table)))
                  (puthash orgid-first-block
                           (format "%s-1" block-name)
                           lilac-org_id-human_id-hash-table)
                  (puthash orgid
                           (format "%s-%d" block-name (1+ block-name-count))
                           lilac-org_id-human_id-hash-table)))
              (t
                 (puthash orgid
                          (format "%s-%d" block-name (1+ block-name-count))
                          lilac-org_id-human_id-hash-table))))
      src-block-html)))

(defun lilac-replace-org_ids-with-human_ids (entire-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let ((html-oneline (lilac-to-single-line entire-html)))
      (maphash
       (lambda (k v)
        (when (and k v)
         (setq html-oneline
               (replace-regexp-in-string
                (rx-to-string `(and " id=" (* (not "\"")) "\"" ,k "\""))
                (format " id=\"%s\"" v) html-oneline))
         (setq html-oneline
               (replace-regexp-in-string
                (rx-to-string `(and " href=" (* (not "\"")) "\"#" ,k "\""))
                (format " href=\"#%s\"" v) html-oneline))))
       lilac-org_id-human_id-hash-table)
      (lilac-to-multi-line html-oneline))))

(defun lilac-to-single-line (s)
  (replace-regexp-in-string "\n" "<<<LILAC_NEWLINE>>>" s))

(defun lilac-to-multi-line (s)
  (replace-regexp-in-string "<<<LILAC_NEWLINE>>>" "\n" s))
#+end_src

*** Pretty source code captions

The default HTML export creates a =<div>= around the entire source code block.
This =<div>= will have a =<pre>= tag with the source code contents, along with a
preceding =<label>= if there was a =#+caption: ...= for this block. Because of
automatic generation of =#+caption: ...= bits for all Noweb-style references in
Section [[* Automatic captions for Noweb source code blocks]], the vast majority of
source code blocks will have this =<label>= tag.

By default the =<label>= tag includes a Listing number ("Listing 1: ...",
"Listing 17: ...", etc), because Org likes to numerically number every single
source code block. We simply drop these listing numbers and instead link back to
the parent block(s) that refer to this source code block (as a Noweb reference),
if any.

For polyblock chains, we also have to keep track of how long each chain is. This
way, each block in the chain will get a unique fraction denoting the position of
that block in the overall chain. (If we don't do this, then all of the captions
for all polyblocks in the same chain will look identical, which can be a bit
confusing). In order to generate these fractions we have to keep around a couple
hash tables for bookkeeping.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions
#+begin_src emacs-lisp
(setq lilac-polyblock-names (make-hash-table :test 'equal))
(setq lilac-polyblock-names-totals (make-hash-table :test 'equal))
#+end_src

First here is the overall shape of the function. If there is no caption
(=<label>= tag in the HTML), then we return the original HTML unmodified.
Otherwise we prettify this label (removing the "Listing N: ..." text, including
a link back to the parent, etc) along with the body text (linkifying references
to child Noweb references), and return both inside a new
=lilac-pre-with-caption= div.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions
#+begin_src emacs-lisp
(defun lilac-prettify-source-code-captions (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let* (
           __NREF__lilac-prettify-source-code-captions-let-bindings)
      (if (s-blank? caption)
          src-block-html
        (concat
          leading-div
            "<div class=\"lilac-pre-with-caption\">"
              caption-text
              body-with-replaced-pre
            "</div>"
          "</div>")))))
#+end_src

Now let's get into the bindings. The first order of business is parsing the HTML
bits into separate parts.

=div-caption-body= is the original HTML but all on a single line. We need to
work with the text without newlines because Emacs Lisp's regular expressions
don't work well with newlines. That's why we call
=lilac-get-source-block-html-parts-without-newlines=.

We need =leading-div= because this outermost =div= contains various class and
other information that Org generates. We don't want to lose any of that info.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions-let-bindings
#+begin_src emacs-lisp
(div-caption-body (lilac-get-source-block-html-parts-without-newlines
                   src-block-html))
(leading-div (nth 0 div-caption-body))
(caption (nth 1 div-caption-body))
(body (nth 2 div-caption-body))
(body-with-newlines
 (lilac-to-multi-line body))
#+end_src

=lilac-get-source-block-html-parts-without-newlines= is defined below. It's just
a list of parsed pieces of HTML.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions
#+begin_src emacs-lisp
(defun lilac-get-source-block-html-parts-without-newlines (src-block-html)
    (let* ((one-line (lilac-to-single-line src-block-html))
           (leading-div
             (let ((div-match
                    (string-match "<div [^>]+>" one-line)))
               (match-string-no-properties 0 one-line)))
           (caption
             (let* ((caption-match
                      (string-match "<label [^>]+>.*?</label>" one-line)))
               (if caption-match
                   (match-string-no-properties 0 one-line)
                   "")))
           (body (progn (string-match "<pre [^>]+>.*?</pre>" one-line)
                        (match-string-no-properties 0 one-line))))
      `(,leading-div ,caption ,body)))
#+end_src

Now come the bits for identifying the human-readable source code block name by
looking at the caption (=<label>=). We extract it from the =<code>= tags that we
expect to see inside the =<label>= tag.

It may very well be the case that the block will not have a name, in which
case we just name it as =anonymous=. A source code block is anonymous if:

1. it does not have a ="#+name: ..."= line, or
2. it does not have a ="#+header: :noweb-ref ..."= line.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions-let-bindings
#+begin_src emacs-lisp
(caption-parts
  (let* ((caption-match
           (string-match "<label [^>]+>\\(.*?\\)</label>" caption)))
    (if caption-match
        (match-string-no-properties 1 caption)
        "")))
(source-block-name-match
  (string-match
    (rx-to-string
      '(and
            "<code>"
            (group (+ (not "<")))
            "</code>"))
    caption-parts))
#+end_src

Because the name =anonymous= is meaningless (there can be more than one such
block), we need to disambiguate it. We do this by appending a numeric suffix to
all source code blocks with the same human-readable =source-block-name=.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions-let-bindings
#+begin_src emacs-lisp
(source-block-name
  (if source-block-name-match
      (match-string-no-properties 1 caption-parts)
      "anonymous"))
(source-block-counter
 (gethash source-block-name lilac-polyblock-names 0))
(source-block-counter-incremented
 (puthash source-block-name (1+ source-block-counter)
          lilac-polyblock-names))
#+end_src

Here we do some additional introspection into the =<pre>= tag which holds the
body text (the actual source code in the source code block). The =pre-id= is
important because it gives us a unique ID (linkable ID) to the body text. We'll
be using this when linking to a child block from a parent block.

Sadly, Org does not give every source code block an ~id=...~ field. Notably,
polyblocks do not get an =id= except for the very first block in the chain. And
so we inject an =id= for every =<pre>= tag ourselves. But first we have to see
if the =<pre>= tag has an ID already with =pre-id-match=.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions-let-bindings
#+begin_src emacs-lisp
(pre-id-match
  (string-match
    (rx-to-string
      '(and
            "<pre "
            (* (not ">"))
            "id=\""
            (group (+ (not "\"")))))
    body))
#+end_src

Now we can create a universal =pre-id= for all =<pre>= tags, and make sure that
all =<pre>= tags without a given =id= can use =pre-id-universal= as a fallback.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions-let-bindings
#+begin_src emacs-lisp
(pre-id-universal
  (if pre-id-match
      (match-string-no-properties 1 body)
    (format "%s-%s"
            source-block-name
            source-block-counter-incremented)))
(pre-tag-match
  (string-match
    (rx-to-string
      '(and
            "<pre "
            (group (* (not ">")))
            ">"))
    body))
(pre-tag-entire (match-string-no-properties 0 body))
(pre-tag-contents (match-string-no-properties 1 body))
(body-with-replaced-pre
  (if pre-id-match
      body-with-newlines
      (string-replace pre-tag-entire
                      (concat "<pre " pre-tag-contents
                              (format " id=\"%s\"" pre-id-universal) ">")
                      body-with-newlines)))
#+end_src

For polyblocks though, we also want to show a fraction in the form =(N/TOTAL)=
where =N= is the numeric position of the polyblock (1 for the head, 2 for the
second one in the chain, 3 for the third, and so on), and =TOTAL= is the total
number of polyblocks in the chain. This way the reader can get some idea about
how many pieces there are as the overall chain is explained in the prose. This
=(N/TOTAL)= fraction is called a =polyblock-indicator=.

Note that we use the =(polyblock)= marker text from [[(NSCB_POLYBLOCK_INDICATOR)][=NSCB_POLYBLOCK_INDICATOR=]]
to detect whether we're dealing with a polyblock, because otherwise all of those
anonymous blocks will get treated as part of a single polyblock chain.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions-let-bindings
#+begin_src emacs-lisp
(polyblock-chain-total
 (gethash source-block-name lilac-polyblock-names-totals 0))
(polyblock-indicator
 (if (and
      (> polyblock-chain-total 0)
      (string-match "\(polyblock\)" caption-parts))
     (format "(%s/%s) "
             source-block-counter-incremented
             polyblock-chain-total)
   ""))
#+end_src

Most source code blocks have a parent where this code block's contents should be
inserted into. There could be more than one parent if the code is reused
verbatim in multiple places.

We generate a link back to the parent (or parents), by extracting the links
(=href= bits in the =<a>= (aka anchor) tags) found in the caption. These links
were generated for us in Section [[* Automatic captions for Noweb source code
blocks]]; our job is to prettify them with CSS classes and such.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions-let-bindings
#+begin_src emacs-lisp
(parent-id-regexp
    (rx-to-string
      '(and
            " <a href=\""
            (group (+ (not "\""))))))
(parent-ids-with-idx
 (lilac-enumerate
  (lilac-matches parent-id-regexp caption-parts 1) 1))
(parent-links
  (mapconcat (lambda (parent-id-with-idx)
               (let ((parent-id (car (cdr parent-id-with-idx)))
                     (idx (car parent-id-with-idx)))
                  (format (concat
                           "<span class="
                           "\"lilac-caption-parent-link\">"
                           "<a href=\"%s\">%s</a></span>")
                    parent-id
                    (if (= idx 1)
                        (string-remove-prefix
                         "__NREF__" source-block-name)
                      idx))))
             parent-ids-with-idx ""))
#+end_src

Every source code block gets a self-link back to itself (shown as a link icon
"🔗"). This goes at the very end of the caption on the far right (top right
corner of the source code block's rectangular area).

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions-let-bindings
#+begin_src emacs-lisp
(link-symbol
  (format (concat "<span class=\"lilac-caption-link-symbol\">"
                  "<a href=\"#%s\">&#x1f517;</a></span>")
    pre-id-universal))
#+end_src

Finally, we're ready to recompose the overall source code block. We make a
distinction for source code blocks that have links back to a parent (or multiple
parents). In all cases we make sure to remove Org's default "Listing N:" prefix.

#+header: :noweb-ref __NREF__lilac-prettify-source-code-captions-let-bindings
#+begin_src emacs-lisp
(caption-without-listing-prefix
 (replace-regexp-in-string "<span.+?span>" "" caption))
(caption-text
 (if (> (length parent-links) 0)
     (concat
       "<div class=\"lilac-caption\">"
         parent-links
         polyblock-indicator
         link-symbol
       "</div>")
     (concat
       "<div class=\"lilac-caption\">"
         caption-without-listing-prefix
         link-symbol
       "</div>")))
#+end_src

*** Link noweb references (link to child block from parent block)

In [[* Pretty source code captions]] we tweaked the HTML so that source code blocks
could link back up to their parents. In this section we are concerned with the
opposite --- linking to child blocks from the parents. For example, consider the
following code:

#+caption: Sample Org-mode Noweb-style references
#+begin_src org
,#+name: parent-block
,#+begin_src bash
echo "Hello from the parent block"
__NREF__child-block-1
__NREF__child-block-2
,#+end_src

...

,#+name: __NREF__child-block-1
,#+begin_src bash
echo "I am child 1"
,#+end_src

...

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo -n "I am "
,#+end_src

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo "child 2"
,#+end_src
#+end_src

What we want to do is to make the =__NREF__child-block-1= and
=__NREF__child-block-2= references inside =parent-block= to link to their
definitions, so that the reader can just click on them to go to see how they're
defined. Unfortunately Org mode doesn't do this by default so we have to do this
ourselves.

In the case of =__NREF__child-block-2=, it is defined in multiple blocks so we
would want to link to the very first block.

We cannot use a =org-export-before-parsing-hook= like we did in [[* Toplevel
 publishing function (=lilac-publish=)]] because at that stage of processing, we
are dealing with Org mode syntax. Any modifications we make to the parent
source code block will be treated as text upon HTML export. Thankfully Org mode
allows customizations on generated HTML through the
=org-export-filter-src-block-functions= variable. This variable is analogous to
=org-export-before-parsing-hook=, but operates at the HTML level (not at the
Org syntax level) for source code blocks, which is exactly what we need.

So we have to craft valid HTML links (not Org links) to the child source code
blocks. For this we need the actual =id= part of the HTML =<pre>...= block that
will hold the source code. That is, the algorithm should be something like:

1. for every parent source code block,
2. for every child block (noweb) referenced in the body, insert an HTML link to
   the child block (lookup in =lilac-child-HTML_ID-hash-table=).

The only thing remaining is the construction of
=lilac-child-HTML_ID-hash-table=. We can construct this by mapping through all
source code blocks and getting the name which can be just drawn from the =<label
...>= HTML tag, thanks to the smart captions we inserted for all child blocks
earlier in [[* Automatic captions for Noweb source code blocks]]. This hash table
will hold mappings from child source block names to their HTML ID's.

Now that we have a high-level understanding, let's walk through the
implementation. First here's the code to populate the
=lilac-child-HTML_ID-hash-table=.

#+header: :noweb-ref __NREF__lilac-link-to-child-blocks-from-parent
#+begin_src emacs-lisp -r -l ";ref:%s"
(setq lilac-child-HTML_ID-hash-table (make-hash-table :test 'equal))

(defun lilac-populate-child-HTML_ID-hash-table (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let* ((child-name (lilac-get-src-block-name-from-html src-block-html))
           (child-HTML_ID (lilac-get-src-block-HTML_ID src-block-html))
           (child-HTML_ID-exists-already
            (gethash child-name lilac-child-HTML_ID-hash-table nil)))
      ; Only process child blocks that have an HTML ID.
      (if (and child-HTML_ID (not child-HTML_ID-exists-already))
          (puthash child-name child-HTML_ID lilac-child-HTML_ID-hash-table))
      ; Return src-block-html as-is (no modifications).
      src-block-html)))

;ref:lilac-get-src-block-HTML_ID
(defun lilac-get-src-block-HTML_ID (src-block-html)
  (let ((match (string-match "<pre [^>]+?id=\"\\([^\"]+\\)\">" src-block-html)))
    (if match (match-string-no-properties 1 src-block-html))))
#+end_src

We need to get the source block name (the name of the child) from the HTML. We
do this in =lilac-get-src-block-name-from-html= below. Either there is a
=__NREF__...= text in the =<code>= tag within a =<label>= tag (from [[* Automatic
captions for Noweb source code blocks]]), or there is just a plain  =<label>= as
a result of a manually-written =#+caption: ...= bit. We use either one. Note
that the latter category assumes that the user used unique caption labels for
all blocks; if the user manually creates non-unique captions, this will probably
break. (FIXME: add test to confirm breakage...?)

#+header: :noweb-ref __NREF__lilac-link-to-child-blocks-from-parent
#+begin_src emacs-lisp -r -l ";ref:%s"
(defun lilac-get-src-block-name-from-html (src-block-html)
  (let* ((match-nref (string-match
                      (concat
                       "<label.+?<code>"
                       (lilac-nref-rx nil)
                       "</code>")
                      src-block-html))
         (match-raw (if (not match-nref)
                        (string-match
                         (rx-to-string
                          '(and
                            "<label"
                            (+ (not ">"))
                            ">"
                            (group (*? anychar))
                            "</label>"))
                         src-block-html)))
         (matched-contents (match-string-no-properties 1 src-block-html)))
    (if match-nref
        matched-contents
        (if match-raw
            (lilac-clean-up-match-raw matched-contents)))))
#+end_src

If the user used manual captions, we have to remove the "Listing N: ..." text
that Org automatically inserts.

#+header: :noweb-ref __NREF__lilac-link-to-child-blocks-from-parent
#+begin_src emacs-lisp -r -l ";ref:%s"
(defun lilac-clean-up-match-raw (s)
  (let* ((normalized (lilac-normalize-string s))
         (rx (rx-to-string
                '(and
                  "Listing-"
                  (+ (any digit))
                  (+ "-")
                  "span"
                  (* "-")
                  (group (+ anychar)))))
         (match (string-match rx normalized)))
    (if match
        (match-string-no-properties 1 normalized)
        normalized)))
#+end_src

Now we have everything we need to add HTML links into the body of the source
code block directly. We search for the child name (which begins with a
=__NREF__...=, which is defined in =lilac-nref-rx=), and perform a string
replacement, adding in the link to the child block.

#+header: :noweb-ref __NREF__lilac-link-to-child-blocks-from-parent
#+begin_src emacs-lisp -r -l ";ref:%s"
(defun lilac-link-to-children-from-parent-body (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let* ((div-caption-body (lilac-get-source-block-html-parts-without-newlines
                              src-block-html))
           (leading-div (nth 0 div-caption-body))
           (caption (nth 1 div-caption-body))
           (body (nth 2 div-caption-body))
           (body-linkified-without-newlines
            (replace-regexp-in-string
             (lilac-nref-rx nil)
             (lambda (child-name-text)
                 (let* ((HTML_ID (gethash child-name-text
                                          lilac-child-HTML_ID-hash-table)))
                  (if HTML_ID
                      (concat "<span class=\"lilac-child-link-from-parent\">"
                              "<a href=\"#" HTML_ID "\">"
                              (string-remove-prefix "__NREF__" child-name-text)
                              "</a></span>")
                      child-name-text)))
             body))
           (body-linkified-with-newlines
            (lilac-to-multi-line body-linkified-without-newlines)))
      (concat leading-div caption body-linkified-with-newlines "</div>"))))
#+end_src

*** Search and replace hardcoded things

Org's HTML export hardcodes some things. We have to do some manual surgery to
set things right. First let's define a generic search-and-replace function. This
function is based on [[https://emacs.stackexchange.com/a/2382/13006][this example]].

#+header: :noweb-ref __NREF__lilac_dot_el-search-replace
#+begin_src emacs-lisp
(defun lilac-replace-from-to (str repl)
  (interactive "sString: \nsReplacement: ")
  (save-excursion
    (goto-char (point-min))
    (replace-string str repl)))
#+end_src

Here's a basic wrapper to perform the string replacement for an HTML file based
on the current buffer name.

#+header: :noweb-ref __NREF__lilac_dot_el-search-replace
#+begin_src emacs-lisp
(defun lilac-replace-from-to-html (str repl &optional regex)
  (let ((html-file-name (concat
                         (file-name-sans-extension (buffer-file-name))
                         ".html")))
    (find-file html-file-name)
    (goto-char 0)
    (if regex
        (replace-regexp str repl)
        (lilac-replace-from-to str repl))
    (save-buffer)))
#+end_src

Now we do some basic search-and-replace commands to clean up the exported HTML
file from Emacs (instead of invoking =sed=).

**** MathJax with line breaking support

Surprisingly, MathJax v3 (which Org ships with) [[https://github.com/mathjax/MathJax/issues/2312][does not support manual line
breaks]]. However, line breaks are supported in the new [[https://github.com/mathjax/MathJax/releases/tag/4.0.0-beta.4][v4 alpha version]]. So use
that.

#+name: __NREF__lilac-publish-fix-mathjax-version
#+begin_src emacs-lisp
(lilac-replace-from-to-html
 "mathjax@3/es5/tex-mml-chtml.js\">"
 "mathjax@4.0.0-beta.4/tex-mml-chtml.js\">")
#+end_src

We have to include the trailing (and somewhat redundant) =\">= so that the
function does not replace the text above as well as the intended raw HTML
(hardcoded) bits that we want to replace.

**** Bibliography (citations)

This cleans up the inline styles for citations. Again we include some additional
characters in the pattern (notably the left angle bracket (=<=)) so that the
text below itself does not get recognized and replaced.

#+name: __NREF__lilac-publish-fix-inline-styles
#+begin_src emacs-lisp
(lilac-replace-from-to-html
 ".csl-right-inline{margin: 0 0 0 1em;}<"
 ".csl-right-inline{margin: 0 0 0 2em;}<")
#+end_src

We also do some replacements for the bibliography entries themselves. Namely,
each entry has the following (odd) structure by default:

#+begin_example
<div class="csl-entry"><a id="citeproc_bib_item_1"></a> ... </div>
#+end_example

and instead we delete the content-less link anchor and instead move th ID to the
parent div, like this:

#+begin_example
<div class="csl-entry" id="citeproc_bib_item_1"> ... </div>
#+end_example

This way we can target this surrounding parent div for the =active= HTML class
attribute (instead of the empty link anchor) to style the entire entry when we
click a link to go to it.

#+name: __NREF__lilac-publish-fix-bibliography-ids
#+begin_src emacs-lisp
(lilac-replace-from-to-html
 "\"csl-entry\"><a \\(id=\"[^\"]+\"\\)></a>"
 "\"csl-entry\" \\1>"
 t)
#+end_src

And here we style these entries.

#+name: __NREF__css-bibliography
#+begin_src css
.csl-entry {
    padding: 0.5em;
    border-style: solid;
    border-width: 1px;
    border-radius: 5px;
    border-color: var(--clear);
}

.outline-2 .csl-bib-body .active {
    __NREF__css-active-item-headline
}
#+end_src

**** Glossary (description lists)

Similar to the bibliography entries, the description lists in HTML have empty
link anchors in them, because of the way we insert the link anchors manually in
the Org text (this is a convention we follow; see the [[* Glossary]] for examples).
We get rid of these anchors and instead create a surrounding div around it, so
that we can highlight the enclosed =<dt>= (description term) and =<dd>=
(description details).

#+name: __NREF__lilac-publish-fix-description-lists
#+begin_src emacs-lisp
(lilac-replace-from-to-html
 "<dt>"
 "<div class=\"lilac-description-list-entry\"><dt>"
 t)
(lilac-replace-from-to-html
 "\"lilac-description-list-entry\"><dt><a \\(id=\"[^\"]+\"\\)></a>"
 "\"lilac-description-list-entry\" \\1><dt>"
 t)
(lilac-replace-from-to-html
 "</dd>"
 "</dd></div>")
#+end_src

And here we style it.

#+name: __NREF__css-description-lists
#+begin_src css
.lilac-description-list-entry {
    padding: 0.2em 0.5em 0.5em 0.5em;
    border-style: solid;
    border-width: 1px;
    border-radius: 5px;
    border-color: var(--clear);
}

.org-dl .active {
    __NREF__css-active-item-headline
}
#+end_src

*** Custom HTML "head" section

If a user wants to use a custom Google web font, they have to make the HTML page
pull it in in the =<head>= part of the page. This requires modifying the HTML.
In order to facilitate this, we provide a replaceable piece of text that can be
swapped out for the value that the user can provide. Specifically, we inject the
line =<!-- LILAC_HTML_HEAD -->= into the HTML, and this can be replaced by the
value of the =lilac-html-head= variable in Emacs Lisp (which can be provided by
the user when they invoke the =lilac-publish= function).

#+name: __NREF__lilac-publish-inject-custom-html-head
#+begin_src emacs-lisp
(if (boundp 'lilac-html-head)
    (lilac-replace-from-to-html
     "<!-- LILAC_HTML_HEAD -->"
     lilac-html-head))
#+end_src

** JavaScript

We use JavaScript to make the HTML document more useful. The primary concern is
to make it easier to navigate around the various intra-document links.

#+name: lilac.js
#+caption: lilac.js
#+begin_src js :tangle lilac.js :eval no
__NREF__js-automatically-link-headlines
__NREF__js-toc-scrollspy
__NREF__js-highlight-link-destination
__NREF__js-scroll-to-history-item
#+end_src

In the[[* Create =lilac.theme= file][=lilac.theme=]] file, we include =lilac.js= and also jQuery
because we depend on it.

#+name: __NREF__lilac-theme-js
#+begin_src org
,#+HTML_HEAD: <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
,#+HTML_HEAD: <script src="lilac.js"></script>
#+end_src

*** Self-linked headlines

Every HTML element =h2= to =h6= (which encode the Org mode headlines) already
come with a unique ID, but they are not linked to themselves. We add the
self-links here, which makes it easy for users to link to them directly when
they're reading the page.

The JavaScript below is taken from [[https://github.com/listx/listx_blog/blame/8e6e7b533d89f77a6939e5eda9fd9d990d25a7a9/misc.js#L1][here]].

#+name: __NREF__js-automatically-link-headlines
#+begin_src js
$(function() {
    $("h2,h3,h4,h5,h6").each(function() {
        var $this = $(this);
        var href = $this.attr("id");
        $this.wrapInner(
            $("<a/>").attr("href", "#" + href)
                     .addClass("section-heading"));
    });
});
#+end_src

Linkifying itself makes all the headlines blue (the default color for links).
This is a bit distracting, so make them black.

#+header: :noweb-ref __NREF__css-source-code-section-headlines
#+begin_src css
a.section-heading {
    color: black;
    text-decoration: none;
    display: block;
}
#+end_src

Lastly, show a link anchor icon when the user hovers over a headline. We have
the icon present at all times; we only make it visible when we hover over the
heading. This way, there is no "jumping" of any kind when the heading is about
the same size as the width of the enclosing =div= (it can jump when displaying
the icon results in a new line break).

#+header: :noweb-ref __NREF__css-source-code-section-headlines
#+begin_src css
a.section-heading::after {
    opacity: 0;
    transition: opacity 150ms;
    content: "\1f517";
    padding-left: 1rem;
}
a.section-heading:hover::after {
    opacity: 1;
    transition: opacity 150ms;
    content: "\1f517";
}
#+end_src

*** Table of contents sidebar

By default Org's HTML export gives us a "Table of Contents". We make several
modifications to it:

1. remove the "Table of Contents" phrase because it doesn't add much value,
2. convert it to a sidebar on the left, and
3. track the current headline.

**** Delete "Table of Contents" text

#+name: __NREF__lilac-publish-delete-toc-text
#+begin_src emacs-lisp
(lilac-replace-from-to-html
 "<h2>Table of Contents</h2>"
 "")
#+end_src

**** Convert "Table of Contents" to a sidebar on the left

#+header: :noweb-ref __NREF__css-toc
#+begin_src css
#table-of-contents {
    position: fixed;
    top: 0;
    float: left;
    margin-left: -300px;
    width: 280px;
    font-size: 90%;
    border-right-style: solid;
    border-right-width: 1px;
    border-right-color: var(--border-light);
}
#text-table-of-contents {
    overflow-y: scroll;
    height: 100vh;
    padding-right: 20px;
    padding-left: 5px;
}
#text-table-of-contents li {
    font-family: var(--font-sans);
}
#text-table-of-contents ul li {
    font-weight: bold;
}
#text-table-of-contents ul li ul li {
    font-weight: normal;
}
#text-table-of-contents ul {
    margin: 0;
    padding: 0;
}
#text-table-of-contents > ul > li {
    padding-top: 1em;
}
#text-table-of-contents > ul > li:last-child {
    padding-bottom: 1.5em;
}
#+end_src

**** Track the current headline

We use some JavaScript to track the current headline when we scroll up or
down the page, forcing it to stay in sync with the content in the main body. We
initially used Bootstrap's "scrollspy" component, but dropped it because it was
too heavy and opinionated.

#+name: __NREF__js-toc-scrollspy
#+begin_src js -r -l "//ref:%s"
function scrollIntoViewIfNeeded(target) {
    if ((target.getBoundingClientRect().bottom > window.innerHeight)
        || (target.getBoundingClientRect().top < 0)) {
        target.scrollIntoView({ behavior: "smooth",
                                block: "center",
                                inline: "center" });
    }
}

function deactivate_other_toc_items(hash) {
    $("#text-table-of-contents a").each((index, elt) => {
        if (elt.hash !== hash) {
            $(elt).removeClass("active");
        }
    })
}

function get_toc_item(hash) {
    return $(`#text-table-of-contents a[href='${hash}']`)[0];
}

$(document).ready(() => {
    $("#text-table-of-contents a").click((e) => {
        var tocItem = get_toc_item(e.target.hash);
        $(tocItem).addClass("active");
        deactivate_other_toc_items(e.target.hash);
    });

    $("*[id^='outline-container-h-']").each((index, elt) => {
        var hash = elt.getAttribute("id")
        hash = hash.replace("outline-container-", "#")
        var tocItem = get_toc_item(hash);
        elt.addEventListener("mouseover", () => {
            $(tocItem).addClass("active");
            deactivate_other_toc_items(hash);
        });
        elt.addEventListener("mouseover", (e) => {
            // If we don't call stopPropagation(), we end up scrolling *all*
            // elements in the stack, which means we will try to scroll e.g.,
            // Section 5 and Section 5.1.2.3 (when we only want the latter).
            e.stopPropagation();
            // Unfortunately, scrollIntoViewIfNeeded is not supported on
            // Firefox. Otherwise we could do
            //
            //    elems[0].scrollIntoViewIfNeeded({ block: "center" });
            //
            // instead. So here we call the custom function that does what we
            // want.  See https://stackoverflow.com/a/37829643/437583.
            scrollIntoViewIfNeeded(tocItem);
        });
    });
});
#+end_src

We add some styling for the "active" headline. The main point is to add a green
background and border around it. For the border, we have to make the non-active
headlines have a white (invisible) border around it because otherwise the active
border makes the item jump a little bit when it's applied.

We have to colorize the foreground color of the link because otherwise it
becomes the color of all other links as per [[* Links]].

#+header: :noweb-ref __NREF__css-toc
#+begin_src css
#table-of-contents a {
    display: block;
    transition: all 300ms ease-in-out;
    padding: 5px;
    border-radius: 4px;
    border-style: solid;
    border-width: 1px;
    border-color: var(--clear);
    color: var(--fg-heading);
}
#table-of-contents .active {
    color: var(--fg-heading);
    __NREF__css-active-item
}
#table-of-contents a:hover {
    text-decoration: none;
}
#+end_src

*** Highlight and scroll to just-clicked-on item

When we click on any link (typically a code block but it can also be a headline
or some other intra-document link destination), the browser shifts the page
there.  But sometimes we are already near the link destination so the page
doesn't move.  Other times we get moved all the way to the top or the bottom of
the page, so by the time the browser finishes moving there, the user can be
confused as to know which destination the browser wanted to go to. This can be
somewhat disorienting.

The solution is to highlight the just-clicked-on link's destination element.
Every time we click on anything, we add a class to the destination element. Then
from CSS we can make this visually compelling. This way we give the user a
visual cue when clicking on links that navigate to a destination within the same
document.

We adapt the code in [[* Track the current headline]] to do what we need here. The
main difference is that while the code there is concerned with adding and
removing the =active= class from the =#text-table-of-contents= div, here we want
to do the same but for the =outline-2= div which contains the outline text
(There can be multiple =outline-2= divs, but this is immaterial.)

We also use the =scrollIntoViewIfNeeded= function to scroll the item into view,
but only if we need to. This way we minimize the need to scroll, resulting in a
much less "jumpy" experience.

#+name: __NREF__js-highlight-link-destination
#+begin_src js -r -l "//ref:%s"
function deactivate_other_non_toc_items(hash) {
    $(".outline-2 *").each((index, elt) => {
        if (`#${elt.id}` !== hash) {
            $(elt).removeClass("active");
        }
    })
}

function is_external_link(destination) {
    return (destination[0] !== "#");
}

$(document).ready(() => {
    $("a").click((e) => {
        var destination = null;
        if (e.target.attributes.length > 0) {
            destination = e.target.attributes.href.nodeValue;
        } else {
            destination = e.target.parentElement.hash;
        }

        // Only disable the browser's "jump to the link immediately" behavior if
        // we are dealing with an intra-document link. For links to other pages,
        // we want the default behavior. The destination is empty if the link
        // goes to another page.
        if (is_external_link(destination)) {
            return;
        } else {
            e.preventDefault();
        }
        $(destination).addClass("active");
        deactivate_other_non_toc_items(destination);
        scrollIntoViewIfNeeded($(destination)[0]);
        // Save intra-document link into history, but only if it's not a repeat
        // of one already there.
        var hash = destination;
        if (history.state === null || history.state.hash != hash) {
            history.pushState( //ref:HISTORY_PUSHSTATE
                {hash: destination},
                "", destination);
        }
    });
});
#+end_src

Now we just need to style the active element.

#+name: __NREF__css-active-item
#+begin_src css
background-color: var(--bg-toc-item);
border-color: var(--fg-toc-item);
#+end_src

For headlines, we draw a border around it.

#+name: __NREF__css-active-item-headline
#+begin_src css
border-style: solid;
border-width: 1px;
border-radius: 5px;
__NREF__css-active-item
#+end_src

For span nodes, we also draw a border around it. Spans can be the destination
when we link to a line inside a source code block.

#+name: __NREF__css-active-item-span
#+begin_src css
display: inline-block;
width: 100%;
border-style: solid;
border-width: 1px;
border-radius: 5px;
__NREF__css-active-item
#+end_src

Different destination elements need different selectors. We cover most of them
here.

#+header: :noweb-ref __NREF__css-active-non-toc-item
#+begin_src css
.outline-2 h2.active {
    __NREF__css-active-item-headline
}
.outline-2 h3.active {
    __NREF__css-active-item-headline
}
.outline-2 h4.active {
    __NREF__css-active-item-headline
}
.outline-2 h5.active {
    __NREF__css-active-item-headline
}
.outline-2 h6.active {
    __NREF__css-active-item-headline
}
.outline-2 pre.active {
    __NREF__css-active-item
}
.outline-2 span.active {
    __NREF__css-active-item-span
}
#+end_src

*** Scroll to history item

Normally, browsers only treat links across URLs as new points in history; this
means that for links /within/ the page, their history is not saved. We make sure
to save it explicitly with =history.pushState()= though in [[(HISTORY_PUSHSTATE)][=HISTORY_PUSHSTATE=]].
So then every time we want to go back in history (by pressing the "back" arrow
button in the browser), we just need to scroll to it.  We already scroll to the
element we click on when we push on a new history item into the stack, so
there's no need to keep it symmetric here.

We have to activate the restored history item (to re-highlight it with the
=active= class), so we do that also.

Lastly, setting the =scrollRestoration= property is critical because otherwise
the browser will want to restore the custom scroll position (instead of going to
the history item location we've saved).

#+name: __NREF__js-scroll-to-history-item
#+begin_src js
$(document).ready(() => {
    history.scrollRestoration = "manual";
    window.addEventListener("popstate", function (e) {
        if (e.state === null) {
           return;
        }
        var hash = e.state.hash;
        e.preventDefault();
        scrollIntoViewIfNeeded($(hash)[0]);
        $(hash).addClass("active");
        deactivate_other_non_toc_items(hash);
    });
});
#+end_src

** Autogenerate CSS for syntax highlighting of source code blocks

See [[https://emacs.stackexchange.com/questions/31439/how-to-get-colored-syntax-highlighting-of-code-blocks-in-asynchronous-org-mode-e][this]], specifically https://emacs.stackexchange.com/a/36759.

Generate =syntax-highlighting.css= and quit emacs. This function is designed to
be run from the command line on a fresh emacs instance (dedicated OS process).
Unfortunately, by itself it is almost useless (see
[[__NREF__enable-syntax-highlighting-from-batch-mode][=__NREF__enable-syntax-highlighting-from-batch-mode=]]), because there appears to
be a [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=61521][bug]] in Emacs 28 which [[https://emacs.stackexchange.com/questions/75814/org-html-htmlize-generate-css-not-generating-styles][breaks]] =org-html-htmlize-generate-css=.

#+name: __NREF__lilac_dot_el-autogenerate-css
#+begin_src emacs-lisp
(defun lilac-gen-css-and-exit ()
  (font-lock-flush)
  (font-lock-fontify-buffer)
  (org-html-htmlize-generate-css)
  (with-current-buffer "*html*"
    (write-file "syntax-highlighting.css"))
  (kill-emacs))

;; Without this, lilac-gen-css-and-exit produces a near-empty CSS file.
__NREF__enable-syntax-highlighting-from-batch-mode
#+end_src

Sadly, =lilac-gen-css-and-exit= by itself generates a near-blank CSS file.
So we have to use code from [[https://emacs.stackexchange.com/questions/38437/org-mode-batch-export-missing-syntax-highlighting][here]]:

#+name: __NREF__enable-syntax-highlighting-from-batch-mode
#+begin_src emacs-lisp
(require 'font-lock)
(require 'subr-x) ;; for `when-let'

(unless (boundp 'maximal-integer)
  (defconst maximal-integer (lsh -1 -1)
    "Maximal integer value representable natively in emacs lisp."))

(defun face-spec-default (spec)
  "Get list containing at most the default entry of face SPEC.
Return nil if SPEC has no default entry."
  (let* ((first (car-safe spec))
     (display (car-safe first)))
    (when (eq display 'default)
      (list (car-safe spec)))))

(defun face-spec-min-color (display-atts)
  "Get min-color entry of DISPLAY-ATTS pair from face spec."
  (let* ((display (car-safe display-atts)))
    (or (car-safe (cdr (assoc 'min-colors display)))
    maximal-integer)))

(defun face-spec-highest-color (spec)
  "Search face SPEC for highest color.
That means the DISPLAY entry of SPEC
with class 'color and highest min-color value."
  (let ((color-list (cl-remove-if-not
             (lambda (display-atts)
               (when-let ((display (car-safe display-atts))
                  (class (and (listp display)
                          (assoc 'class display)))
                  (background (assoc 'background display)))
             (and (member 'light (cdr background))
                  (member 'color (cdr class)))))
             spec)))
    (cl-reduce (lambda (display-atts1 display-atts2)
         (if (> (face-spec-min-color display-atts1)
            (face-spec-min-color display-atts2))
             display-atts1
           display-atts2))
           (cdr color-list)
           :initial-value (car color-list))))

(defun face-spec-t (spec)
  "Search face SPEC for fall back."
  (cl-find-if (lambda (display-atts)
        (eq (car-safe display-atts) t))
          spec))

; This is slightly tweaked from the original, because the incoming "face" value
; can look like (fixed-pitch face-name) --- so we take the second element.
(defun my-face-attribute (face attribute &optional frame inherit)
  "Get FACE ATTRIBUTE from `face-user-default-spec' and not from
`face-attribute'."
  (let*
    ((face-spec (face-user-default-spec (if (listp face)
                                            (car (cdr face))
                                          face)))
     (display-attr (or (face-spec-highest-color face-spec)
               (face-spec-t face-spec)))
     (attr (cdr display-attr))
     (val (or (plist-get attr attribute)
              (car-safe (cdr (assoc attribute attr))))))
    (when (and (null (eq attribute :inherit))
           (null val))
      (let ((inherited-face (my-face-attribute face :inherit)))
    (when (and inherited-face
           (null (eq inherited-face 'unspecified)))
      (setq val (my-face-attribute inherited-face attribute)))))
    (or val 'unspecified)))

(advice-add 'face-attribute :override #'my-face-attribute)
#+end_src

** Misc settings

*** Use HTML5 export, not XML (to un-break MathJax)

By default on Org 9.6, MathJax settings (JavaScript snippet) gets wrapped in a
CDATA tag, and we run into the same problem described on this email that has
gone unanswered:
https://www.mail-archive.com/emacs-orgmode@gnu.org/msg140821.html. It appears
that this is because the document is exported as XML, not HTML. Setting the
document type to =html5=, as below, appears to make the CDATA tag magically
disappear.

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(setq org-html-doctype "html5")
#+end_src

*** Set citeproc styles folder

For some reason we cannot specify citeproc styles based on a relative path in
our Org file. The solution is to set the =org-cite-csl-styles-dir= variable. See
[[https://list.orgmode.org/CAFyQvY2SZ3jMWo2uwVq0bzTkZGog8eyDSEwhdBZVc8ui9K54vQ@mail.gmail.com/][this post]].

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(setq org-cite-csl-styles-dir
      (concat (getenv "LILAC_ROOT") "/deps/styles/"))
#+end_src

*** Code references

**** Define =CodeHighlightOn= and =CodeHighlightOff=

If we don't do this, we get an error because the "coderef" links (the links
inside code blocks, for example =;ref:NSCB_NAME=) will still try to run the
=CodeHighlightOn= and =CodeHighlightOff= JavaScript functions. Turning this
setting on here injects the definitions of these functions into the HTML.

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(setq org-html-head-include-scripts t)
#+end_src

**** Do not highlight coderefs

#+name: __NREF__css-coderef-disable-background-color
#+begin_src css
.code-highlighted {
    background-color: inherit;
}
#+end_src

*** Preserve leading whitespace characters on export

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src

*** Set tab width to 4 spaces

This matters for languages that require tabs, such as Makefiles.

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(setq-default tab-width 4)
#+end_src

*** Disable backups

Disable backup files for =lilac.el= (that look like =lilac.el~=) when we invoke
Emacs from the [[Makefile][Makefile]].

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(setq make-backup-files nil)
#+end_src

*** Profiling

We don't use this very often, but it's mainly for determining cost centers for
weaving and tangling.

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(defun lilac-publish-profile ()
  (interactive)
  (profiler-start 'cpu)
  (lilac-publish)
  (profiler-stop)
  (profiler-report)
  (profiler-report-write-profile "emacs-profile-weave.txt") t)

(defun lilac-tangle-profile ()
  (interactive)
  (profiler-start 'cpu)
  (org-babel-tangle)
  (profiler-stop)
  (profiler-report)
  (profiler-report-write-profile "emacs-profile-tangle.txt") t)
#+end_src

** Imports

If we want syntax-highlighting to work for a code block, that code block's major
mode (language) must be loaded in here.

#+name: __NREF__lilac_dot_el-imports
#+begin_src emacs-lisp
;; Built-in packages (distributed with Emacs).
(require 'elisp-mode)

(defun lilac-load (p)
  (add-to-list 'load-path
    (concat (getenv "LILAC_ROOT") p)))

;; Third-party packages (checked in as Git submodules)
(lilac-load "/deps/elisp/s.el")
(require 's)
(lilac-load "/deps/elisp/compat.el")
(require 'compat)
(lilac-load "/deps/elisp/dash.el")
(require 'dash)
(lilac-load "/deps/elisp/dr-qubit.org")
(lilac-load "/deps/elisp/f.el")
(lilac-load "/deps/elisp/parsebib")
(lilac-load "/deps/elisp/citeproc-el")
(require 'citeproc)
(require 'oc-csl)
(lilac-load "/deps/elisp/emacs-htmlize")
(require 'htmlize)
(lilac-load "/deps/elisp/magit/lisp")
(require 'magit-section)
(lilac-load "/deps/elisp/nix-mode")
(require 'nix-mode)
(lilac-load "/deps/elisp/elquery")
(require 'elquery)
#+end_src

** Additional (hand-tweaked) CSS

We add some additional CSS tweaks on top of what we get from Org.

#+name: lilac.css
#+caption: lilac.css
#+begin_src css :tangle lilac.css
__NREF__css-general
__NREF__css-headline-font-size
__NREF__css-coderef-disable-background-color
__NREF__css-source-code-section-headlines
__NREF__css-source-code-block-body
__NREF__css-source-code-block-captions
__NREF__css-source-code-block-child-link-from-parent
__NREF__css-sidenotes
__NREF__css-description-lists
__NREF__css-bibliography
__NREF__css-toc
__NREF__css-active-non-toc-item
#+end_src

*** Colors and fonts

We define colors and fonts in one place and reuse them throughout the rest of
the CSS, with the =var()= function.

#+begin_sidenote
This would be an excellent candidate to copy/paste/tweak into your own
=lilac-override.css= file to tweak any of the colors or fonts used by Lilac.
#+end_sidenote

#+header: :noweb-ref __NREF__css-general
#+begin_src css
:root {
    --bg: #fff;
    --fg: #000;
    --bg-code: #f7f7f7;
    --border-code: #777;
    --border-light: #ccc;
    --fg-link: #0000ff;
    --fg-nref-link: #21618c;
    --bg-nref-link: #d8f6ff;
    --fg-nref-link-hover: #7d3c98;
    --bg-nref-link-hover: #f8e9ff;
    --fg-toc-item: green;
    --bg-toc-item: #f1ffef;
    --fg-heading: black;
    --clear: rgba(255, 255, 255, 0);
    --font-serif: "Source Serif Pro", serif;
    --font-sans: "Source Sans Pro", sans;
    --font-mono: "Source Code Pro", monospace;
}
#+end_src

*** General body text

#+header: :noweb-ref __NREF__css-general
#+begin_src css
body {
    font-size: 1.25em;
    width: 800px;
    margin-left: 310px;
    overflow-x: hidden;
    background-color: var(--bg);
    color: var(--fg);
}

body, p, li, legend {
    font-family: var(--font-serif);
}

h2, h3, h4, h5, h6 {
    margin: 1em 0 0 -4px;
    padding: 0 4px;
    display: inline-block;
    border-style: solid;
    border-width: 1px;
    border-color: var(--clear);
}

h1, h2, h3, h4, h5, h6, dt {
    font-family: var(--font-sans);
}

h3, h4, h5, h6 {
    font-weight: normal;
}

p, li {
    line-height: 1.2em;
}

p, ol, ul {
    margin-top: 0;
    margin-bottom: 0;
    padding-top: 1em;
}

li {
    margin-bottom: 0;
}
#+end_src

*** Headline font sizes

#+header: :noweb-ref __NREF__css-headline-font-size
#+begin_src css
h1 {
    font-size: 3em;
}

h2 {
    font-size: 2.4em;
}

h3 {
    font-size: 2em;
}

h4 {
    font-size: 1.6em;
}

h5 {
    font-size: 1.2em;
}

h6 {
    font-size: 1em;
}
#+end_src

**** Title font

#+header: :noweb-ref __NREF__css-general
#+begin_src css
h1.title {
    font-family: "Source Serif Pro", serif;
    font-size: 60pt;
    margin-top: 0.4em;
    margin-bottom: 0;
}
#+end_src

*** Tables

#+header: :noweb-ref __NREF__css-general
#+begin_src css
table {
    margin: 1em auto 0em auto;
    border-spacing: 0;
    border-radius: 4px;
    border: 1px solid var(--border-code);
    border-collapse: unset;
    overflow: hidden;
}

th, td {
    padding: 3px 6px;
    border-right: 1px solid var(--border-code);
    border-bottom: 1px solid var(--border-code);
}

th:last-child, td:last-child  {
    border-right: none;
}

tr:last-child td {
    border-bottom: none;
}

thead {
    background-color: var(--bg-code);
}
#+end_src

*** Description lists

#+header: :noweb-ref __NREF__css-general
#+begin_src css
dl {
    margin: 0;
    padding-top: 1em;
}
#+end_src

*** Images

#+header: :noweb-ref __NREF__css-general
#+begin_src css
img {
    display: block;
    margin: 0 auto;
}
#+end_src

*** Monospaced

#+header: :noweb-ref __NREF__css-general
#+begin_src css
code {
    background-color: var(--bg-code);
    padding-left: 5px;
    padding-right: 5px;
    white-space: nowrap;
    border-radius: 4px;
    border-style: solid;
    border-width: 1px;
    border-color: var(--border-code);
}

pre {
    font-size: 0.8em;
    border-radius: 5px;
    margin: 1em 0 0 0;
    background-color: var(--bg-code);
    border-color: var(--border-code);
    min-width: fit-content;
}
#+end_src

Also make the background color of the programming language hover text the same
as what we have elsewhere. This hover text comes with Org mode's HTML export of
source code blocks.

#+header: :noweb-ref __NREF__css-general
#+begin_src css
pre.src::before {
    background-color: var(--bg-code);
}
#+end_src

*** Links

Force all links to have a blue color. This is mainly to override whatever Org
gives us by default.

#+header: :noweb-ref __NREF__css-general
#+begin_src css
a {
    color: var(--fg-link);
}
#+end_src

*** Source code block body

#+name: __NREF__css-source-code-block-body
#+begin_src css
.org-src-container {
    padding-top: 1em;
}

.org-src-container pre {
    margin: 0;
    font-family: var(--font-mono);
    border-width: 0;
    scroll-margin-top: 100px;
    border-style: solid;
    border-width: 1px;
    border-color: var(--border-code);
    border-radius: 5px;
}

/* Source code block body. */
.org-src-container pre.src {
    background-color: var(--bg-code);
}

#+end_src

*** Source code block captions

#+name: __NREF__css-source-code-block-captions
#+begin_src css
.lilac-caption {
    font-family: var(--font-mono);
    text-align: right;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    padding-top: 2px;
    padding-bottom: 2px;
}

.lilac-caption label {
    margin-right: 10px;
    padding-left: 10px;
    padding-right: 10px;
    padding-bottom: 10px;
    border-radius: 5px;
    border-style: solid;
    border-bottom-style: none;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    border-width: 1px;
    background-color: var(--bg-code);
    border-color: var(--border-code);
}

.lilac-caption-source-code-block-name {
    color: #444444;
    font-weight: bold;
    margin-right: 5px;
}

.lilac-caption-parent-link {
    margin-top: 5px;
    margin-right: 5px;
    padding-left: 5px;
    padding-right: 5px;
    font-weight: bold;
}
.lilac-caption-parent-link a {
    padding-left: 10px;
    padding-right: 10px;
    padding-bottom: 10px;
    color: var(--fg-nref-link);
    background-color: var(--bg-nref-link);
    border-radius: 5px;
    border-style: solid;
    border-width: 1px;
    border-bottom-style: none;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    transition: all 150ms ease-in-out;
}
.lilac-caption-parent-link a:hover {
    color: var(--fg-nref-link-hover);
    background-color: var(--bg-nref-link-hover);
    text-decoration: none;
}

.lilac-caption-link-symbol a {
    margin-right: 5px;
}
.lilac-caption-link-symbol a:hover {
    text-decoration: none;
}

.lilac-caption-listing-number {
    margin-right: 5px;
}
#+end_src

*** Links to child source block from parent

#+name: __NREF__css-source-code-block-child-link-from-parent
#+begin_src css
.lilac-child-link-from-parent {
    font-weight: bold;
}
.lilac-child-link-from-parent a {
    color: var(--fg-nref-link);
    background-color: var(--bg-nref-link);
    border-radius: 5px;
    border-style: solid;
    border-width: 1px;
    margin: 2px 0;
    padding: 0 5px;
    display: inline-block;
    transition: all 150ms ease-in-out;
}
.lilac-child-link-from-parent a:hover {
    color: var(--fg-nref-link-hover);
    background-color: var(--bg-nref-link-hover);
    text-decoration: none;
}
#+end_src

*** Sidenotes

Sidenotes are small blurbs of text that are displayed "out-of-band", on the
right margin. This right margin is good for presenting smaller ideas that
shouldn't necessarily sit in the main body text.

The CSS below is drawn primarily from [[https://scripter.co/sidenotes-using-only-css/][here]], with some modifications.

#+name: __NREF__css-sidenotes
#+begin_src css
.sidenote {
    font-size: 80%;
    margin-top: 1em;
    padding: 1em 0 1em 1em;
    border-left: solid;
    border-right: none;
    border-width: 1px;
    border-color: var(--border-light);
}

.sidenote p {
    padding-top: 0;
    margin-top: 1em;
}

.sidenote p:first-child {
    margin-top: 0;
}

@media (max-width: 1425px) {
    .sidenote {
        margin-left: 1em;
    }
}

@media (min-width: 1425px) {
    .sidenote {
        margin-left: 0;

        width: 280px;
        float: right;
        margin-right: -315px;
    }
}
#+end_src

*** Printer-friendly styling

When printing, we don't display the sidebar because it unnecessarily narrows the
width of the main text area.

#+header: :noweb-ref __NREF__css-toc
#+begin_src css
@media print {
    #table-of-contents {
        display: none !important;
    }
    body {
        margin-left: 0;
    }
}
#+end_src

** Create =lilac.theme= file

Allow HTML exports of Org files (including this one) to pull in CSS and
JavaScript that we've defined for Lilac by referring to a single theme file. The
inspiration for this setup comes from https://gitlab.com/OlMon/org-themes.

For the default fonts, we break up the definition over multiple lines here using
Emacs Lisp for readability.

#+name: __NREF__fonts-to-load
#+begin_src emacs-lisp
(concat
 "#+HTML_HEAD: <link rel=\"stylesheet\" href="
   "\"https://fonts.googleapis.com/css2"
     "?family=Source+Serif+Pro:wght@400;700"
     "&family=Source+Sans+Pro:wght@400;700"
     "&family=Source+Code+Pro"
 "\">")
#+end_src

Now we get the result of evaluating the above with =__NREF__fonts-to-load()=
(note the trailing parentheses =()=, which evaluates the referenced code block
before injecting its evaluated value).

Also note that we pull in both the =lilac.css= file which we tangle in [[*
Additional (hand-tweaked) CSS]], but this can be expanded by customizing the
value of =lilac-html-head=, per [[* Custom HTML "head" section]]. For example, you
could make this variable link to a separate =lilac-override.css= file to
override any of the values we have hardcoded in =lilac.css=.

#+name: lilac.theme
#+caption: lilac.theme
#+begin_src org :tangle lilac.theme :eval no
,#+HTML_HEAD: <link rel="preconnect" href="https://fonts.googleapis.com" />
,#+HTML_HEAD: <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
__NREF__fonts-to-load()

__NREF__lilac-theme-js

# Include additional CSS styles.
,#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="syntax-highlighting.css"/>
,#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="lilac.css" />

,#+HTML_HEAD: <!-- LILAC_HTML_HEAD -->
#+end_src

** Ignore woven HTML from =git diff=

Typically we only need to look at the rendered HTML output in a web browser as
the raw HTML diff output is extremely difficult to parse as a human. So by
default we ask Git to exclude it from =git diff= by treating them as binary
data.

#+name: .gitattributes
#+caption: .gitattributes
#+begin_src gitattributes :tangle .gitattributes :eval no
,* -diff
,**/*.org diff
,**/.gitattributes diff
,**/.gitmodules diff
,**/.gitignore diff
package/nix/sources.json diff
package/nix/sources.nix diff
#+end_src

In order to still show the HTML textual diff, we can run =git diff --text=.

*** =git add -p=

Note that the above setting to treat HTML files as binary data prevents them
from being considered for =git add -p=. In order to add them, use =git add -u=
instead.

** gitignore

#+name: .gitignore
#+caption: .gitignore
#+begin_src gitignore :tangle .gitignore :eval no
,**/*.auctex-auto
tangle
update-deps
weave
#+end_src

* Tests

We use [[https://www.gnu.org/software/emacs/manual/ert.html][ERT, the Emacs Lisp Regression Testing tool]] for our unit tests. Pure
functions that take all of their inputs explicitly ("dependency-injected") are
easy to test because we just provide the various inputs and expect the function
to produce certain outputs. For functions that operate on an Emacs buffer, we
use =with-temp-buffer= to create a temporary buffer first before invoking the
functions under test.

Some functions we test expect Org mode to be active (so that certain Org mode
functions are available), so we turn it on here by calling =(org-mode)=.

#+name: lilac-tests.el
#+caption: lilac-tests.el
#+begin_src emacs-lisp :tangle lilac-tests.el :eval no
(require 'ert)
(require 'lilac)

(org-mode)

__NREF__t-helpers
__NREF__t-smart-caption-generation
__NREF__t-link-to-child-block-from-parent-block

(provide 'lilac-tests)
#+end_src

** Test helpers

*** Avoid cross-abstraction Noweb reference prefix collision

Note that we cannot write =__NREF__foo= directly in the test code here, because
when this Org file is tangled, the references will be detected and Org mode will
try to replace them with a monoblock or polyblock elsewhere in this file named
=__NREF__foo=. So we have to go in "stealth mode" by writing the =__NREF__=
prefix indirectly with the =(nref)= helper function.

#+header: :noweb-ref __NREF__t-helpers
#+begin_src emacs-lisp
(defun nref (s) (concat "__NREF__" s))
#+end_src

*** Setup and tear-down fixture for HTML tests

#+begin_sidenote
The [[https://www.gnu.org/software/emacs/manual/html_mono/ert.html#Fixtures-and-Test-Suites][Emacs manual]] for ERT defines fixtures as environments which provide setup
and tear-down.
#+end_sidenote

When testing HTML output (behavior of =(lilac-publish)=), it's useful to create
a temporary Org file and to generate the HTML output (as part of "setup"). Then
we'd run the tests, and finally delete the temporary files (as part of
"tear-down").

We use =(lilac-publish-fixture)= to do the aforementioned setup and tear-down
for us. In between setup and tear-down, we execute the =test= function with a
=funcall=.

#+header: :noweb-ref __NREF__t-helpers
#+begin_src emacs-lisp
(defun lilac-publish-fixture (fname-prefix content test)
  (let* ((fname-org (make-temp-file fname-prefix nil ".org"))
         (fname-html (concat (string-remove-suffix "org" fname-org) "html")))
    (unwind-protect
        (progn
          (with-temp-file fname-org
            (org-mode)
            (insert content))
          (find-file fname-org)
          (lilac-publish)
          (funcall test (elquery-read-file fname-html)))
      (shell-command-to-string
       (concat
        "rm -f " (mapconcat 'identity `(,fname-org ,fname-html) " "))))))
#+end_src

** Smart source code block caption helpers

=lilac-get-noweb-children= should return a list of Noweb references (child block
names) found in a source code block.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-get-noweb-children ()
  (let ((body
         (concat
          "#+name: foo\n"
          "#+caption: foo\n"
          "#+begin_src emacs-lisp\n"
          "; foo\n"
          "#+end_src\n")))
    (should (equal (lilac-get-noweb-children body)
                   ())))
  (let ((body
         (concat
          "#+name: parent\n"
          "#+caption: parent\n"
          "#+begin_src emacs-lisp\n"
          "; foo\n"
          (nref "one") "\n"
          "; bar\n"
          (nref "two") "\n"
          "#+end_src\n")))
    (should (equal (lilac-get-noweb-children body)
                   `(,(nref "one") ,(nref "two"))))))
#+end_src

=lilac-is-parent-block= depends on =lilac-get-noweb-children=. We tested the
latter already above, but we test the former anyway for completeness.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-is-parent-block ()
  (with-temp-buffer
    (insert "#+name: parent\n")
    (insert "#+caption: parent\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child") "\n"))
    (insert "#+end_src\n")
    (goto-char (point-min))
    (let ((src-block (org-element-at-point)))
      (should-not (equal nil (lilac-is-parent-block src-block))))))
#+end_src

Here we test whether we can automatically insert captions for child blocks.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-insert-noweb-source-code-block-captions ()
  (with-temp-buffer
    (insert "#+name: parent\n")
    (insert "#+caption: parent\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child2") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; baz\n")
    (insert "#+end_src\n")
    (lilac-insert-noweb-source-code-block-captions nil)
    (goto-char (point-min))
    (should (search-forward
             (concat "#+caption: =" (nref "child1") "=  [[parent][1]]")
             nil t))
    (should (search-forward
             (concat "#+caption: =" (nref "child2") "=  [[parent][1]]")
             nil t)))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child2") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; baz\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: parent2\n"))
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (lilac-insert-noweb-source-code-block-captions nil)
    (goto-char (point-min))
    (should (search-forward
             (concat "#+caption: ="
                     (nref "child1")
                     "=  [[parent1][1]]  [[parent2][2]]")
             nil t))
    (should (search-forward
             (concat "#+caption: =" (nref "child2") "=  [[parent1][1]]")
             nil t))))
#+end_src

Here we test retrieval of parent source code blocks.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-get-parent-blocks ()
  (with-temp-buffer
    (insert "#+name: foo\n")
    (insert "#+caption: foo\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: bar\n")
    (insert "#+caption: bar\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert "#+end_src\n")
    (should-not (lilac-get-parent-blocks)))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (should (lilac-get-parent-blocks))))
#+end_src

Here we test generating the child-to-parents hash table.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-mk-child-parents-hash-table ()
  (with-temp-buffer
    (insert "#+name: foo\n")
    (insert "#+caption: foo\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: bar\n")
    (insert "#+caption: bar\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks)))
      (should (equal (hash-table-count child-parents-hash-table) 0))))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks)))
      (should (equal (hash-table-count child-parents-hash-table) 2)))))
#+end_src

Here we test the construction of smart captions.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-mk-smart-captions ()
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (should (equal smart-captions nil))))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child1\n")
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (should (equal smart-captions
       `((181 . ,(concat "#+caption: ="
                         (nref "child1")
                         "=  [[parent1][1]]  [[parent2][2]]\n")))))))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child1\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child2") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child2\n")
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (should (equal smart-captions
       `((181 . ,(concat "#+caption: ="
                         (nref "child1")
                         "=  [[parent1][1]]\n"))
         (247 . ,(concat "#+caption: ="
                         (nref "child2")
                         "=  [[parent2][1]]\n")))))))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child1\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child2") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child2\n")
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (should (equal smart-captions
       `((91 . ,(concat "#+caption: ="
                         (nref "child1")
                         "=  [[parent1][1]]\n"))
         (172 . ,(concat "#+caption: ="
                         (nref "child2")
                         "=  [["
                         (nref "child1")
                         "][1]]\n"))))))))
#+end_src

** Link to child block from parent block

*** One (same) child node block referenced in two different parent blocks

Expect to find a link in the HTML from the parent blocks to the same child
block.

#+header: :noweb-ref __NREF__t-link-to-child-block-from-parent-block
#+begin_src emacs-lisp
(ert-deftest t-lilac-children-are-linked-from-parent ()
  (lilac-publish-fixture
   "t-lilac-children-are-linked-from-parent-"
   (concat
    "#+name: parent1\n"
    "#+caption: parent1\n"
    "#+begin_src emacs-lisp\n"
    "; foo\n"
    (concat (nref "child1") "\n")
    "#+end_src\n"
    "\n"
    "#+name: parent2\n"
    "#+caption: parent2\n"
    "#+begin_src emacs-lisp\n"
    "; bar\n"
    (concat (nref "child1") "\n")
    "#+end_src\n"
    "\n"
    (concat "#+name: " (nref "child1") "\n")
    "#+begin_src emacs-lisp\n"
    "; child1\n"
    "#+end_src\n")
   (lambda (html-ast)
     (let ((got-child-link-text-parent1
            (elquery-text
             (car (elquery-$
                   "#parent1 .lilac-child-link-from-parent a"
                   html-ast))))
           (got-child-link-text-parent2
            (elquery-text
             (car (elquery-$
                   "#parent2 .lilac-child-link-from-parent a"
                   html-ast)))))
       (should (equal got-child-link-text-parent1 "child1"))
       (should (equal got-child-link-text-parent2 "child1"))))))
#+end_src

*** Nested child blocks

A child block can itself be a parent (and link to the nested child within it).
Expect to find a link to the nested child block from wiithin the first child
block.

#+header: :noweb-ref __NREF__t-link-to-child-block-from-parent-block
#+begin_src emacs-lisp
(ert-deftest t-lilac-children-are-linked-from-parent-nested ()
  (lilac-publish-fixture
   "t-lilac-children-are-linked-from-parent-nested-"
   (concat
    "#+name: parent1\n"
    "#+caption: parent1\n"
    "#+begin_src emacs-lisp\n"
    "; foo\n"
    (concat (nref "child1") "\n")
    "#+end_src\n"
    "\n"
    (concat "#+name: " (nref "child1") "\n")
    "#+begin_src emacs-lisp\n"
    "; child1\n"
    (concat (nref "nested-child") "\n")
    "#+end_src\n"
    "\n"
    (concat "#+name: " (nref "nested-child") "\n")
    "#+caption: nested-child\n"
    "#+begin_src emacs-lisp\n"
    "; nested-child\n"
    "#+end_src\n")
   (lambda (html-ast)
     (let ((got-child-link-text-parent1
            (elquery-text
             (car (elquery-$
                   "#parent1 .lilac-child-link-from-parent a"
                   html-ast))))
           (got-child-link-text-child1
            (elquery-text
             (car (elquery-$
                   (concat "#" (nref "child1")
                           " .lilac-child-link-from-parent a")
                 html-ast)))))
       (should (equal got-child-link-text-parent1 "child1"))
       (should (equal got-child-link-text-child1 "nested-child"))))))
#+end_src

* Glossary

- <<glossary: literate document>> *literate document* :: A file or collection of
  files that include both source code and prose to explain it. Well-known
  formats include Noweb files (=*.nw=) and Org mode files (=*.org=).
- <<glossary: monoblock>> *monoblock* :: an Org mode source code block with a
  =#+name: ...= field. This block is an independent block and there are no other
  blocks with the same name.
- <<glossary: Noweb>> *Noweb* :: A literate programming tool from 1989 that
  still works and from which [[glossary: Org mode][Org mode]] borrows heavily using [[glossary: noweb-ref][Noweb-style
  references]]. See [[https://en.wikipedia.org/wiki/Noweb][Wikipedia]].
- <<glossary: noweb-ref>> *noweb-ref* :: aka "Noweb-style reference". A
  Noweb-style reference is just a name (string) that refers to a monoblock or
  polyblock. See [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][the Org manual]].
- <<glossary: Org mode>> *Org mode* :: An Emacs major mode for =*.org= files,
  where "major mode" means that it provides things like syntax highlighting and
  keyboard shortcuts for =*.org= text files if you are using Emacs. For Lilac,
  the important thing is that we use Org mode as a literate programming tool.
  See [[https://orgmode.org/][Org mode]].
- <<glossary: polyblock>> *polyblock* :: an Org mode source code block without a
  =#+name: ...= field, but which has a =#+header: :noweb-ref ...= field. Other
  blocks with the same Noweb-ref name are concatenated together when they are
  tangled.  Polyblocks are used in cases where we would like to break up a
  single block into smaller pieces for explanatory purposes. In all other cases,
  monoblocks are preferable, unless the source code block is not to be tangled
  and is only for explanatory purposes in the woven output.
- <<glossary: source code block>> *source code block* :: An Org mode facility
  that allows you to enclose a multiline text (typically source code) with
  =#+begin_src ...= and =#+end_src= lines. They are enclosed in a separate
  background color in the HTML output, and are often used for illustrating
  source code listings. The format is =#+begin_src LANGUAGE_NAME= where
  =LANGUAGE_NAME= is the name of the programming language used for the listing.
  If the name is a recognized name, it will get syntax highlighting in the
  output automatically.
- <<glossary: tangling>> *tangling* :: The act of extracting source code from a
  raw [[glossary: literate document][literate document]].
- <<glossary: weaving>> *weaving* :: The act of converting a raw literate
  document to a richer format such as PDF or HTML. This allows fancier output,
  such as for mathematical formulas, which are easier to read versus the
  original [[glossary: literate document][literate document]].

* References

#+begin_src bibtex :tangle citations.bib :eval no :exports none
@article{knuth_1984,
    title = {{Literate Programming}},
    volume = {27},
    issn = {0010-4620, 1460-2067},
    url = {https://academic.oup.com/comjnl/article-lookup/doi/10.1093/comjnl/27.2.97},
    doi = {10.1093/comjnl/27.2.97},
    language = {en},
    number = {2},
    urldate = {2023-05-03},
    journal = {{The Computer Journal}},
    author = {Knuth, D. E.},
    month = feb,
    year = {1984},
    pages = {97--111},
}

@article{ramsey_1994,
    title = {Literate programming simplified},
    author = {Ramsey, Norman},
    year = {1994},
    journal = {{IEEE Software}},
    volume = {11},
    issn = {1937-4194},
    doi = {10.1109/52.311070},
    abstract = {Literate programming tools let you arrange the parts of a
                  program in any order and extract documentation and code from
                  the same source file. The author argues that
                  language-dependence and feature complexity have hampered
                  acceptance of these tools, then offers a simpler
                  alternative.{\textless}{\textgreater}},
    number = {5},
    month = sep,
    keywords = {Documentation, Code standards, Writing, Program processors,
                  Computer languages, Operating systems, Internet, Strips,
                  Pipelines},
    pages = {97--105},
}
#+end_src

#+cite_export: csl ieee.csl
#+print_bibliography:
