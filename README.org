#+title: Lilac
#+SETUPFILE: lilac.theme

# Set default header argument for all source code blocks. The "no-export" means
# that we do not expand noweb references when exporting (weaving) --- the fact
# that this is not the default option is odd.
#+PROPERTY: header-args :noweb no-export

# Number the top 5 levels of headings; since h1 is the title, this means headings
# up to 5 numbers --- e.g., "1.2.3.4.5".
#+OPTIONS: H:5

#+BIBLIOGRAPHY: ./citations.bib

* Introduction

/Lilac/ is an addon for Emacs Org mode to make [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]] (LP) using
Noweb-style [cite:@ramsey_1994] references easy. It comes in two parts:

1. =lilac.el=: to be loaded and used when /weaving/ [cite:@knuth_1984 98] and
   /tangling/ [cite:@knuth_1984 98] from your own Org mode files (which use
   Noweb references), and
2. =lilac.theme=: to be sourced by your Org mode files to use Lilac's customized
   HTML export.

This document itself reuses the =lilac.theme= file, which gives you a preview
(if you are viewing the HTML output) of what weaving with Lilac looks like.

* Motivation

Lilac was created mainly because the existing Org mode features around Noweb
references were lacking in features. There seems to have been a great deal of
effort to make /tangling/ (extracting source code from source code blocks) work
well, but not much has been done around /weaving/, where I think most of the
difficulties lie (because making output look good to a human (weaving) is much
more difficult than making output look good to a computer (tangling)).

** Problems with Org mode

By default, source code blocks do not get any captions in the HTML output. This
is a problem for LP because you have to manually explain the name of each block
to keep track of their usage in other blocks (when referring to them with Noweb
style references). This gets repetitive rather quickly.

While Org mode allows source code blocks to refer to other blocks (Noweb
references), it does not do any kind of linking. So you can write blocks like

#+begin_src org
,#+name: example-parent-block
,#+begin_src bash
echo "Hello from the parent block"
<<some-other-block>>
,#+end_src

...

,#+name: some-child-block
,#+begin_src bash
echo "I am child 1"
,#+end_src
#+end_src

but when this is exported to HTML neither =example-parent-block= nor
=some-child-block= have any links to each other. This is frustrating because it
makes navigating between them difficult.

Org mode does not create link anchors for headings, which makes referring to
them from other external documents slightly annoying. Org mode does not add link
anchors to source code blocks.

Org mode generates random link ID's on every export. That is, even if you change
nothing in your Org mode file, if you export to HTML there *will* be a diff
because all of the linked objects will get a new link ID.

** Lilac to the rescue

Lilac addresses all of the issues presented above.

Lilac frees you from having to write
a custom =#+caption: ...= text for every source code block, because it generates
them automatically based on the name of the Noweb reference. And Lilac
automatically links child blocks and parent blocks together. Lilac automatically
adds link anchors to all source code blocks as well as headlines, making it
easier to link to different parts of an Org file while browsing it.

Lilac makes HTML generation deterministic. This makes it VCS and CI-friendly
because the output changes if and only if the input changes. Speaking of
CI-friendliness, Lilac was designed to be run from outside of Emacs by default
(and not interactively).

* Usage

First create an Org mode file that uses LP. Then either clone this repo or add
it as a submodule to your project. The point is to get the =lilac.el= (and its
dependencies, themselves submodules) and =lilac.theme= (and associated
CSS/JavaScript files) available locally. Then for the Org mode file you are
using, you can load =lilac.el= and run =(lilac-publish)= to generate the HTML
file, or run =(org-babel-tangle)= to generate the source code from it. See the
=Makefile= that this project uses as a reference.

The main thing that you need to keep in mind when writing Org mode files for
consumption by Lilac is that the source code blocks must use Noweb references
using =__NREF__= as a prefix. See the discussion below.

** Source code blocks: monoblocks and polyblocks

In Org mode, Noweb-style references by default must be enclosed in double angle
brackets =<<= and =>>=. While this works, it's problematic because it can mean
different things syntactically based on the source code language. Your source
code block's language might think that the angle brackets are operators or
keywords and colorize them differently, for example.

Instead, Lilac expects Noweb-style references in the form =__NREF__foo= (where
the "NREF" stands for "Noweb reference"). Then you are free to name your child
block with this same =__NREF__foo= name. This is better because now you can
search for this word =__NREF__foo= in your raw Org mode document and you'll
instantly be able to see where it is used. Contrast this with the default Org
mode behavior where you'll have to search for =<<foo>>= and =foo= separately
(because searching for just =foo= may collide with other names that are not
source code block names).

In the example below, the =parent-block= refers to 2 other child blocks for its
definition.

#+begin_comment
The =,#+name: ...=, =,#+begin_src ...= and =,#+end_src= in the =org= source
blocks have a leading comma but this comma is only for Org's own parser to
disambiguate against actual source code blocks in this file. The leading comma
is stripped during HTML export.
#+end_comment

#+caption: Sample Org-mode Noweb-style references
#+begin_src org
,#+name: parent-block
,#+begin_src bash
echo "Hello from the parent block"
__NREF__child-block-1
__NREF__child-block-2
,#+end_src

...

,#+name: __NREF__child-block-1
,#+begin_src bash
echo "I am child 1"
,#+end_src

...

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo -n "I am "
,#+end_src

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo "child 2"
,#+end_src
#+end_src

This example illustrates the two ways to define a child block: either as a
single code block with =#+name: __NREF__foo=, or as multiple blocks with
=#+header: :noweb-ref __NREF__foo=. Lilac calls them [[monoblock][monoblocks]] and [[polyblock][polyblocks]]
respectively. Polyblocks are concatenated together in the order they appear in
the overall Org file; this final concatenated version is what gets inserted into
the Noweb reference in the parent block.

*** Examples of source code blocks

Below is an example of the usage described above. Notice how the child blocks
referenced in the parent block are linked to their definitions.

#+name: example-parent-block
#+caption: example-parent-block
#+begin_src bash
echo "Hello from the parent block"
__NREF__example-child-block-foo
echo ""
__NREF__example-child-block-bar
#+end_src

Below are the child blocks. The first is a monoblock. Every child block's name
links back up to the parent block where it is referenced.

#+name: __NREF__example-child-block-foo
#+begin_src bash
echo "I am child 1"
#+end_src

The blocks below are polyblocks.

#+header: :noweb-ref __NREF__example-child-block-bar
#+begin_src bash
echo -n "I am "
#+end_src

Note the fraction after the name which denotes the position of the block in the
overall polyblock "chain".

#+header: :noweb-ref __NREF__example-child-block-bar
#+begin_src bash
echo "child 2"
#+end_src

**** Multi-parent child blocks

Sometimes a piece of code will be reused in different source code blocks. You
can think of it as constants in a programming language, but in LP the concept
extends to any arbitrary piece of text.

Below is an example where we define a child block once...

#+name: __NREF__example-child-block-baz
#+begin_src bash
echo "Hello from child block baz"
#+end_src

...but where we also reuse it (reference it) in different parent blocks.

#+name: example-parent-1
#+caption: example-parent-1
#+begin_src bash
echo "Hello from parent 1"
__NREF__example-child-block-baz
#+end_src

#+name: example-parent-2
#+caption: example-parent-2
#+begin_src bash
echo "Hello from parent 2"
__NREF__example-child-block-baz
#+end_src

Notice that the child block has an additional link named "2", which points to
the second parent that references this block (the first parent is linked by the
child block name itself, as in the previous example). If it is referenced in
additional parent blocks, they will show up as links "3", "4", etc.

* How Lilac uses LP

All source code is generated by /tangling/ this Org file (=README.org=). This
file is the single source of truth for basically everything. Some other things
like COPYRIGHT and LICENSE do not come from this file, but they are exceptions.

Tangling is done by loading this file into Emacs and then running
=(org-babel-tangle)=. This file is also the source of truth for the /woven/
HTML documentation (=README.html=), and similarly the HTML is generated by
invoking =(lilac-publish)=. The outputs of both tangling and weaving are checked
into version control.

The =Makefile= in this repo is used as the main "driver" for both tangling and
weaving.

* Weaving (generating the HTML)

Weaving is conceptually simpler than tangling because there is no extra step ---
the output is an HTML page and that is something that we can use directly
(unlike program source code, which may require additional compilation into a
binary, depending on the language). We limit ourselves to HTML output because
HTML support is ubiquitous; plus we don't have to worry about page breaks such
as in PDF output.

Although weaving is conceptually simple, most of the code in [[file:lilac.el][=lilac.el=]] have to
do with weaving because the default infrastructure that ships with Org mode is
too rigid for our needs. For example, we make heavy use of Noweb-style
[cite:@ramsey_1994] references, but also add in extensive HTML links to allow
the reader to jump around code easily because Org does not cross-link these
references by default.

Weaving currently requires the following dependencies:

| Dependency | Why                      |
|------------+--------------------------|
| [[https://www.gnu.org/software/make/][GNU Make]]   | to run "make"            |
| [[https://www.gnu.org/software/emacs/][GNU Emacs]]  | for tangling and weaving |

Note that all of the above can be brought in by using the [[https://github.com/NixOS/nix][Nix package manager]].
This is why we provide a [[file:shell.nix]] file in this repo.

** Makefile

We have a top-level =Makefile= so that we can run some =make= commands on the
command line. The overall idea is to tangle and weave, while also running any
associated tests.

#+name: Makefile
#+caption: Makefile
#+begin_src makefile :tangle Makefile :eval no
all: test weave
.PHONY: all

test: tangle
	emacs --quick --batch --kill --load ert \
		--load lilac.el \
		--load lilac-tests.el \
		--funcall ert-run-tests-batch-and-exit
.PHONY: test

__NREF__Makefile-weave
__NREF__Makefile-tangle
__NREF__Makefile-run_emacs
__NREF__Makefile-update-deps
#+end_src

Weaving just depends on the main =README.html= file being generated. Before we
call =(lilac-publish)=, we have to first call =(lilac-gen-css-and-exit
\"README.org\")= because otherwise the source code blocks do not get any syntax
highlighting. And lastly we have to modify the generated =README.html= file with
=sed= because we have to fix up some CSS classes that get inlined into the HTML.

#+name: __NREF__Makefile-weave
#+begin_src makefile
weave: README.html
.PHONY: weave

README.html: README.org
	$(call run_emacs,(lilac-gen-css-and-exit),README.org)
	$(call run_emacs,(lilac-publish),README.org)
	# Fix inline styles.
	sed -i 's/<style>.csl-left-margin{float: left; padding-right: 0em/'\
	'<style>.csl-left-margin{float: left; padding-right: 1em/' README.html
	sed -i 's/.csl-right-inline{margin: 0 0 0 1em;}<\/style>/'\
	'.csl-right-inline{margin: 0 0 0 2em;}<\/style>/' README.html
#+end_src

Tangling is pretty straightforward --- we just need to call
=(org-babel-tangle)= on =README.org=. This generates a number of files, such as
=Makefile= and =shell.nix=.

The key here is to enumerate these generated files, because we need to tell the
=make= utility that it should run the rule if =README.org= has a newer
modification timestamp than any of the generated files. Technically speaking,
because all of the tangled files are tangled together at once with
=(org-babel-tangle)=, we could just list one of them such as =Makefile= (instead
of enumerating all of them). However we still enumerate them all here for
completeness.

Lastly we make use of the fake file =tangle=, so that we can write the top-level
=test= rule as =test: tangle=, which reads more naturally than the equivalent
=test: Makefile= or =test: lilac.el=.

#+name: __NREF__Makefile-tangle
#+begin_src makefile
# tangled_output are all files that are generated by tangling README.org.
tangled_output = \
	citations.bib \
	lilac.el \
	lilac.theme \
	.gitattributes \
	.gitignore \
	Makefile \
	misc.js \
	shell.nix \
	style.css \
	syntax-highlighting.css

tangle $(tangled_output) &: README.org
	# Generate the toplevel Makefile (this file) and others as described in
	# tangled_output. In a way this bootstraps the whole literate-programming
	# pipeline.
	$(call run_emacs,(org-babel-tangle),README.org)
	touch tangle
#+end_src

The =run_emacs= function is used for both weaving and tangling. The main thing
of interest here is that it loads the =lilac.el= (tangled) file before
evaluating the given expression.

#+name: __NREF__Makefile-run_emacs
#+begin_src makefile
define run_emacs
	emacs $(2) --quick --batch --kill --load $(PROJ_ROOT)/lilac.el --eval="$(1)"
endef

PROJ_ROOT := $(shell git rev-parse --show-toplevel)
#+end_src

We use [[https://github.com/nmattia/niv][=niv=]] to update the dependencies sourced by =shell.nix=.

#+name: __NREF__Makefile-update-deps
#+begin_src makefile
update-deps: package/nix/sources.json package/nix/sources.nix
	cd package && niv update
	touch update-deps
#+end_src

** Emacs customizations for HTML export (=lilac.el=)

Below is the overall structure of =lilac.el=. The =gc-cons-threshold= setting is
to prevent =emacs= from entering garbage collection pauses, because we invoke
=emacs= from the command line in a fire-and-forget manner.

#+name: lilac.el
#+caption: lilac.el
#+begin_src emacs-lisp :tangle lilac.el :eval no
; Set garbage-collection threshold to 16 GiB.
(setq gc-cons-threshold #x400000000)
__NREF__lilac_dot_el-imports
__NREF__lilac_dot_el-fix-nondeterminism
__NREF__lilac_dot_el-autogenerate-css
__NREF__lilac_dot_el-lilac-publish
__NREF__lilac_dot_el-misc
(provide 'lilac)
#+end_src

** Fix non-determinism

Nondeterminism is problematic because it results in a different HTML file
every time we run =org-babel-tangle=, /even if the Org files have not changed/.
Here we take care to set things right so that we can have reprducible, stable
HTML output.

*** Do not insert current time as HTML comment

Org mode also injects an HTML comment (not visible to the user) to record the
time that the HTML was generated. We disable this because it breaks
deterministic output. See [[https://emacs.stackexchange.com/questions/50117/how-to-disable-commented-date-in-org-mode-html-export][this link]] for more info.

#+header: :noweb-ref __NREF__lilac_dot_el-fix-nondeterminism
#+begin_src emacs-lisp
(setq org-export-time-stamp-file nil)
#+end_src

*** Do not insert current Org mode version

By default Org mode appends visible metadata at the bottom of the HTML document,
including the Org version used to generate the document. We suppress this
information.

#+header: :noweb-ref __NREF__lilac_dot_el-fix-nondeterminism
#+begin_src emacs-lisp
(setq org-html-postamble nil)
#+end_src

*** Do not use random numbers for the HTML "=id=" attribute

Stop randomized IDs from being generated every time. Instead count from 0 and
work our way up.

See https://www.reddit.com/r/orgmode/comments/aagmfh/comment/hk6upbf.

#+header: :noweb-ref __NREF__lilac_dot_el-fix-nondeterminism
#+begin_src emacs-lisp
(defun org-export-deterministic-reference (references)
  (let ((new (length references)))
     (while (rassq new references) (setq new (+ new 1)))
     new))
(advice-add #'org-export-new-reference
            :override #'org-export-deterministic-reference)
#+end_src

** Toplevel publishing function (=lilac-publish=)

The toplevel function is =lilac-publish=. This actually publishes twice, with
=lilac-publish-1= and =lilac-publish-2=. The reason we publish twice is because
we need to examine the HTML output twice in order to build up a database of
parent/child source code block links (which is then used to link between these
parent/child source code blocks).

Also note that we do some modifications to the Org buffer directly before
exporting to HTML. The main reason is so that the source code blocks that are
named =__NREF__...= get an automatic =#+caption: ...= text to go along with it
(because for these Noweb-style blocks, the captions should always look uniform).

#+name: __NREF__lilac_dot_el-lilac-publish
#+begin_src emacs-lisp
(defun lilac-publish ()
  (interactive)
  (lilac-publish-1)
  (clrhash lilac-polyblock-names-totals)
  (lilac-publish-2))

(defun lilac-publish-1 ()
  (let (
        __NREF__lilac-publish-modify-org
        __NREF__lilac-publish-modify-HTML-1
        __NREF__lilac-publish-use-css)
    (org-html-export-to-html)))

(defun lilac-publish-2 ()
  (let (
        __NREF__lilac-publish-modify-org
        __NREF__lilac-publish-modify-HTML-2
        __NREF__lilac-publish-use-css)
    (org-html-export-to-html)))

;; Modify Org buffer
__NREF__UID-for-all-src-blocks
__NREF__smart-source-code-block-captions
__NREF__UID-for-all-headlines

;; Modify HTML
__NREF__lilac-link-to-child-blocks-from-parent
__NREF__lilac-prettify-source-code-captions
__NREF__lilac-human-readable-src-block-ids
#+end_src

*** Modify the Org buffer

Here we modify the Org mode buffer, by using =org-export-before-parsing-hook=.
This takes a list of functions that are free to modify the Org mode buffer
before each Org element in the buffer gets converted into HTML.

#+name: __NREF__lilac-publish-modify-org
#+begin_src emacs-lisp
(org-export-before-parsing-hook
 '(lilac-UID-for-all-src-blocks
   lilac-insert-noweb-source-code-block-captions
   lilac-UID-for-all-headlines))
#+end_src

As for the actual modifications, see:

- =lilac-UID-for-all-src-blocks= ([[* Give all source code blocks a =#+name: ...= field (HTML ID)]])
- =lilac-insert-noweb-source-code-block-captions= ([[* Automatic captions for Noweb source code blocks]])
- =lilac-UID-for-all-headlines= ([[* Human-readable UIDs (Headings, aka headlines)]])

In brief, the =lilac-UID-for-all-*= functions make it so that the links to
headlines and source code blocks are both deterministic and human-readable. The
=lilac-insert-noweb-source-code-block-captions= function

*** Modify the HTML

This is useful for adding in final tweaks to the HTML that is difficult to
accomplish at the Org-mode buffer level.

Phase 1: In the first phase, we use the generated HTML data to populate the
=lilac-child-HTML_ID-hash-table=. This data structure is used to link to child
blocks from parent blocks. We also populate the
=lilac-org_id-human_id-hash-table= which is used to convert HTML IDs to be more
human-readable.

#+name: __NREF__lilac-publish-modify-HTML-1
#+begin_src emacs-lisp
(org-export-filter-src-block-functions
 '(lilac-populate-child-HTML_ID-hash-table
   lilac-populate-org_id-human_id-hash-table))
#+end_src

Phase 2: In this phase we perform the linking from parent blocks to child blocks
(=lilac-link-to-children-from-parent-body=), and also convert the child source
code captions to look prettier (=lilac-prettify-source-code-captions=).

#+name: __NREF__lilac-publish-modify-HTML-2
#+begin_src emacs-lisp
(org-export-filter-src-block-functions
 '(lilac-link-to-children-from-parent-body
   lilac-prettify-source-code-captions))
(org-export-filter-final-output-functions
 '(lilac-replace-org_ids-with-human_ids))
#+end_src

*** Miscellaneous export settings

Do not hardcode colors into the HTML. Instead refer to CSS class names, to be
stylized by an external CSS file.

#+name: __NREF__lilac-publish-use-css
#+begin_src emacs-lisp
(org-html-htmlize-output-type 'css)
#+end_src

** Org modifications

*** Give all source code blocks a =#+name: ...= field (HTML ID)

Only source code blocks that have a =#+name: ...= field (org name field) get an
HTML ID (org ID) assigned to it. The problem with polyblocks is that they are
not assigned an org name field by default.

Of course, we still want all polyblock to have an HTML ID, which can then be
extracted by [[(lilac-get-src-block-HTML_ID)][=lilac-get-src-block-HTML_ID=]] to build up the
=lilac-child-HTML_ID-hash-table= in [[* Link noweb references (link to child block
from parent block)]]. If we don't do this then parent source code blocks won't
be able to link to the polyblock at all (or vice versa).

Monoblocks with a =#+name: ...= field get a unique HTML ID assigned to it in
the form =orgN= where =N= is a hexadecimal number. By default Org generates a
random number for =N=, but we use a simple counter that increments, starting
from 0 (see [[*Do not use random numbers for the HTML "=id=" attribute]]).

Some source code blocks may not even be monoblocks, because a =#+name: ...=
field may simply be missing.

What we can do is inject a =#+name: ___anonymous-src-block-N= line (where =N= is
an incrementing number) into the beginning of the source code section of all
source code blocks that need it. Then we can construct an HTML link to any
source code block.

Note that the actual name =__anonymous-src-block-N= is not important, because it
gets erased and replaced with an =orgN= ID during HTML export. At that point we
make these =orgN= strings human-readable in [[* Use human-readable HTML IDs for
source code links]].

#+name: __NREF__UID-for-all-src-blocks
#+begin_src emacs-lisp
(defun lilac-UID-for-all-src-blocks (_backend)
  (let* ((all-src-blocks
           __NREF__all-src-blocks)
         (counter 0)
         (auto-names
           (-remove 'null
             (cl-loop for src-block in all-src-blocks collect
               (let* ((pos (org-element-property :begin src-block))
                      (parent-name-struct (lilac-get-src-block-name src-block))
                      (direct-name (org-element-property :name src-block))
                      (no-direct-name (s-blank? direct-name))
                      (prefix
                        (cond ((s-blank? (car parent-name-struct))
                               "___anonymous-src-block")
                              (t
                               (car parent-name-struct))))
                      (name-final
                       (format "#+name: %s-%x\n" prefix counter)))
                 (setq counter (1+ counter))
                 (when no-direct-name
                   (cons pos name-final)))))))
    (lilac-insert-strings-into-buffer auto-names)))
#+end_src

*** Automatic captions for Noweb source code blocks

For the parent/child source code blocks, we simply build these up by having
blocks named =#+name: __NREF__foo= or =#+header: :noweb-ref __NREF__foo=. Each
of these blocks can also reference other blocks by having a line =__NREF__bar=
inside its body. When defining such blocks, we really don't want to define the
=#+caption: ...= part manually because it gets tedious rather quickly. Yet we
still have to have these =#+caption: ...= bits (/for every =__NREF__...=
block!/) because that's the only way that Org's HTML exporter knows how to label
these blocks.

The code in this section automatically generates =#+caption: ...= text for these
=__NREF__...= blocks.

We want each =#+caption: ...= text to have the following items:

- [[(NSCB_NAME)][=NSCB_NAME=]] :: name of the Noweb source code block,
- [[(NSCB_POLYBLOCK_INDICATOR)][=NSCB_POLYBLOCK_INDICATOR=]] :: an indicator to show whether this block is
  broken up over multiple blocks, and
- [[(NSCB_LINKS_TO_PARENTS)][=NSCB_LINKS_TO_PARENTS=]] :: a link back up to a parent block (if any) where
  this block is used; can contain more than 1 parent if multiple parents refer
  to this same child block

/NSCB/ here means /Noweb source code block/. We loop through every source code
block and insert a =#+caption: ...= text into the buffer. This modified buffer
(with the three bits of information from above) is what is sent down the
pipeline for final export to HTML (i.e., the buffer modification does not affect
the actual buffer (=*.org= file)).

So assume that we already have the smart captions in a sorted [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html][association list]]
(aka alist), where the KEY is the integer buffer position where this caption
should be inserted, and the VALUE is the caption itself (a string), like this:

#+caption: Caption locations
#+begin_src elisp
'((153  . "#+caption: ...")
  (384  . "#+caption: ...")
  (555  . "#+caption: ...")
  (684  . "#+caption: ...")
  (1051 . "#+caption: ..."))
#+end_src

We can use the KEY to go to that buffer position and insert the caption. However
the insertion operation mutates the buffer. This means if we perform the
insertions top-to-bottom, the subsequent KEY values will become obsolete. The
trick then is to just do the insertions in reverse order (bottom-to-top), so
that the remaining KEY values remain valid. This is what we do below, where
=smart-captions= is an alist like the one just described.

#+name: __NREF__smart-source-code-block-captions
#+begin_src emacs-lisp
(defun lilac-insert-noweb-source-code-block-captions (_backend)
  (let* ((parent-blocks
           __NREF__parent-blocks)
         (child-parents-hash-table
           __NREF__child-parents-hash-table)
         (all-src-blocks
           __NREF__all-src-blocks)
         (smart-captions
           __NREF__smart-captions))
    (lilac-insert-strings-into-buffer smart-captions)))

__NREF__smart-source-code-block-captions-helpers
#+end_src

(We'll get to the helper functions =smart-source-code-block-captions-helpers=
later as they obscure the big picture.)

Now we just have to construct =smart-captions=. The main difficulty is the
construction of [[(NSCB_LINKS_TO_PARENTS)][=NSCB_LINKS_TO_PARENTS=]], so most of the code will be concerned
about child-parent associations.

Why do we even need these source code blocks to link back to their parents? The
point is to make things easier to navigate. For example, if we have

#+caption: Sample Org-mode Noweb-style references
#+begin_src org
,#+name: parent-block
,#+begin_src bash
echo "Hello from the parent block"
__NREF__child-block-1
__NREF__child-block-2
,#+end_src

...

,#+name: __NREF__child-block-1
,#+begin_src bash
echo "I am child 1"
,#+end_src

...

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo -n "I am "
,#+end_src

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo "child 2"
,#+end_src
#+end_src

and we export this to HTML, ideally we would want both =__NREF__child-block-1=
and each of the =__NREF__child-block-2= blocks to include an HTML link back up
to =parent-block=. This would make it easier to skim the document and not get
too lost (any time you are looking at any particular source code block, you
would be able to just click on the link back to the parent (if there is one) to
see a higher-level view).

The key idea here is to build a hash table (=child-parents-hash-table=) where
the KEY is a child source code block and the VALUE is the parent block(s). Then
in order to construct [[(NSCB_LINKS_TO_PARENTS)][=NSCB_LINKS_TO_PARENTS=]] we just do a lookup against this
hash table to find the parent(s), if any.

The first thing we need is a list of parent source code blocks. We consider a
source code block a parent block if it has any Noweb references within its body.

#+name: __NREF__parent-blocks
#+begin_src emacs-lisp
(lilac-get-parent-blocks)
#+end_src

Then we construct the =child-parents-hash-table=. For each parent block, we get
all of its children (=child-names=), and use this data to construct a
child-parent association. Note that we use =cl-pushnew= instead of =push= to
deduplicate parents (i.e., when a single parent refers to the same child more
than once we do not want to link back to this same parent more than once from
the child block's caption).

#+name: __NREF__child-parents-hash-table
#+begin_src emacs-lisp
(lilac-mk-child-parents-hash-table parent-blocks)
#+end_src

Now that we have the child-parent associations, we have to look at all source
code blocks and check if

1. this source code block's name shows up at all in =child-parents-hash-table=,
   and if so
2. add a link to the parent ([[(NSCB_LINKS_TO_PARENTS)][=NSCB_LINKS_TO_PARENTS=]]).

Let's grab all source code blocks:

#+name: __NREF__all-src-blocks
#+begin_src emacs-lisp
(org-element-map (org-element-parse-buffer) 'src-block 'identity)
#+end_src

And now we can finally construct =smart-captions=:

#+name: __NREF__smart-captions
#+begin_src emacs-lisp
(lilac-mk-smart-captions child-parents-hash-table)
#+end_src

We used some helper functions up in [[__NREF__smart-source-code-block-captions][=__NREF__smart-source-code-block-captions=]];
let's examine them now.

=lilac-is-parent-block= checks whether a source code block is a parent (contains
noweb references to other child blocks in the form =__NREF__child-name=).

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-is-parent-block (src-block)
  (let ((body (org-element-property :value src-block)))
    (lilac-get-noweb-children body)))
#+end_src

=lilac-get-parent-blocks= retrieves all source code blocks that are parents
(which have =__NREF__...= references).

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-get-parent-blocks ()
  (org-element-map (org-element-parse-buffer) 'src-block
    (lambda (src-block)
       (if (lilac-is-parent-block src-block) src-block))))
#+end_src

=lilac-mk-child-parents-hash-table= takes all parent source code blocks and
generates a hash table where the KEY is the child block name and the VALUE is
the list of parents that refer to the child. When we loop through
=parent-blocks= below, we have to first =reverse= it because the function
=cl-pushnew= grows the list by prepending to it.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-mk-child-parents-hash-table (parent-blocks)
  (let ((hash-table (make-hash-table :test 'equal)))
    (mapc
     (lambda (parent-block)
      (let* ((parent-name (org-element-property :name parent-block))
             (parent-body (org-element-property :value parent-block))
             (child-names (lilac-get-noweb-children parent-body)))
        (mapc (lambda (child-name)
                (let* ((parents (gethash child-name hash-table)))
                  (if parents
                    (puthash child-name (cl-pushnew parent-name parents) hash-table)
                    (puthash child-name (list parent-name) hash-table))))
              child-names)))
     (reverse parent-blocks))
    hash-table))
#+end_src

=lilac-mk-smart-captions= generates an alist of buffer positions (positive
integer) and the literal =#+caption: ...= text that needs to be inserted back
into the buffer.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp -r -l ";ref:%s"
(defun lilac-mk-smart-captions (child-parents-hash-table)
  (-remove 'null
    (cl-loop for src-block in __NREF__all-src-blocks collect
      (let* ((child (lilac-get-src-block-name src-block))
             (child-name (car child))
             (NSCB_NAME (format "=%s= " child-name))                  ;ref:NSCB_NAME
             (NSCB_POLYBLOCK_INDICATOR                                ;ref:NSCB_POLYBLOCK_INDICATOR
               (if (lilac-get-noweb-ref-polyblock-name src-block)
                   "(polyblock)"
                 ""))
             (polyblock-counter (gethash child-name lilac-polyblock-names-totals 0))
             (polyblock-counter-incremented
              (puthash child-name (1+ polyblock-counter)
                       lilac-polyblock-names-totals))
             (parents (gethash child-name child-parents-hash-table))
             (parents-zipped (lilac-enumerate parents))
             (pos (org-element-property :begin src-block))
             (NSCB_LINKS_TO_PARENTS                                   ;ref:NSCB_LINKS_TO_PARENTS
              (mapconcat (lambda (parent-with-idx)
                           (format " [[%s][%d]]"
                                   (nth 1 parent-with-idx)
                                   (1+ (nth 0 parent-with-idx))))
                         parents-zipped " "))
             (smart-caption
              (concat
                "#+caption: "
                NSCB_NAME
                NSCB_POLYBLOCK_INDICATOR
                NSCB_LINKS_TO_PARENTS
                "\n")))
        (when parents (cons pos smart-caption))))))
#+end_src

=lilac-insert-strings-into-buffer= takes an alist of buffer positions and
strings and inserts them all into the buffer.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-insert-strings-into-buffer (pos-strings)
  (cl-loop for pos-string in (reverse pos-strings) do
        (let ((pos (car pos-string))
              (str (cdr pos-string)))
          (goto-char pos)
          (insert str))))
#+end_src

=lilac-get-noweb-children= extracts all Noweb references in the form
"=__NREF__foo=" from a given multiline string, returning a list of all such
references. This function expects at most 1 Noweb reference per line. The return
type is a list of strings.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-get-noweb-children (s)
  (let* ((lines (split-string s "\n"))
         (refs (-remove 'null
                 (mapcar
                  (lambda (line)
                   (if (string-match (lilac-nref-rx nil) line)
                       (match-string-no-properties 1 line)))
                  lines))))
    refs))
#+end_src

=lilac-get-noweb-ref-polyblock-name= gets the string =__NREF__foo= in a
=#+header: :noweb-ref __NREF__foo= line for a source code block.

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-get-noweb-ref-polyblock-name (source-code-block)
  (let* ((headers (org-element-property :header source-code-block))
         (noweb-ref-name
          (nth 0
           (-remove 'null
            (mapcar
             (lambda (header)
               (if (string-match ":noweb-ref \\(.+\\)" header)
                   (match-string-no-properties 1 header)))
             headers)))))
    noweb-ref-name))
#+end_src

Note that a child source block can have two ways of defining its name. The first
is with the direct =#+name: __NREF__foo= style ([[monoblock][monoblock]]), and the second way
is with a line like =#+header: :noweb-ref __NREF__foo= ([[polyblock][polyblock]]). Here
=lilac-get-src-block-name= grabs the name of a (child) source code block, taking
into account these two styles. For polyblock names, we mark it as such with a
=(polyblock)= string, which is used later for the [[(NSCB_POLYBLOCK_INDICATOR)][=NSCB_POLYBLOCK_INDICATOR=]].

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-get-src-block-name (src-block)
  (let* ((name-direct (org-element-property :name src-block))
         (name-indirect (lilac-get-noweb-ref-polyblock-name src-block)))
    (if name-indirect
        `(,name-indirect "(polyblock)")
        `(,name-direct ""))))
#+end_src

Next we have some helpers to enumerate through a list just like in Python. The
index starts at 0 (same as Python).

#+header: :noweb-ref __NREF__smart-source-code-block-captions-helpers
#+begin_src emacs-lisp
(defun lilac-enumerate (lst &optional start)
  (let ((ret ()))
    (cl-loop for index from (if start start 0)
           for item in lst
           do (push (list index item) ret))
    (reverse ret)))

; See https://emacs.stackexchange.com/a/7150.
(defun lilac-matches (regexp s &optional group)
  "Get a list of all regexp matches in a string"
  (if (= (length s) 0)
      ()
      (save-match-data
        (let ((pos 0)
              (matches ()))
          (while (string-match regexp s pos)
            (push (match-string (if group group 0) s) matches)
            (setq pos (match-end 0)))
          (reverse matches)))))
#+end_src

*** Human-readable UIDs (Headings, aka headlines)

By default Org does a terrible job of naming HTML =id= fields for headings. By
default it uses a randomly-generated number. In [[* Do not use random numbers for
the HTML "=id=" attribute]] we tweak this behavior to use a deterministic,
incrementing number starting from 0. However while this solution gets rid of the
nondeterminism, it still results in human-unfriendly =id= attributes because
they are all numeric (e.g. =org00000a1=, =org00000f3=, etc).

For headings, we can do better because in practice they already mostly have
unique contents, which should work most of the time to act as an =id=. In other
words, we want all headings to have HTML IDs that are patterned after their
contents. This way we can have IDs like =some-heading-name-1= (where the
trailing =-1= is only used to disambiguate against another heading of the same
name) instead of =org00000a1= (numeric hex).

For each heading, we insert a =CUSTOM_ID= property. This makes Org refer to this
=CUSTOM_ID= instead of the numeric =org...= link names. We append this headline
property just below every headline we find in the buffer. The actual
construction of the =CUSTOM_ID= (=headline-UID= in the code below) is done by
=lilac-get-unique-id=.

#+Name: __NREF__UID-for-all-headlines
#+begin_src emacs-lisp
(defun lilac-UID-for-all-headlines (_backend)
  (let* ((all-headlines
           (org-element-map (org-element-parse-buffer) 'headline 'identity))

         (headline-uid-hash-table (make-hash-table :test 'equal))
         (headline-UIDs
           (-remove 'null
             (cl-loop for headline in all-headlines collect
               (let* ((headline-UID
                       (lilac-get-unique-id headline headline-uid-hash-table))
                      ;; Get the position just after the headline (just
                      ;; underneath it).
                      (pos (progn
                             (goto-char (org-element-property :begin headline))
                             (re-search-forward "\n"))))
                 (cons pos (concat
                            ":PROPERTIES:\n"
                            ":CUSTOM_ID: " headline-UID "\n"
                            ":END:\n")))))))
    (lilac-insert-strings-into-buffer headline-UIDs)))

__NREF__get-unique-id
#+end_src

=lilac-get-unique-id= converts a given headline to its canonical form (every
non-word character converted to a dash) and performs a lookup against the hash
table. If the entry exists, it looks up a =entry-N= value in a loop with =N=
increasing until it sees that no such key exists (at which point we know that we
have a unique ID).

#+name: __NREF__get-unique-id
#+begin_src emacs-lisp
(defun lilac-get-unique-id (headline hash-table)
  (let* ((name (org-element-property :raw-value headline))
         (disambiguation-number 0)
         (key (concat "h-" (lilac-normalize-string name)))
         (val (gethash key hash-table)))
    ;; Discard the key if a value already exists. This drives up the
    ;; disambiguation number.
    (while val
      (setq disambiguation-number (1+ disambiguation-number))
      (setq key (concat "h-"
                        (lilac-normalize-string
                         (format "%s-%s" name disambiguation-number))))
      (setq val (gethash key hash-table)))
    (puthash key t hash-table)
    key))

(defun lilac-normalize-string (s)
  (string-trim
    (replace-regexp-in-string "[^A-Za-z0-9]" "-" s)
    "-"
    "-"))
#+end_src

** HTML modifications

*** Use human-readable HTML IDs for source code links

Recall that there are 2 types of source code blocks: [[monoblock][monoblocks]] and [[polyblock][polyblocks]].

Polyblocks do get a name field attached to them during the [[*Give all source code blocks a =#+name: ...= field (HTML ID)][Org
modification stage]], in the format =___anonymous-src-block-N=. These names are
for HTML link generation only, because the user won't see them --- they will
instead just see =org000012= or some such. In fact, all monoblocks are also
given these random-looking (and unstable) =org...= HTML IDs.

And therein lies the problem: if a user decides to bookmark a particular source
code block, whether a monoblock or polyblock, they will link to an
=org...=-style ID and chances are that this link will break over time.

This is exactly the same problem we have for headlines. For headlines we solved
the problem with a [[* Human-readable UIDs (Headings, aka headlines)][hash table]], and we need to do the same thing here. The major
difference, though, is that unlike headlines which can accept a =CUSTOM_ID= Org
property, source code blocks have no such facility. So instead of modifying the
buffer (as we do for headlines), we have to modify the final HTML output
instead.

The solution is to simply look at all source code block links, then modify the
~id=...~ part so that it looks like a more human-readable ID. We can extract the
human-readable ID by looking at the smart captions inside the
=<label>...</label>= area for both monoblocks and polyblocks. And then it's just
a matter of doing a basic search-and-replace across the entire buffer (HTML
file).

We have to do a search-and-replace across the entire file because we may also
have manual links to source code blocks (although --- maybe it's just not worth
it because we can't refer to polyblocks anyway by name).

#+name: __NREF__lilac-human-readable-src-block-ids
#+begin_src emacs-lisp -r -l ";ref:%s"
; Define a global hash table for mapping Org-mode-generated ids (that look like
; "org00012") for source code blocks to a more human-readable ID.
(setq lilac-org_id-human_id-hash-table (make-hash-table :test 'equal))
(setq lilac-human_id-count-hash-table (make-hash-table :test 'equal))
(setq lilac-human_id-org_id-hash-table (make-hash-table :test 'equal))

(defun lilac-populate-org_id-human_id-hash-table (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let* ((block-name (lilac-get-src-block-name-from-html src-block-html))
           (block-name-count (gethash block-name
                                      lilac-human_id-count-hash-table
                                      0))
           (orgid (lilac-get-src-block-HTML_ID src-block-html)))
      (when orgid
        (puthash block-name
                 (1+ block-name-count)
                 lilac-human_id-count-hash-table)
        (cond ((= block-name-count 0)
                (progn
                  (puthash orgid
                           block-name
                           lilac-org_id-human_id-hash-table)
                  (puthash block-name
                           orgid
                           lilac-human_id-org_id-hash-table)))
              ((= block-name-count 1)
                (let* ((orgid-first-block
                        (gethash block-name lilac-human_id-org_id-hash-table)))
                  (puthash orgid-first-block
                           (format "%s-1" block-name)
                           lilac-org_id-human_id-hash-table)
                  (puthash orgid
                           (format "%s-%d" block-name (1+ block-name-count))
                           lilac-org_id-human_id-hash-table)))
              (t
                 (puthash orgid
                          (format "%s-%d" block-name (1+ block-name-count))
                          lilac-org_id-human_id-hash-table))))
      src-block-html)))

(defun lilac-replace-org_ids-with-human_ids (entire-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let ((html-oneline (lilac-to-single-line entire-html)))
      (maphash
       (lambda (k v)
        (when (and k v)
         (setq html-oneline
               (replace-regexp-in-string
                (rx-to-string `(and " id=" (* (not "\"")) "\"" ,k "\""))
                (format " id=\"%s\"" v) html-oneline))
         (setq html-oneline
               (replace-regexp-in-string
                (rx-to-string `(and " href=" (* (not "\"")) "\"#" ,k "\""))
                (format " href=\"#%s\"" v) html-oneline))))
       lilac-org_id-human_id-hash-table)
      (lilac-to-multi-line html-oneline))))
#+end_src

*** Pretty source code captions

Here there are basically 3 things we have to keep track of:

1. the outer =<div>= that encloses the entire source code block,
2. the =<label>=, if any (it may not exist), and
3. the =<pre>= content.

We only care about source code blocks with a =<label>= because that determines
whether we have a "Listing: ..." or not. We just need to save the 3 bits of
information, and then:

1. print the outer =<div ...>=,
2. print the =<label>= content but as a =<div>=, and
3. print the =<pre>= content.

For the last step, we want to additionally parse the inner "Listing N ... 0 [1 2
3 ...]" text and transform it with reordering and also additional metadata
information such as ~<span class="...">~ tags.

We also save the =NSCB_POLYBLOCK_INDICATOR= with the =polyblock-indicator=
variable and display it.

#+name: __NREF__lilac-prettify-source-code-captions
#+begin_src emacs-lisp
(setq lilac-polyblock-names (make-hash-table :test 'equal))
(setq lilac-polyblock-names-totals (make-hash-table :test 'equal))

(defun lilac-prettify-source-code-captions (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    ;; Break up source block into 3 subparts --- the leading <div ...>, the
    ;; <label ...></label> (if any) and <pre ...></pre>.
    ;; Then run the linkifying logic against only the body, and then return the
    ;; original label and new body.
    (let* ((div-caption-body (lilac-get-source-block-html-parts-without-newlines
                              src-block-html))
           (leading-div (nth 0 div-caption-body))
           (body (nth 2 div-caption-body))
           (pre-id-match
             (string-match
               (rx-to-string
                 '(and
                       "<pre "
                       (* (not ">"))
                       "id=\""
                       (group (+ (not "\"")))))
               body))
           (pre-id
             (if pre-id-match
                 (match-string-no-properties 1 body)
                 "#deadlink"))
           (body-with-newlines
            (lilac-to-multi-line body))
           (caption (nth 1 div-caption-body))
           ; caption-parts just captures whatever substring is inside the
           ; <label> tags.
           (caption-parts
             (let* ((caption-match
                      (string-match "<label [^>]+>\\(.*?\\)</label>" caption)))
               (if caption-match
                   (match-string-no-properties 1 caption)
                   "")))
           (source-block-name-match
             (string-match
               (rx-to-string
                 '(and
                       "<code>"
                       (group (+ (not "<")))
                       "</code>"))
               caption-parts))
           ;; A source code block is anonymous if: (1) it does not have a
           ;; "#+name: ..." line, or (2) it does not have a "#+header:
           ;; :noweb-ref ..." line.
           (source-block-name
             (if source-block-name-match
                 (match-string-no-properties 1 caption-parts)
                 "anonymous"))
           ;; This is just used for the side effect of recording the
           ;; source-block-name, to be used for the fallback-id.
           (source-block-counter
            (gethash source-block-name lilac-polyblock-names 0))
           (source-block-counter-incremented
            (puthash source-block-name (1+ source-block-counter)
                     lilac-polyblock-names))
           (source-block-name-styled
             (cond ((string-prefix-p "__NREF__" source-block-name)
                    (concat
                      "<span class=\"lilac-caption-source-code-block-name\">"
                      (string-remove-prefix "__NREF__" source-block-name)
                      "</span>"))
                   (t
                    (concat
                      "<span class=\"lilac-caption-source-code-block-name\">"
                      "&#x1f4c4; "
                      source-block-name
                      "</span>"))))
           (polyblock-chain-total
            (gethash source-block-name lilac-polyblock-names-totals 0))
           (polyblock-chain-location
            (if (= polyblock-chain-total 0)
                ""
              (format "(%s/%s) "
                      source-block-counter-incremented polyblock-chain-total)))
           (polyblock-indicator
             (if (string-match "\(polyblock\)" caption-parts)
                 polyblock-chain-location ""))
           (parent-id-regexp
               (rx-to-string
                 '(and
                       " <a href=\""
                       (group (+ (not "\""))))))
           (parent-ids-with-idx
            (lilac-enumerate
             (lilac-matches parent-id-regexp caption-parts 1) 1))
           (parent-links
             (mapconcat (lambda (parent-id-with-idx)
                          (let ((parent-id (car (cdr parent-id-with-idx)))
                                (idx (car parent-id-with-idx)))
                             (format (concat
                                      "<span class="
                                      "\"lilac-caption-parent-link\">"
                                      "<a href=\"%s\">%s</a></span>")
                               parent-id
                               (if (= idx 1)
                                   (string-remove-prefix
                                    "__NREF__" source-block-name)
                                 idx))))
                        parent-ids-with-idx ""))
           ;; For polyblocks, only the first (head) block gets an id field for a
           ;; <pre> tag. The rest (tail) don't have this field so they would
           ;; normally get assigned a deadlink. To avoid this, use a counter for
           ;; the parent-id, because this parent-id is shared across all
           ;; polyblocks. Then use this with the parent-id to generate an
           ;; alternate, fallback-id. This way the tail polyblocks get assigned
           ;; a unique (meaningful) ID and not just "##deadlink".
           (fallback-id
             (if (string= pre-id "#deadlink")
                 (format "%s-%s"
                         source-block-name
                         source-block-counter-incremented)
                 pre-id))
           (pre-tag-match
             (string-match
               (rx-to-string
                 '(and
                       "<pre "
                       (group (* (not ">")))
                       ">"))
               body))
           (pre-tag-entire (match-string-no-properties 0 body))
           (pre-tag-contents (match-string-no-properties 1 body))
           (body-with-replaced-pre
             (if pre-id-match
                 body-with-newlines
                 (string-replace pre-tag-entire
                                 (concat "<pre " pre-tag-contents
                                         (format " id=\"%s\"" fallback-id) ">")
                                 body-with-newlines)))
           (link-symbol
             (format (concat "<span class=\"lilac-caption-link-symbol\">"
                             "<a href=\"#%s\">&#x1f517;</a></span>")
               fallback-id))
           (caption-without-listing-prefix
            (replace-regexp-in-string "<span.+?span>" "" caption))
           (caption-text
            (if (> (length parent-links) 0)
                (concat
                  "<div class=\"lilac-caption\">"
                    parent-links
                    polyblock-indicator
                    link-symbol
                  "</div>")
                (concat
                  "<div class=\"lilac-caption\">"
                    caption-without-listing-prefix
                    link-symbol
                  "</div>")))
           )
      (if (s-blank? caption)
       src-block-html
       (concat
        leading-div
          "<div class=\"lilac-pre-with-caption\">"
            caption-text
            body-with-replaced-pre
          "</div>"
        "</div>")))))

__NREF__lilac-get-source-block-html-parts-without-newlines
#+end_src

This is a helper function to parse the HTML output for a source code block.

#+name: __NREF__lilac-get-source-block-html-parts-without-newlines
#+begin_src emacs-lisp
(defun lilac-get-source-block-html-parts-without-newlines (src-block-html)
    (let* ((one-line (lilac-to-single-line src-block-html))
           (leading-div
             (let ((div-match
                    (string-match "<div [^>]+>" one-line)))
               (match-string-no-properties 0 one-line)))
           (caption
             (let* ((caption-match
                      (string-match "<label [^>]+>.*?</label>" one-line)))
               (if caption-match
                   (match-string-no-properties 0 one-line)
                   "")))
           (body (progn (string-match "<pre [^>]+>.*?</pre>" one-line)
                        (match-string-no-properties 0 one-line))))
      `(,leading-div ,caption ,body)))
#+end_src

*** Link noweb references (link to child block from parent block)

Consider the following code:

#+caption: Sample Org-mode Noweb-style references
#+begin_src org
,#+name: parent-block
,#+begin_src bash
echo "Hello from the parent block"
__NREF__child-block-1
__NREF__child-block-2
,#+end_src

...

,#+name: __NREF__child-block-1
,#+begin_src bash
echo "I am child 1"
,#+end_src

...

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo -n "I am "
,#+end_src

,#+header: :noweb-ref __NREF__child-block-2
,#+begin_src bash
echo "child 2"
,#+end_src
#+end_src

What we want to do is to make the =__NREF__child-block-1= and
=__NREF__child-block-2= references inside =parent-block= to link to their
definitions, so that the reader can just click on them to go to see how they're
defined. Unfortunately Org mode doesn't do this by default so we have to do this
ourselves.

In the case of =__NREF__child-block-2=, it is defined in multiple blocks so we
would want to link to the very first block.

We cannot use a =org-export-before-parsing-hook= like we did in
[[__NREF__lilac-publish-modify-org][=__NREF__lilac-publish-modify-org=]] because at that stage of processing, we are
dealing with Org mode syntax. Any modifications we make to the parent source
code block will be treated as text upon HTML export. Thankfully Org mode allows
customizations on generated HTML through the
=org-export-filter-src-block-functions= variable. This variable is analogous to
=org-export-before-parsing-hook=, but operates at the HTML level (not at the Org
syntax level) for source code blocks, which is exactly what we need.

So we have to craft valid HTML links (not Org links) to the child source code
blocks. For this we need the actual =id= part of the HTML =<pre>...= block that
will hold the source code. That is, the algorithm should be something like:

1. for every parent source code block,
2. for every child block (noweb) referenced in the body, insert an HTML link to
   the child block (lookup in =lilac-child-HTML_ID-hash-table=).

The only thing remaining is the construction of
=lilac-child-HTML_ID-hash-table=. We can construct this by mapping through all
source code blocks and getting the name which can be just drawn from the =<label
...>= HTML tag, thanks to the smart captions we inserted for all child blocks
earlier in [[* Automatic captions for Noweb source code blocks]].

#+name: __NREF__lilac-link-to-child-blocks-from-parent
#+begin_src emacs-lisp -r -l ";ref:%s"
; Define a global hash table for mapping child source block names to their HTML
; IDs.
(setq lilac-child-HTML_ID-hash-table (make-hash-table :test 'equal))

(defun lilac-populate-child-HTML_ID-hash-table (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    (let* ((child-name (lilac-get-src-block-name-from-html src-block-html))
           (child-HTML_ID (lilac-get-src-block-HTML_ID src-block-html))
           (child-HTML_ID-exists-already
            (gethash child-name lilac-child-HTML_ID-hash-table nil)))
      ; Skip blocks that lack an HTML ID.
      (if (and child-HTML_ID (not child-HTML_ID-exists-already))
        (puthash child-name child-HTML_ID lilac-child-HTML_ID-hash-table))
      ; Return src-block-html as-is (no modifications).
      src-block-html)))

(defun lilac-get-src-block-name-from-html (src-block-html)
  (let* ((match-nref (string-match
                      (concat
                       "<label.+?<code>"
                       (lilac-nref-rx nil)
                       "</code>")
                      src-block-html))
         (match-raw (if (not match-nref)
                        (string-match
                         (rx-to-string
                          '(and
                            "<label"
                            (+ (not ">"))
                            ">"
                            (group (*? anychar))
                            "</label>"))
                         src-block-html)))
         (matched-contents (match-string-no-properties 1 src-block-html)))
    (if match-nref
        matched-contents
        (if match-raw
            (lilac-clean-up-match-raw matched-contents)))))

(defun lilac-clean-up-match-raw (s)
  (let* ((normalized (lilac-normalize-string s))
         (rx (rx-to-string
                '(and
                  "Listing-"
                  (+ (any digit))
                  (+ "-")
                  "span"
                  (* "-")
                  (group (+ anychar)))))
         (match (string-match rx normalized)))
    (if match
        (match-string-no-properties 1 normalized)
        normalized)))

;ref:lilac-get-src-block-HTML_ID
(defun lilac-get-src-block-HTML_ID (src-block-html)
  (let ((match (string-match "<pre [^>]+?id=\"\\([^\"]+\\)\">" src-block-html)))
    (if match (match-string-no-properties 1 src-block-html))))

(defun lilac-link-to-children-from-parent-body (src-block-html backend info)
  (when (org-export-derived-backend-p backend 'html)
    ;; Break up source block into 3 subparts --- the leading <div ...>, the
    ;; <label ...></label> (if any) and <pre ...></pre>.
    ;; Then run the linkifying logic against only the body, and then return the
    ;; original label and new body.
    (let* ((div-caption-body (lilac-get-source-block-html-parts-without-newlines
                              src-block-html))
           (leading-div (nth 0 div-caption-body))
           (caption (nth 1 div-caption-body))
           (body (nth 2 div-caption-body))
           (body-linkified-without-newlines
            (replace-regexp-in-string
             (lilac-nref-rx nil)
             (lambda (child-name-text)
                 (let* ((HTML_ID (gethash child-name-text
                                          lilac-child-HTML_ID-hash-table)))
                  (if HTML_ID
                      (concat "<span class=\"lilac-child-link-from-parent\">"
                              "<a href=\"#" HTML_ID "\">"
                              (string-remove-prefix "__NREF__" child-name-text)
                              "</a></span>")
                      child-name-text)))
             body))
           (body-linkified-with-newlines
            (lilac-to-multi-line body-linkified-without-newlines)))
      (concat leading-div caption body-linkified-with-newlines "</div>"))))

(defun lilac-to-single-line (s)
  (replace-regexp-in-string "\n" "<<<LILAC_NEWLINE>>>" s))

(defun lilac-to-multi-line (s)
  (replace-regexp-in-string "<<<LILAC_NEWLINE>>>" "\n" s))

__NREF__custom-noweb-delimiters
#+end_src

*** Custom Noweb delimiters

Note that we need to evaluate this lisp code if we want to run ~C-c C-v t~ to
tangle code blocks properly in an interactive manner from an Emacs editing
session.

#+name: __NREF__custom-noweb-delimiters
#+begin_src emacs-lisp :noweb no
(setq org-babel-noweb-wrap-start "__NREF__")
(setq org-babel-noweb-wrap-end "")

(defun lilac-nref-rx (match-optional-params)
  (rx-to-string
   (lilac-nref-rx-primitive match-optional-params)))

(defun lilac-nref-rx-primitive (match-optional-params)
  (if match-optional-params
   `(group
           "__NREF__"
          ;; Noweb reference must start with a letter...
          (any alpha)
          ;; ...and must be followed by
          ;; letters,numbers,dashes,underscores,periods...
          (* (or (any alnum) "-" "_" "."))
          ;; ...and may terminate with a "(...)" where the "..." may be an empty
          ;; string, or some other argument.
          (* (or "()"
                 (and "("
                      (* (not ")"))
                      ")"))))
   `(group
          "__NREF__"
          (any alpha)
          (* (or (any alnum) "-" "_" ".")))))

;; Customize noweb delimiters. Unlike traditional << and >> delimiters, we just
;; use the "__NREF__" prefix as our only delimiter. This has the advantage of
;; being encoded the same way into HTML, which makes our HTML modifications
;; easier and more consistent across different source code languages.
;; See https://emacs.stackexchange.com/a/73720/13006.
(defun org-babel-noweb-wrap (&optional regexp)
  "Return regexp matching a Noweb reference.

Match any reference, or only those matching REGEXP, if non-nil.
When matching, reference is stored in match group 1."
  (lilac-nref-rx t))
#+end_src

** Autogenerate CSS for syntax highlighting of source code blocks

See [[https://emacs.stackexchange.com/questions/31439/how-to-get-colored-syntax-highlighting-of-code-blocks-in-asynchronous-org-mode-e][this]], specifically https://emacs.stackexchange.com/a/36759.

Generate =syntax-highlighting.css= and quit emacs. This function is designed to
be run from the command line on a fresh emacs instance (dedicated OS process).
Unfortunately, by itself it is almost useless (see
[[__NREF__enable-syntax-highlighting-from-batch-mode][=__NREF__enable-syntax-highlighting-from-batch-mode=]]), because there appears to
be a [[https://debbugs.gnu.org/cgi/bugreport.cgi?bug=61521][bug]] in Emacs 28 which [[https://emacs.stackexchange.com/questions/75814/org-html-htmlize-generate-css-not-generating-styles][breaks]] =org-html-htmlize-generate-css=.

#+name: __NREF__lilac_dot_el-autogenerate-css
#+begin_src emacs-lisp
(defun lilac-gen-css-and-exit ()
  (font-lock-flush)
  (font-lock-fontify-buffer)
  (org-html-htmlize-generate-css)
  (with-current-buffer "*html*"
    (write-file "syntax-highlighting.css"))
  (kill-emacs))

;; Without this, batch-org-gen-css-and-exit produces a near-empty CSS file.
__NREF__enable-syntax-highlighting-from-batch-mode
#+end_src

Sadly, =lilac-gen-css-and-exit= by itself generates a near-blank CSS file.
So we have to use code from [[https://emacs.stackexchange.com/questions/38437/org-mode-batch-export-missing-syntax-highlighting][here]]:

#+name: __NREF__enable-syntax-highlighting-from-batch-mode
#+begin_src emacs-lisp
(require 'font-lock)
(require 'subr-x) ;; for `when-let'

(unless (boundp 'maximal-integer)
  (defconst maximal-integer (lsh -1 -1)
    "Maximal integer value representable natively in emacs lisp."))

(defun face-spec-default (spec)
  "Get list containing at most the default entry of face SPEC.
Return nil if SPEC has no default entry."
  (let* ((first (car-safe spec))
     (display (car-safe first)))
    (when (eq display 'default)
      (list (car-safe spec)))))

(defun face-spec-min-color (display-atts)
  "Get min-color entry of DISPLAY-ATTS pair from face spec."
  (let* ((display (car-safe display-atts)))
    (or (car-safe (cdr (assoc 'min-colors display)))
    maximal-integer)))

(defun face-spec-highest-color (spec)
  "Search face SPEC for highest color.
That means the DISPLAY entry of SPEC
with class 'color and highest min-color value."
  (let ((color-list (cl-remove-if-not
             (lambda (display-atts)
               (when-let ((display (car-safe display-atts))
                  (class (and (listp display)
                          (assoc 'class display)))
                  (background (assoc 'background display)))
             (and (member 'light (cdr background))
                  (member 'color (cdr class)))))
             spec)))
    (cl-reduce (lambda (display-atts1 display-atts2)
         (if (> (face-spec-min-color display-atts1)
            (face-spec-min-color display-atts2))
             display-atts1
           display-atts2))
           (cdr color-list)
           :initial-value (car color-list))))

(defun face-spec-t (spec)
  "Search face SPEC for fall back."
  (cl-find-if (lambda (display-atts)
        (eq (car-safe display-atts) t))
          spec))

; This is slightly tweaked from the original, because the incoming "face" value
; can look like (fixed-pitch face-name) --- so we take the second element.
(defun my-face-attribute (face attribute &optional frame inherit)
  "Get FACE ATTRIBUTE from `face-user-default-spec' and not from
`face-attribute'."
  (let*
    ((face-spec (face-user-default-spec (if (listp face)
                                            (car (cdr face))
                                          face)))
     (display-attr (or (face-spec-highest-color face-spec)
               (face-spec-t face-spec)))
     (attr (cdr display-attr))
     (val (or (plist-get attr attribute)
              (car-safe (cdr (assoc attribute attr))))))
    (when (and (null (eq attribute :inherit))
           (null val))
      (let ((inherited-face (my-face-attribute face :inherit)))
    (when (and inherited-face
           (null (eq inherited-face 'unspecified)))
      (setq val (my-face-attribute inherited-face attribute)))))
    (or val 'unspecified)))

(advice-add 'face-attribute :override #'my-face-attribute)
#+end_src

** Misc settings

*** Use HTML5 export, not XML (to un-break MathJax)

By default on Org 9.6, MathJax settings (JavaScript snippet) gets wrapped in a
CDATA tag, and we run into the same problem described on this email that has
gone unanswered:
https://www.mail-archive.com/emacs-orgmode@gnu.org/msg140821.html. It appears
that this is because the document is exported as XML, not HTMl. Setting the
document type to =html5=, as below, appears to make the CDATA tag magically
disappear.

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(setq org-html-doctype "html5")
#+end_src

*** Preserve leading whitespace characters on export

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src

*** Disable backups

Disable backup files for =lilac.el= (that look like =lilac.el~=) when we invoke
Emacs from the [[Makefile][Makefile]].

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(setq make-backup-files nil)
#+end_src

*** Profiling

We don't use this very often, but it's mainly for determining cost centers for
weaving and tangling.

#+header: :noweb-ref __NREF__lilac_dot_el-misc
#+begin_src emacs-lisp
(defun lilac-publish-profile ()
  (interactive)
  (profiler-start 'cpu)
  (lilac-publish)
  (profiler-stop)
  (profiler-report)
  (profiler-report-write-profile "emacs-profile-weave.txt") t)

(defun lilac-tangle-profile ()
  (interactive)
  (profiler-start 'cpu)
  (org-babel-tangle)
  (profiler-stop)
  (profiler-report)
  (profiler-report-write-profile "emacs-profile-tangle.txt") t)
#+end_src

** Automatically link headlines (h2 to h6)

Every HTML element =h2= to =h6= (which encode the Org mode headlines) already
come with a unique ID, but they are only ever linked from the Table of Contents.
The code here makes it so that the headlines are linked to themselves, which
makes it easy for users to link to them directly when they're reading the page.

The JavaScript below is taken from [[https://github.com/listx/listx_blog/blame/8e6e7b533d89f77a6939e5eda9fd9d990d25a7a9/misc.js#L1][here]].

#+name: misc.js
#+caption: misc.js
#+begin_src js :tangle misc.js :eval no
$(function() {
    $("h2,h3,h4,h5,h6").each(function() {
        var $this = $(this);
        var href = $this.attr("id");
        $this.wrapInner(
            $("<a/>").attr("href", '#' + href)
                     .addClass("section-heading"));
    });
});
#+end_src

Now we just have to refer to the above in the snippet below, to be included in [[* Create
=lilac.theme= file][=lilac.theme=]].

#+name: __NREF__automatically_link_headlines
#+begin_src org
# Automatically link headlines.
,#+HTML_HEAD: <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
,#+HTML_HEAD: <script src="misc.js"></script>
#+end_src

Linkifying itself makes all the headlines blue (the default color for links).
This is a bit distracting, so make them black.

#+name: __NREF__css-source-code-section-headlines
#+begin_src css
a.section-heading {
    color: black;
    text-decoration: none;
}

a.section-heading:hover::after {
    float: left;
    margin-left: -1.3em;
    content: "\1f517";
}
#+end_src

** Imports

If we want syntax-highlighting to work for a code block, that code block's major
mode (language) must be loaded in here.

#+name: __NREF__lilac_dot_el-imports
#+begin_src emacs-lisp
;; Built-in packages (distributed with Emacs).
(require 'elisp-mode)

;; Third-party packages (checked in as Git submodules)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/s.el"))
(require 's)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/compat.el"))
(require 'compat)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/dash.el"))
(require 'dash)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/dr-qubit.org"))
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/f.el"))
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/parsebib"))
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/citeproc-el"))
(require 'citeproc)
(require 'oc-csl)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/emacs-htmlize"))
(require 'htmlize)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/magit/lisp"))
(require 'magit-section)
(add-to-list 'load-path (concat (getenv "PWD") "/deps/elisp/nix-mode"))
(require 'nix-mode)
#+end_src

** Additional (hand-tweaked) CSS

We add some additional CSS tweaks on top of what we get from Org.

#+name: style.css
#+caption: style.css
#+begin_src css :tangle style.css
a {
    color: #0000ff;
}

body {
    font-size: 1.5em;
    width: 1000px;
    margin: auto;
}

body, p, li, h1, h2, h3, h4, h5, h6, legend {
    font-family: "Source Serif Pro", serif;
}

p, li {
    line-height: 1.2em;
}

p, ol, ul {
    margin-bottom: 0.5em;
}

li {
    margin-bottom: 0;
}

table {
    margin: 1em auto 0em auto;
    border-spacing: 0;
    border-radius: 4px;
    border: 1px solid #777;
    border-collapse: unset;
}

th, td {
    padding: 3px 6px;
    border-right: 1px solid #777;
    border-bottom: 1px solid #777;
}

th:last-child, td:last-child  {
    border-right: none;
}

tr:last-child td {
    border-bottom: none;
}

/* Center all images. */
img {
    display: block;
    margin: 0 auto;
}

/* Increase text size for smaller sections. */
h3, h4, h5, h6 {
    margin-top: 1em;
    margin-bottom: 1em;
}
h7 {
    font-weight: bold;
    font-size: 18pt;
}
.outline-7 {
    margin-top: 1em;
}

code {
    background: #eee;
    padding-left: 5px;
    padding-right: 5px;
    white-space: nowrap;
    border-radius: 4px;
    border-style: solid;
    border-width: 1px;
    border-color: #777;
}

thead {
    background: #eee;
}

pre {
    font-size: 0.8em;
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
}

__NREF__css-source-code-section-headlines
__NREF__css-source-code-block-body
__NREF__css-source-code-block-captions
__NREF__css-source-code-block-child-link-from-parent
#+end_src

*** Source code block body

#+name: __NREF__css-source-code-block-body
#+begin_src css
.org-src-container {
    margin: 1em 0;
}

.org-src-container pre {
    margin: 0;
    font-family: "Source Code Pro", monospace;
    border-width: 0;
    scroll-margin-top: 100px;
    border-style: solid;
    border-width: 2px;
    border-color: #999;
    border-radius: 5px;
}

/* Source code block body. */
.org-src-container pre.src {
    background-color: #f3f3f3;
}

#+end_src

*** Source code block captions

#+name: __NREF__css-source-code-block-captions
#+begin_src css
.lilac-caption {
    font-family: "Source Code Pro", monospace;
    text-align: right;
    border-top-left-radius: 5px;
    border-top-right-radius: 5px;
    padding-top: 2px;
    padding-bottom: 5px;
}

.lilac-caption label {
    margin-right: 10px;
    padding-left: 10px;
    padding-right: 10px;
    padding-bottom: 10px;
    border-radius: 5px;
    border-style: solid;
    border-bottom-style: none;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
    background-color: #ddd;
    border-color: #999;
}

.lilac-caption-source-code-block-name {
    color: #444444;
    font-weight: bold;
    margin-right: 5px;
}

.lilac-caption-parent-link {
    margin-top: 5px;
    margin-right: 5px;
    padding-left: 5px;
    padding-right: 5px;
    font-weight: bold;
}
.lilac-caption-parent-link a {
    padding-left: 10px;
    padding-right: 10px;
    padding-bottom: 10px;
    color: #21618c;
    background-color: #d8f6ff;
    border-radius: 5px;
    border-style: solid;
    border-bottom-style: none;
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
}
.lilac-caption-parent-link a:hover {
    color: #7d3c98;
    background-color: #f8e9ff;
    text-decoration: none;
}

.lilac-caption-link-symbol a {
    margin-right: 5px;
}
.lilac-caption-link-symbol a:hover {
    text-decoration: none;
}

.lilac-caption-listing-number {
    margin-right: 5px;
}
#+end_src

*** Links to child source block from parent

#+name: __NREF__css-source-code-block-child-link-from-parent
#+begin_src css
.lilac-child-link-from-parent {
    font-weight: bold;
}
.lilac-child-link-from-parent a {
    color: #21618c;
    background-color: #d8f6ff;
    border-radius: 5px;
    border-style: solid;
    margin: 5px 0;
    padding: 2px 5px;
    display: inline-block;
}
.lilac-child-link-from-parent a:hover {
    color: #7d3c98;
    background-color: #f8e9ff;
    text-decoration: none;
}
#+end_src

** Create =lilac.theme= file

Allow HTML exports of Org files (inluding this one) to pull in CSS and
JavaScript that we've defined for Lilac by referring to a single theme file. The
inspiration for this setup comes from https://gitlab.com/OlMon/org-themes.

#+name: lilac.theme
#+caption: lilac.theme
#+begin_src org :tangle lilac.theme :eval no
# Include additional CSS styles.
,#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="syntax-highlighting.css"/>
,#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css" />
,#+HTML_HEAD: <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&family=Source+Code+Pro">

__NREF__automatically_link_headlines
#+end_src

** Ignore woven HTML from =git diff=

Typically we only need to look at the rendered HTML output in a web browser as
the raw HTML diff output is extremely difficult to parse as a human. So by
default we ask Git to exclude it from =git diff= by treating them as binary
data.

#+name: .gitattributes
#+caption: .gitattributes
#+begin_src gitattributes :tangle .gitattributes :eval no
,* -diff
,**/*.org diff
,**/.gitattributes diff
,**/.gitmodules diff
,**/.gitignore diff
package/nix/sources.json diff
package/nix/sources.nix diff
#+end_src

In order to still show the HTML textual diff, we can run =git diff --text=.

*** =git add -p=

Note that the above setting to treat HTML files as binary data prevents them
from being considered for =git add -p=. In order to add them, use =git add -u=
instead.

** gitignore

#+name: .gitignore
#+caption: .gitignore
#+begin_src gitignore :tangle .gitignore :eval no
,**/*.auctex-auto
tangle
update-deps
weave
#+end_src

* Tangling (generating the source code)

Tangling is simply the act of collecting the =#+begin_src ... #+end_src= blocks
and arranging them into the various target (source code) files. Every source
code block is given a unique name.

We simply tangle the =README.org= file (this file) to get all the code we need.

* Development environment (Nix shell)

This is the main development shell and brings in all of our dependencies to
build all of our code. Taken from [[https://github.com/tweag/haskell-stack-nix-example/blob/b9383e35416a2b0e21fbc97ed079538f9f395b6a/shell.nix#L1][here]]. The =Makefile= is meant to be executed
from within this environment.

#+name: shell.nix
#+caption: shell.nix
#+begin_src nix :tangle shell.nix :eval no
let
  # Nixpkgs snapshot.
  sources = import ./package/nix/sources.nix;
  # The final "pkgs" attribute.
  pkgs = import sources.nixpkgs {};
in

# This is our development shell.
pkgs.mkShell ({
  buildInputs = [
    # Tangling and weaving for Literate Programming.
    pkgs.emacs

    # Update Nix dependencies in package/nix/sources.nix.
    pkgs.niv

    # Misc.
    pkgs.git
    pkgs.less
  ];
})
#+end_src

* Tests

We use [[https://www.gnu.org/software/emacs/manual/ert.html][ERT, the Emacs Lisp Regression Testing tool]] for our unit tests. Pure
functions that take all of their inputs explicitly ("dependency-injected") are
easy to test because we just provide the various inputs and expect the function
to produce certain outputs. For functions that operate on an Emacs buffer, we
use =with-temp-buffer= to create a temporary buffer first before invoking the
functions under test.

Some functions we test expect Org mode to be active (so that certain Org mode
functions are available), so we turn it on here by calling =(org-mode)=.

#+name: lilac-tests.el
#+caption: lilac-tests.el
#+begin_src emacs-lisp :tangle lilac-tests.el :eval no
(require 'ert)
(require 'lilac)

(org-mode)

__NREF__t-helpers
__NREF__t-smart-caption-generation

(provide 'lilac-tests)
#+end_src

** Test helpers

Note that we cannot write =__NREF__foo= directly in the test code here, because
when this Org file is tangled, the references will be detected and Org mode will
try to replace them with a monoblock or polyblock elsewhere in this file named
=__NREF__foo=. So we have to go in "stealth mode" by writing the =__NREF__=
prefix indirectly with the =(nref)= helper function.

#+name: __NREF__t-helpers
#+begin_src emacs-lisp
(defun nref (s) (concat "__NREF__" s))
#+end_src

** Smart source code block caption helpers

=lilac-get-noweb-children= should return a list of Noweb references (child block
names) found in a source code block.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-get-noweb-children ()
  (let ((body
         (concat
          "#+name: foo\n"
          "#+caption: foo\n"
          "#+begin_src emacs-lisp\n"
          "; foo\n"
          "#+end_src\n")))
    (should (equal (lilac-get-noweb-children body)
                   ())))
  (let ((body
         (concat
          "#+name: parent\n"
          "#+caption: parent\n"
          "#+begin_src emacs-lisp\n"
          "; foo\n"
          (nref "one") "\n"
          "; bar\n"
          (nref "two") "\n"
          "#+end_src\n")))
    (should (equal (lilac-get-noweb-children body)
                   `(,(nref "one") ,(nref "two"))))))
#+end_src

=lilac-is-parent-block= depends on =lilac-get-noweb-children=. We tested the
latter already above, but we test the former anyway for completeness.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-is-parent-block ()
  (with-temp-buffer
    (insert "#+name: parent\n")
    (insert "#+caption: parent\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child") "\n"))
    (insert "#+end_src\n")
    (goto-char (point-min))
    (let ((src-block (org-element-at-point)))
      (should-not (equal nil (lilac-is-parent-block src-block))))))
#+end_src

Here we test whether we can automatically insert captions for child blocks.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-insert-noweb-source-code-block-captions ()
  (with-temp-buffer
    (insert "#+name: parent\n")
    (insert "#+caption: parent\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child2") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; baz\n")
    (insert "#+end_src\n")
    (lilac-insert-noweb-source-code-block-captions nil)
    (goto-char (point-min))
    (should (search-forward
             (concat "#+caption: =" (nref "child1") "=  [[parent][1]]")
             nil t))
    (should (search-forward
             (concat "#+caption: =" (nref "child2") "=  [[parent][1]]")
             nil t)))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child2") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; baz\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: parent2\n"))
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (lilac-insert-noweb-source-code-block-captions nil)
    (goto-char (point-min))
    (should (search-forward
             (concat "#+caption: =" (nref "child1") "=  [[parent1][1]]  [[parent2][2]]")
             nil t))
    (should (search-forward
             (concat "#+caption: =" (nref "child2") "=  [[parent1][1]]")
             nil t))))
#+end_src

Here we test retrieval of parent source code blocks.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-get-parent-blocks ()
  (with-temp-buffer
    (insert "#+name: foo\n")
    (insert "#+caption: foo\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: bar\n")
    (insert "#+caption: bar\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert "#+end_src\n")
    (should-not (lilac-get-parent-blocks)))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (should (lilac-get-parent-blocks))))
#+end_src

Here we test generating the child-to-parents hash table.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-mk-child-parents-hash-table ()
  (with-temp-buffer
    (insert "#+name: foo\n")
    (insert "#+caption: foo\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: bar\n")
    (insert "#+caption: bar\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks)))
      (should (equal (hash-table-count child-parents-hash-table) 0))))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks)))
      (should (equal (hash-table-count child-parents-hash-table) 2)))))
#+end_src

Here we test the construction of smart captions.

#+header: :noweb-ref __NREF__t-smart-caption-generation
#+begin_src emacs-lisp
(ert-deftest t-lilac-mk-smart-captions ()
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (should (equal smart-captions nil))))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child1\n")
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (should (equal smart-captions
       `((181 . ,(concat "#+caption: ="
                         (nref "child1")
                         "=  [[parent1][1]]  [[parent2][2]]\n")))))))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert "#+name: parent2\n")
    (insert "#+caption: parent2\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; bar\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child1\n")
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child2") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child2\n")
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (should (equal smart-captions
       `((181 . ,(concat "#+caption: ="
                         (nref "child1")
                         "=  [[parent1][1]]\n"))
         (247 . ,(concat "#+caption: ="
                         (nref "child2")
                         "=  [[parent2][1]]\n")))))))
  (with-temp-buffer
    (insert "#+name: parent1\n")
    (insert "#+caption: parent1\n")
    (insert "#+begin_src emacs-lisp\n")
    (insert "; foo\n")
    (insert (concat (nref "child1") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child1") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child1\n")
    (insert (concat (nref "child2") "\n"))
    (insert "#+end_src\n")
    (insert "\n")
    (insert (concat "#+name: " (nref "child2") "\n"))
    (insert "#+begin_src emacs-lisp\n")
    (insert "; child2\n")
    (insert "#+end_src\n")
    (let* ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (should (equal smart-captions
       `((91 . ,(concat "#+caption: ="
                         (nref "child1")
                         "=  [[parent1][1]]\n"))
         (172 . ,(concat "#+caption: ="
                         (nref "child2")
                         "=  [["
                         (nref "child1")
                         "][1]]\n"))))))))
#+end_src

* Glossary

- <<monoblock>> *monoblock* :: an Org mode source code block with a =#+name:
  ...= field. This block is an independent block and there are no other blocks
  with the same name.
- *Noweb* :: A literate programming tool from 1989 that still works and from
  which [[Org mode][Org mode]] borrows heavily using [[noweb-ref][Noweb-style references]]. See [[https://en.wikipedia.org/wiki/Noweb][Wikipedia]].
- <<noweb-ref>> *noweb-ref* :: aka "Noweb-style reference". A Noweb-style
  reference is just a name (string) that refers to a monoblock or polyblock. See
  [[https://orgmode.org/manual/Noweb-Reference-Syntax.html][the Org manual]].
- <<Org mode>> *Org mode* :: An Emacs major mode for =*.org= files, where "major
  mode" means that it provides things like syntax highlighting and keyboard
  shortcuts for =*.org= text files if you are using Emacs. For Lilac, the
  important thing is that we use Org mode as a literate programming tool. See
  [[https://orgmode.org/][Org mode]].
- <<polyblock>> *polyblock* :: an Org mode source code block without a =#+name:
  ...= field, but which has a =#+header: :noweb-ref ...= field. Other blocks
  with the same Noweb-ref name are concatenated together when they are tangled.
  Polyblocks are used in cases where we would like to break up a single block
  into smaller pieces for explanatory purposes. In all other cases, monoblocks
  are preferable, unless the source code block is not to be tangled and is only
  for explanatory purposes in the woven output.
- *source code block* :: An Org mode facility that allows you to enclose a
  multiline piece of text with =#+begin_src ...= and =#+end_src= lines.

* References

#+begin_src bibtex :tangle citations.bib :eval no :exports none
@article{knuth_1984,
    title = {Literate Programming},
    volume = {27},
    issn = {0010-4620, 1460-2067},
    url = {https://academic.oup.com/comjnl/article-lookup/doi/10.1093/comjnl/27.2.97},
    doi = {10.1093/comjnl/27.2.97},
    language = {en},
    number = {2},
    urldate = {2023-05-03},
    journal = {The Computer Journal},
    author = {Knuth, D. E.},
    month = feb,
    year = {1984},
    pages = {97--111},
}

@article{ramsey_1994,
    title = {Literate programming simplified},
    author = {Ramsey, Norman},
    year = {1994},
    journal = {IEEE Software},
    volume = {11},
    issn = {1937-4194},
    doi = {10.1109/52.311070},
    abstract = {Literate programming tools let you arrange the parts of a
                  program in any order and extract documentation and code from
                  the same source file. The author argues that
                  language-dependence and feature complexity have hampered
                  acceptance of these tools, then offers a simpler
                  alternative.{\textless}{\textgreater}},
    number = {5},
    month = sep,
    keywords = {Documentation, Code standards, Writing, Program processors,
                  Computer languages, Operating systems, Internet, Strips,
                  Pipelines},
    pages = {97--105},
}
#+end_src

#+CITE_EXPORT: csl ~/prog/lilac/deps/styles/ieee.csl
#+PRINT_BIBLIOGRAPHY:
