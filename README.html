<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lilac</title>
<meta name="author" content="Linus Arver" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="syntax-highlighting.css"/>
<link rel="stylesheet" type="text/css" href="style.css" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&family=Source+Code+Pro">
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<script src="misc.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Lilac</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h-Introduction">1. Introduction</a></li>
<li><a href="#h-Motivation">2. Motivation</a>
<ul>
<li><a href="#h-Problems-with-Org-mode">2.1. Problems with Org mode</a></li>
<li><a href="#h-Lilac-to-the-rescue">2.2. Lilac to the rescue</a></li>
</ul>
</li>
<li><a href="#h-Usage">3. Usage</a>
<ul>
<li><a href="#h-Source-code-blocks--monoblocks-and-polyblocks">3.1. Source code blocks: monoblocks and polyblocks</a>
<ul>
<li><a href="#h-Examples-of-source-code-blocks">3.1.1. Examples of source code blocks</a>
<ul>
<li><a href="#h-Multi-parent-child-blocks">3.1.1.1. Multi-parent child blocks</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-How-Lilac-uses-LP">4. How Lilac uses LP</a></li>
<li><a href="#h-Weaving--generating-the-HTML">5. Weaving (generating the HTML)</a>
<ul>
<li><a href="#h-Makefile">5.1. Makefile</a></li>
<li><a href="#h-Emacs-customizations-for-HTML-export---lilac-el-">5.2. Emacs customizations for HTML export (<code>lilac.el</code>)</a></li>
<li><a href="#h-Fix-non-determinism">5.3. Fix non-determinism</a>
<ul>
<li><a href="#h-Do-not-insert-current-time-as-HTML-comment">5.3.1. Do not insert current time as HTML comment</a></li>
<li><a href="#h-Do-not-insert-current-Org-mode-version">5.3.2. Do not insert current Org mode version</a></li>
<li><a href="#h-Do-not-use-random-numbers-for-the-HTML---id---attribute">5.3.3. Do not use random numbers for the HTML "<code>id</code>" attribute</a></li>
</ul>
</li>
<li><a href="#h-Toplevel-publishing-function---lilac-publish-">5.4. Toplevel publishing function (<code>lilac-publish</code>)</a>
<ul>
<li><a href="#h-Modify-the-Org-buffer">5.4.1. Modify the Org buffer</a></li>
<li><a href="#h-Modify-the-HTML">5.4.2. Modify the HTML</a></li>
<li><a href="#h-Miscellaneous-export-settings">5.4.3. Miscellaneous export settings</a></li>
</ul>
</li>
<li><a href="#h-Org-modifications">5.5. Org modifications</a>
<ul>
<li><a href="#h-Give-all-source-code-blocks-a----name-------field--HTML-ID">5.5.1. Give all source code blocks a <code>#+name: ...</code> field (HTML ID)</a></li>
<li><a href="#h-Automatic-captions-for-Noweb-source-code-blocks">5.5.2. Automatic captions for Noweb source code blocks</a></li>
<li><a href="#h-Human-readable-UIDs--Headings--aka-headlines">5.5.3. Human-readable UIDs (Headings, aka headlines)</a></li>
</ul>
</li>
<li><a href="#h-HTML-modifications">5.6. HTML modifications</a>
<ul>
<li><a href="#h-Use-human-readable-HTML-IDs-for-source-code-links">5.6.1. Use human-readable HTML IDs for source code links</a></li>
<li><a href="#h-Pretty-source-code-captions">5.6.2. Pretty source code captions</a></li>
<li><a href="#h-Link-noweb-references--link-to-child-block-from-parent-block">5.6.3. Link noweb references (link to child block from parent block)</a></li>
<li><a href="#h-Custom-Noweb-delimiters">5.6.4. Custom Noweb delimiters</a></li>
</ul>
</li>
<li><a href="#h-Autogenerate-CSS-for-syntax-highlighting-of-source-code-blocks">5.7. Autogenerate CSS for syntax highlighting of source code blocks</a></li>
<li><a href="#h-Misc-settings">5.8. Misc settings</a>
<ul>
<li><a href="#h-Use-HTML5-export--not-XML--to-un-break-MathJax">5.8.1. Use HTML5 export, not XML (to un-break MathJax)</a></li>
<li><a href="#h-Preserve-leading-whitespace-characters-on-export">5.8.2. Preserve leading whitespace characters on export</a></li>
<li><a href="#h-Disable-backups">5.8.3. Disable backups</a></li>
<li><a href="#h-Profiling">5.8.4. Profiling</a></li>
</ul>
</li>
<li><a href="#h-Automatically-link-headlines--h2-to-h6">5.9. Automatically link headlines (h2 to h6)</a></li>
<li><a href="#h-Imports">5.10. Imports</a></li>
<li><a href="#h-Additional--hand-tweaked--CSS">5.11. Additional (hand-tweaked) CSS</a>
<ul>
<li><a href="#h-Source-code-block-body">5.11.1. Source code block body</a></li>
<li><a href="#h-Source-code-block-captions">5.11.2. Source code block captions</a></li>
<li><a href="#h-Links-to-child-source-block-from-parent">5.11.3. Links to child source block from parent</a></li>
</ul>
</li>
<li><a href="#h-Create--lilac-theme--file">5.12. Create <code>lilac.theme</code> file</a></li>
<li><a href="#h-Ignore-woven-HTML-from--git-diff">5.13. Ignore woven HTML from <code>git diff</code></a>
<ul>
<li><a href="#h-git-add--p">5.13.1. <code>git add -p</code></a></li>
</ul>
</li>
<li><a href="#h-gitignore">5.14. gitignore</a></li>
</ul>
</li>
<li><a href="#h-Tangling--generating-the-source-code">6. Tangling (generating the source code)</a></li>
<li><a href="#h-Development-environment--Nix-shell">7. Development environment (Nix shell)</a></li>
<li><a href="#h-Tests">8. Tests</a>
<ul>
<li><a href="#h-Test-helpers">8.1. Test helpers</a></li>
<li><a href="#h-Smart-source-code-block-caption-helpers">8.2. Smart source code block caption helpers</a></li>
</ul>
</li>
<li><a href="#h-Glossary">9. Glossary</a></li>
<li><a href="#h-References">10. References</a></li>
</ul>
</div>
</div>

<div id="outline-container-h-Introduction" class="outline-2">
<h2 id="h-Introduction"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-h-Introduction">
<p>
<i>Lilac</i> is an addon for Emacs Org mode to make <a href="https://en.wikipedia.org/wiki/Literate_programming">Literate Programming</a> (LP) using
Noweb-style <a href="#citeproc_bib_item_1">[1]</a> references easy. It comes in two parts:
</p>

<ol class="org-ol">
<li><code>lilac.el</code>: to be loaded and used when <i>weaving</i> <a href="#citeproc_bib_item_2">[2, p. 98]</a> and
<i>tangling</i> <a href="#citeproc_bib_item_2">[2, p. 98]</a> from your own Org mode files (which use
Noweb references), and</li>
<li><code>lilac.theme</code>: to be sourced by your Org mode files to use Lilac's customized
HTML export.</li>
</ol>

<p>
This document itself reuses the <code>lilac.theme</code> file, which gives you a preview
(if you are viewing the HTML output) of what weaving with Lilac looks like.
</p>
</div>
</div>

<div id="outline-container-h-Motivation" class="outline-2">
<h2 id="h-Motivation"><span class="section-number-2">2.</span> Motivation</h2>
<div class="outline-text-2" id="text-h-Motivation">
<p>
Lilac was created mainly because the existing Org mode features around Noweb
references were lacking in features. There seems to have been a great deal of
effort to make <i>tangling</i> (extracting source code from source code blocks) work
well, but not much has been done around <i>weaving</i>, where I think most of the
difficulties lie (because making output look good to a human (weaving) is much
more difficult than making output look good to a computer (tangling)).
</p>
</div>

<div id="outline-container-h-Problems-with-Org-mode" class="outline-3">
<h3 id="h-Problems-with-Org-mode"><span class="section-number-3">2.1.</span> Problems with Org mode</h3>
<div class="outline-text-3" id="text-h-Problems-with-Org-mode">
<p>
By default, source code blocks do not get any captions in the HTML output. This
is a problem for LP because you have to manually explain the name of each block
to keep track of their usage in other blocks (when referring to them with Noweb
style references). This gets repetitive rather quickly.
</p>

<p>
While Org mode allows source code blocks to refer to other blocks (Noweb
references), it does not do any kind of linking. So you can write blocks like
</p>

<div class="org-src-container"><pre class="src src-org" id="org0000000"><span class="org-org-meta-line">#+name: example-parent-block</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"Hello from the parent block"</span></span>
<span class="org-org-block">&lt;&lt;some-other-block&gt;&gt;</span>
<span class="org-org-block-end-line">#+end_src</span>

...

<span class="org-org-meta-line">#+name: some-child-block</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"I am child 1"</span></span>
<span class="org-org-block-end-line">#+end_src</span>
</pre></div><p>
but when this is exported to HTML neither <code>example-parent-block</code> nor
<code>some-child-block</code> have any links to each other. This is frustrating because it
makes navigating between them difficult.
</p>

<p>
Org mode does not create link anchors for headings, which makes referring to
them from other external documents slightly annoying. Org mode does not add link
anchors to source code blocks.
</p>

<p>
Org mode generates random link ID's on every export. That is, even if you change
nothing in your Org mode file, if you export to HTML there <b>will</b> be a diff
because all of the linked objects will get a new link ID.
</p>
</div>
</div>

<div id="outline-container-h-Lilac-to-the-rescue" class="outline-3">
<h3 id="h-Lilac-to-the-rescue"><span class="section-number-3">2.2.</span> Lilac to the rescue</h3>
<div class="outline-text-3" id="text-h-Lilac-to-the-rescue">
<p>
Lilac addresses all of the issues presented above.
</p>

<p>
Lilac frees you from having to write
a custom <code>#+caption: ...</code> text for every source code block, because it generates
them automatically based on the name of the Noweb reference. And Lilac
automatically links child blocks and parent blocks together. Lilac automatically
adds link anchors to all source code blocks as well as headlines, making it
easier to link to different parts of an Org file while browsing it.
</p>

<p>
Lilac makes HTML generation deterministic. This makes it VCS and CI-friendly
because the output changes if and only if the input changes. Speaking of
CI-friendliness, Lilac was designed to be run from outside of Emacs by default
(and not interactively).
</p>
</div>
</div>
</div>

<div id="outline-container-h-Usage" class="outline-2">
<h2 id="h-Usage"><span class="section-number-2">3.</span> Usage</h2>
<div class="outline-text-2" id="text-h-Usage">
<p>
First create an Org mode file that uses LP. Then either clone this repo or add
it as a submodule to your project. The point is to get the <code>lilac.el</code> (and its
dependencies, themselves submodules) and <code>lilac.theme</code> (and associated
CSS/JavaScript files) available locally. Then for the Org mode file you are
using, you can load <code>lilac.el</code> and run <code>(lilac-publish)</code> to generate the HTML
file, or run <code>(org-babel-tangle)</code> to generate the source code from it. See the
<code>Makefile</code> that this project uses as a reference.
</p>

<p>
The main thing that you need to keep in mind when writing Org mode files for
consumption by Lilac is that the source code blocks must use Noweb references
using <code>__NREF__</code> as a prefix. See the discussion below.
</p>
</div>

<div id="outline-container-h-Source-code-blocks--monoblocks-and-polyblocks" class="outline-3">
<h3 id="h-Source-code-blocks--monoblocks-and-polyblocks"><span class="section-number-3">3.1.</span> Source code blocks: monoblocks and polyblocks</h3>
<div class="outline-text-3" id="text-h-Source-code-blocks--monoblocks-and-polyblocks">
<p>
In Org mode, Noweb-style references by default must be enclosed in double angle
brackets <code>&lt;&lt;</code> and <code>&gt;&gt;</code>. While this works, it's problematic because it can mean
different things syntactically based on the source code language. Your source
code block's language might think that the angle brackets are operators or
keywords and colorize them differently, for example.
</p>

<p>
Instead, Lilac expects Noweb-style references in the form <code>__NREF__foo</code> (where
the "NREF" stands for "Noweb reference"). Then you are free to name your child
block with this same <code>__NREF__foo</code> name. This is better because now you can
search for this word <code>__NREF__foo</code> in your raw Org mode document and you'll
instantly be able to see where it is used. Contrast this with the default Org
mode behavior where you'll have to search for <code>&lt;&lt;foo&gt;&gt;</code> and <code>foo</code> separately
(because searching for just <code>foo</code> may collide with other names that are not
source code block names).
</p>

<p>
In the example below, the <code>parent-block</code> refers to 2 other child blocks for its
definition.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Sample Org-mode Noweb-style references</label><span class="lilac-caption-link-symbol"><a href="#Sample-Org-mode-Noweb-style-references-1">&#x1f517;</a></span></div><pre class="src src-org" id="Sample-Org-mode-Noweb-style-references-1"><span class="org-org-meta-line">#+name: parent-block</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"Hello from the parent block"</span></span>
<span class="org-org-block">__NREF__child-block-1</span>
<span class="org-org-block">__NREF__child-block-2</span>
<span class="org-org-block-end-line">#+end_src</span>

...

<span class="org-org-meta-line">#+name: __NREF__child-block-1</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"I am child 1"</span></span>
<span class="org-org-block-end-line">#+end_src</span>

...

<span class="org-org-meta-line">#+header: :noweb-ref __NREF__child-block-2</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> -n </span><span class="org-org-block"><span class="org-string">"I am "</span></span>
<span class="org-org-block-end-line">#+end_src</span>

<span class="org-org-meta-line">#+header: :noweb-ref __NREF__child-block-2</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"child 2"</span></span>
<span class="org-org-block-end-line">#+end_src</span>
</pre></div></div><p>
This example illustrates the two ways to define a child block: either as a
single code block with <code>#+name: __NREF__foo</code>, or as multiple blocks with
<code>#+header: :noweb-ref __NREF__foo</code>. Lilac calls them <a href="#org0000004">monoblocks</a> and <a href="#org0000006">polyblocks</a>
respectively. Polyblocks are concatenated together in the order they appear in
the overall Org file; this final concatenated version is what gets inserted into
the Noweb reference in the parent block.
</p>
</div>

<div id="outline-container-h-Examples-of-source-code-blocks" class="outline-4">
<h4 id="h-Examples-of-source-code-blocks"><span class="section-number-4">3.1.1.</span> Examples of source code blocks</h4>
<div class="outline-text-4" id="text-h-Examples-of-source-code-blocks">
<p>
Below is an example of the usage described above. Notice how the child blocks
referenced in the parent block are linked to their definitions.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">example-parent-block</label><span class="lilac-caption-link-symbol"><a href="#example-parent-block">&#x1f517;</a></span></div><pre class="src src-bash" id="example-parent-block"><span class="org-builtin">echo</span> <span class="org-string">"Hello from the parent block"</span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__example-child-block-foo">example-child-block-foo</a></span>
<span class="org-builtin">echo</span> <span class="org-string">""</span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__example-child-block-bar-1">example-child-block-bar</a></span>
</pre></div></div><p>
Below are the child blocks. The first is a monoblock. Every child block's name
links back up to the parent block where it is referenced.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#example-parent-block">example-child-block-foo</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__example-child-block-foo">&#x1f517;</a></span></div><pre class="src src-bash" id="__NREF__example-child-block-foo"><span class="org-builtin">echo</span> <span class="org-string">"I am child 1"</span>
</pre></div></div><p>
The blocks below are polyblocks.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#example-parent-block">example-child-block-bar</a></span>(1/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__example-child-block-bar-1">&#x1f517;</a></span></div><pre class="src src-bash" id="__NREF__example-child-block-bar-1"><span class="org-builtin">echo</span> -n <span class="org-string">"I am "</span>
</pre></div></div><p>
Note the fraction after the name which denotes the position of the block in the
overall polyblock "chain".
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#example-parent-block">example-child-block-bar</a></span>(2/2) <span class="lilac-caption-link-symbol"><a href="#__NREF__example-child-block-bar-2">&#x1f517;</a></span></div><pre class="src src-bash" id="__NREF__example-child-block-bar-2"><span class="org-builtin">echo</span> <span class="org-string">"child 2"</span>
</pre></div></div>
</div>

<div id="outline-container-h-Multi-parent-child-blocks" class="outline-5">
<h5 id="h-Multi-parent-child-blocks"><span class="section-number-5">3.1.1.1.</span> Multi-parent child blocks</h5>
<div class="outline-text-5" id="text-h-Multi-parent-child-blocks">
<p>
Sometimes a piece of code will be reused in different source code blocks. You
can think of it as constants in a programming language, but in LP the concept
extends to any arbitrary piece of text.
</p>

<p>
Below is an example where we define a child block once&#x2026;
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#example-parent-1">example-child-block-baz</a></span><span class="lilac-caption-parent-link"><a href="#example-parent-2">2</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__example-child-block-baz">&#x1f517;</a></span></div><pre class="src src-bash" id="__NREF__example-child-block-baz"><span class="org-builtin">echo</span> <span class="org-string">"Hello from child block baz"</span>
</pre></div></div><p>
&#x2026;but where we also reuse it (reference it) in different parent blocks.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">example-parent-1</label><span class="lilac-caption-link-symbol"><a href="#example-parent-1">&#x1f517;</a></span></div><pre class="src src-bash" id="example-parent-1"><span class="org-builtin">echo</span> <span class="org-string">"Hello from parent 1"</span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__example-child-block-baz">example-child-block-baz</a></span>
</pre></div></div><div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">example-parent-2</label><span class="lilac-caption-link-symbol"><a href="#example-parent-2">&#x1f517;</a></span></div><pre class="src src-bash" id="example-parent-2"><span class="org-builtin">echo</span> <span class="org-string">"Hello from parent 2"</span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__example-child-block-baz">example-child-block-baz</a></span>
</pre></div></div><p>
Notice that the child block has an additional link named "2", which points to
the second parent that references this block (the first parent is linked by the
child block name itself, as in the previous example). If it is referenced in
additional parent blocks, they will show up as links "3", "4", etc.
</p>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-h-How-Lilac-uses-LP" class="outline-2">
<h2 id="h-How-Lilac-uses-LP"><span class="section-number-2">4.</span> How Lilac uses LP</h2>
<div class="outline-text-2" id="text-h-How-Lilac-uses-LP">
<p>
All source code is generated by <i>tangling</i> this Org file (<code>README.org</code>). This
file is the single source of truth for basically everything. Some other things
like COPYRIGHT and LICENSE do not come from this file, but they are exceptions.
</p>

<p>
Tangling is done by loading this file into Emacs and then running
<code>(org-babel-tangle)</code>. This file is also the source of truth for the <i>woven</i>
HTML documentation (<code>README.html</code>), and similarly the HTML is generated by
invoking <code>(lilac-publish)</code>. The outputs of both tangling and weaving are checked
into version control.
</p>

<p>
The <code>Makefile</code> in this repo is used as the main "driver" for both tangling and
weaving.
</p>
</div>
</div>

<div id="outline-container-h-Weaving--generating-the-HTML" class="outline-2">
<h2 id="h-Weaving--generating-the-HTML"><span class="section-number-2">5.</span> Weaving (generating the HTML)</h2>
<div class="outline-text-2" id="text-h-Weaving--generating-the-HTML">
<p>
Weaving is conceptually simpler than tangling because there is no extra step &#x2014;
the output is an HTML page and that is something that we can use directly
(unlike program source code, which may require additional compilation into a
binary, depending on the language). We limit ourselves to HTML output because
HTML support is ubiquitous; plus we don't have to worry about page breaks such
as in PDF output.
</p>

<p>
Although weaving is conceptually simple, most of the code in <a href="lilac.el"><code>lilac.el</code></a> have to
do with weaving because the default infrastructure that ships with Org mode is
too rigid for our needs. For example, we make heavy use of Noweb-style
<a href="#citeproc_bib_item_1">[1]</a> references, but also add in extensive HTML links to allow
the reader to jump around code easily because Org does not cross-link these
references by default.
</p>

<p>
Weaving currently requires the following dependencies:
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Dependency</th>
<th scope="col" class="org-left">Why</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><a href="https://www.gnu.org/software/make/">GNU Make</a></td>
<td class="org-left">to run "make"</td>
</tr>

<tr>
<td class="org-left"><a href="https://www.gnu.org/software/emacs/">GNU Emacs</a></td>
<td class="org-left">for tangling and weaving</td>
</tr>
</tbody>
</table>

<p>
Note that all of the above can be brought in by using the <a href="https://github.com/NixOS/nix">Nix package manager</a>.
This is why we provide a <a href="shell.nix">shell.nix</a> file in this repo.
</p>
</div>

<div id="outline-container-h-Makefile" class="outline-3">
<h3 id="h-Makefile"><span class="section-number-3">5.1.</span> Makefile</h3>
<div class="outline-text-3" id="text-h-Makefile">
<p>
We have a top-level <code>Makefile</code> so that we can run some <code>make</code> commands on the
command line. The overall idea is to tangle and weave, while also running any
associated tests.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Makefile</label><span class="lilac-caption-link-symbol"><a href="#Makefile">&#x1f517;</a></span></div><pre class="src src-makefile" id="Makefile"><span class="org-makefile-targets">all</span>: test weave
<span class="org-makefile-targets">.PHONY</span>: all

<span class="org-makefile-targets">test</span>: tangle
        emacs --quick --batch --kill --load ert \
                --load lilac.el \
                --load lilac-tests.el \
                --funcall ert-run-tests-batch-and-exit
<span class="org-makefile-targets">.PHONY</span>: test

<span class="lilac-child-link-from-parent"><a href="#__NREF__Makefile-weave">Makefile-weave</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__Makefile-tangle">Makefile-tangle</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__Makefile-run_emacs">Makefile-run_emacs</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__Makefile-update-deps">Makefile-update-deps</a></span>
</pre></div></div><p>
Weaving just depends on the main <code>README.html</code> file being generated. Before we
call <code>(lilac-publish)</code>, we have to first call <code>(lilac-gen-css-and-exit
\"README.org\")</code> because otherwise the source code blocks do not get any syntax
highlighting. And lastly we have to modify the generated <code>README.html</code> file with
<code>sed</code> because we have to fix up some CSS classes that get inlined into the HTML.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Makefile">Makefile-weave</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__Makefile-weave">&#x1f517;</a></span></div><pre class="src src-makefile" id="__NREF__Makefile-weave"><span class="org-makefile-targets">weave</span>: README.html
<span class="org-makefile-targets">.PHONY</span>: weave

<span class="org-makefile-targets">README.html</span>: README.org
        $(<span class="org-variable-name">call</span> run_emacs,(lilac-gen-css-and-exit),README.org)
        $(<span class="org-variable-name">call</span> run_emacs,(lilac-publish),README.org)
<span class="org-makefile-space">        #</span><span class="org-comment-delimiter"> </span><span class="org-comment">Fix inline styles.</span>
        sed -i <span class="org-string">'s/&lt;style&gt;.csl-left-margin{float: left; padding-right: 0em/'</span>\
        <span class="org-string">'&lt;style&gt;.csl-left-margin{float: left; padding-right: 1em/'</span> README.html
        sed -i <span class="org-string">'s/.csl-right-inline{margin: 0 0 0 1em;}&lt;\/style&gt;/'</span>\
        <span class="org-string">'.csl-right-inline{margin: 0 0 0 2em;}&lt;\/style&gt;/'</span> README.html
</pre></div></div><p>
Tangling is pretty straightforward &#x2014; we just need to call
<code>(org-babel-tangle)</code> on <code>README.org</code>. This generates a number of files, such as
<code>Makefile</code> and <code>shell.nix</code>.
</p>

<p>
The key here is to enumerate these generated files, because we need to tell the
<code>make</code> utility that it should run the rule if <code>README.org</code> has a newer
modification timestamp than any of the generated files. Technically speaking,
because all of the tangled files are tangled together at once with
<code>(org-babel-tangle)</code>, we could just list one of them such as <code>Makefile</code> (instead
of enumerating all of them). However we still enumerate them all here for
completeness.
</p>

<p>
Lastly we make use of the fake file <code>tangle</code>, so that we can write the top-level
<code>test</code> rule as <code>test: tangle</code>, which reads more naturally than the equivalent
<code>test: Makefile</code> or <code>test: lilac.el</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Makefile">Makefile-tangle</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__Makefile-tangle">&#x1f517;</a></span></div><pre class="src src-makefile" id="__NREF__Makefile-tangle"><span class="org-comment-delimiter"># </span><span class="org-comment">tangled_output are all files that are generated by tangling README.org.</span>
<span class="org-variable-name">tangled_output</span> = \
        citations.bib \
        lilac.el \
        lilac.theme \
        .gitattributes \
        .gitignore \
        Makefile \
        misc.js \
        shell.nix \
        style.css \
        syntax-highlighting.css

<span class="org-makefile-targets">tangle $(</span><span class="org-variable-name"><span class="org-makefile-targets">tangled_output</span></span><span class="org-makefile-targets">) &amp;</span>: README.org
<span class="org-makefile-space">        #</span><span class="org-comment-delimiter"> </span><span class="org-comment">Generate the toplevel Makefile (this file) and others as described in</span>
<span class="org-makefile-space">        #</span><span class="org-comment-delimiter"> </span><span class="org-comment">tangled_output. In a way this bootstraps the whole literate-programming</span>
<span class="org-makefile-space">        #</span><span class="org-comment-delimiter"> </span><span class="org-comment">pipeline.</span>
        $(<span class="org-variable-name">call</span> run_emacs,(org-babel-tangle),README.org)
        touch tangle
</pre></div></div><p>
The <code>run_emacs</code> function is used for both weaving and tangling. The main thing
of interest here is that it loads the <code>lilac.el</code> (tangled) file before
evaluating the given expression.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Makefile">Makefile-run_emacs</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__Makefile-run_emacs">&#x1f517;</a></span></div><pre class="src src-makefile" id="__NREF__Makefile-run_emacs">define run_emacs
        emacs $(<span class="org-variable-name">2</span>) --quick --batch --kill --load $(<span class="org-variable-name">PROJ_ROOT</span>)/lilac.el --eval=<span class="org-string">"$(</span><span class="org-string"><span class="org-variable-name">1</span></span><span class="org-string">)"</span>
endef

<span class="org-variable-name">PROJ_ROOT</span> := $(<span class="org-variable-name">shell</span> git rev-parse --show-toplevel)
</pre></div></div><p>
We use <a href="https://github.com/nmattia/niv"><code>niv</code></a> to update the dependencies sourced by <code>shell.nix</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#Makefile">Makefile-update-deps</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__Makefile-update-deps">&#x1f517;</a></span></div><pre class="src src-makefile" id="__NREF__Makefile-update-deps"><span class="org-makefile-targets">update-deps</span>: package/nix/sources.json package/nix/sources.nix
        cd package &amp;&amp; niv update
        touch update-deps
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Emacs-customizations-for-HTML-export---lilac-el-" class="outline-3">
<h3 id="h-Emacs-customizations-for-HTML-export---lilac-el-"><span class="section-number-3">5.2.</span> Emacs customizations for HTML export (<code>lilac.el</code>)</h3>
<div class="outline-text-3" id="text-h-Emacs-customizations-for-HTML-export---lilac-el-">
<p>
Below is the overall structure of <code>lilac.el</code>. The <code>gc-cons-threshold</code> setting is
to prevent <code>emacs</code> from entering garbage collection pauses, because we invoke
<code>emacs</code> from the command line in a fire-and-forget manner.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">lilac.el</label><span class="lilac-caption-link-symbol"><a href="#lilac-el">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="lilac-el"><span class="org-comment-delimiter">; </span><span class="org-comment">Set garbage-collection threshold to 16 GiB.</span>
(<span class="org-keyword">setq</span> gc-cons-threshold #x400000000)
<span class="lilac-child-link-from-parent"><a href="#__NREF__lilac_dot_el-imports">lilac_dot_el-imports</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__lilac_dot_el-fix-nondeterminism-1">lilac_dot_el-fix-nondeterminism</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__lilac_dot_el-autogenerate-css">lilac_dot_el-autogenerate-css</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__lilac_dot_el-lilac-publish">lilac_dot_el-lilac-publish</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__lilac_dot_el-misc-1">lilac_dot_el-misc</a></span>
(<span class="org-keyword">provide</span> '<span class="org-constant">lilac</span>)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Fix-non-determinism" class="outline-3">
<h3 id="h-Fix-non-determinism"><span class="section-number-3">5.3.</span> Fix non-determinism</h3>
<div class="outline-text-3" id="text-h-Fix-non-determinism">
<p>
Nondeterminism is problematic because it results in a different HTML file
every time we run <code>org-babel-tangle</code>, <i>even if the Org files have not changed</i>.
Here we take care to set things right so that we can have reprducible, stable
HTML output.
</p>
</div>

<div id="outline-container-h-Do-not-insert-current-time-as-HTML-comment" class="outline-4">
<h4 id="h-Do-not-insert-current-time-as-HTML-comment"><span class="section-number-4">5.3.1.</span> Do not insert current time as HTML comment</h4>
<div class="outline-text-4" id="text-h-Do-not-insert-current-time-as-HTML-comment">
<p>
Org mode also injects an HTML comment (not visible to the user) to record the
time that the HTML was generated. We disable this because it breaks
deterministic output. See <a href="https://emacs.stackexchange.com/questions/50117/how-to-disable-commented-date-in-org-mode-html-export">this link</a> for more info.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-fix-nondeterminism</a></span>(1/3) <span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-fix-nondeterminism-1">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-fix-nondeterminism-1">(<span class="org-keyword">setq</span> org-export-time-stamp-file nil)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Do-not-insert-current-Org-mode-version" class="outline-4">
<h4 id="h-Do-not-insert-current-Org-mode-version"><span class="section-number-4">5.3.2.</span> Do not insert current Org mode version</h4>
<div class="outline-text-4" id="text-h-Do-not-insert-current-Org-mode-version">
<p>
By default Org mode appends visible metadata at the bottom of the HTML document,
including the Org version used to generate the document. We suppress this
information.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-fix-nondeterminism</a></span>(2/3) <span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-fix-nondeterminism-2">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-fix-nondeterminism-2">(<span class="org-keyword">setq</span> org-html-postamble nil)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Do-not-use-random-numbers-for-the-HTML---id---attribute" class="outline-4">
<h4 id="h-Do-not-use-random-numbers-for-the-HTML---id---attribute"><span class="section-number-4">5.3.3.</span> Do not use random numbers for the HTML "<code>id</code>" attribute</h4>
<div class="outline-text-4" id="text-h-Do-not-use-random-numbers-for-the-HTML---id---attribute">
<p>
Stop randomized IDs from being generated every time. Instead count from 0 and
work our way up.
</p>

<p>
See <a href="https://www.reddit.com/r/orgmode/comments/aagmfh/comment/hk6upbf">https://www.reddit.com/r/orgmode/comments/aagmfh/comment/hk6upbf</a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-fix-nondeterminism</a></span>(3/3) <span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-fix-nondeterminism-3">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-fix-nondeterminism-3">(<span class="org-keyword">defun</span> <span class="org-function-name">org-export-deterministic-reference</span> (references)
  (<span class="org-keyword">let</span> ((new (length references)))
     (<span class="org-keyword">while</span> (rassq new references) (<span class="org-keyword">setq</span> new (+ new 1)))
     new))
(advice-add #'org-export-new-reference
            <span class="org-builtin">:override</span> #'org-export-deterministic-reference)
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Toplevel-publishing-function---lilac-publish-" class="outline-3">
<h3 id="h-Toplevel-publishing-function---lilac-publish-"><span class="section-number-3">5.4.</span> Toplevel publishing function (<code>lilac-publish</code>)</h3>
<div class="outline-text-3" id="text-h-Toplevel-publishing-function---lilac-publish-">
<p>
The toplevel function is <code>lilac-publish</code>. This actually publishes twice, with
<code>lilac-publish-1</code> and <code>lilac-publish-2</code>. The reason we publish twice is because
we need to examine the HTML output twice in order to build up a database of
parent/child source code block links (which is then used to link between these
parent/child source code blocks).
</p>

<p>
Also note that we do some modifications to the Org buffer directly before
exporting to HTML. The main reason is so that the source code blocks that are
named <code>__NREF__...</code> get an automatic <code>#+caption: ...</code> text to go along with it
(because for these Noweb-style blocks, the captions should always look uniform).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-lilac-publish</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-lilac-publish">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-lilac-publish">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-publish</span> ()
  (<span class="org-keyword">interactive</span>)
  (lilac-publish-1)
  (clrhash lilac-polyblock-names-totals)
  (lilac-publish-2))

<span class="org-comment-delimiter">;; </span><span class="org-comment">This is here solely to populate the lilac-child-HTML_ID-hash-table.</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-publish-1</span> ()
  (<span class="org-keyword">let</span> (
        <span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-publish-modify-org">lilac-publish-modify-org</a></span>
        <span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-publish-modify-HTML-1">lilac-publish-modify-HTML-1</a></span>
        <span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-publish-use-css">lilac-publish-use-css</a></span>)
    (org-html-export-to-html)))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-publish-2</span> ()
  (<span class="org-keyword">let</span> (
        <span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-publish-modify-org">lilac-publish-modify-org</a></span>
        <span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-publish-modify-HTML-2">lilac-publish-modify-HTML-2</a></span>
        <span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-publish-use-css">lilac-publish-use-css</a></span>)
    (org-html-export-to-html)))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Modify Org buffer</span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__UID-for-all-headlines">UID-for-all-headlines</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__UID-for-all-src-blocks">UID-for-all-src-blocks</a></span>

<span class="org-comment-delimiter">;; </span><span class="org-comment">Modify HTML</span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-html-filter-src-blocks">lilac-html-filter-src-blocks</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-prettify-source-code-captions">lilac-prettify-source-code-captions</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-human-readable-src-block-ids">lilac-human-readable-src-block-ids</a></span>
</pre></div></div>
</div>

<div id="outline-container-h-Modify-the-Org-buffer" class="outline-4">
<h4 id="h-Modify-the-Org-buffer"><span class="section-number-4">5.4.1.</span> Modify the Org buffer</h4>
<div class="outline-text-4" id="text-h-Modify-the-Org-buffer">
<p>
Here we modify the Org mode buffer, by using <code>org-export-before-parsing-hook</code>.
This takes a list of functions that are free to modify the Org mode buffer
before each Org element in the buffer gets converted into HTML.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">lilac-publish-modify-org</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac-publish-modify-org">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac-publish-modify-org">(org-export-before-parsing-hook
 '(lilac-UID-for-all-src-blocks
   lilac-insert-noweb-source-code-block-captions
   lilac-UID-for-all-headlines))
</pre></div></div><p>
As for the actual modifications, see:
</p>

<ul class="org-ul">
<li><code>lilac-UID-for-all-src-blocks</code> (<a href="#h-Give-all-source-code-blocks-a----name-------field--HTML-ID">5.5.1</a>)</li>
<li><code>lilac-insert-noweb-source-code-block-captions</code> (<a href="#h-Automatic-captions-for-Noweb-source-code-blocks">5.5.2</a>)</li>
<li><code>lilac-UID-for-all-headlines</code> (<a href="#h-Human-readable-UIDs--Headings--aka-headlines">5.5.3</a>)</li>
</ul>

<p>
In brief, the <code>lilac-UID-for-all-*</code> functions make it so that the links to
headlines and source code blocks are both deterministic and human-readable. The
<code>lilac-insert-noweb-source-code-block-captions</code> function
</p>
</div>
</div>

<div id="outline-container-h-Modify-the-HTML" class="outline-4">
<h4 id="h-Modify-the-HTML"><span class="section-number-4">5.4.2.</span> Modify the HTML</h4>
<div class="outline-text-4" id="text-h-Modify-the-HTML">
<p>
This is useful for adding in final tweaks to the HTML that is difficult to
accomplish at the Org-mode buffer level.
</p>

<p>
Phase 1: In the first phase, we use the generated HTML data to populate the
<code>child-HTML_ID-hash-table</code>. This data structure is used to link to child blocks
from parent blocks.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">lilac-publish-modify-HTML-1</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac-publish-modify-HTML-1">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac-publish-modify-HTML-1">(org-export-filter-src-block-functions
 '(lilac-populate-child-HTML_ID-hash-table
   lilac-populate-org_id-human_id-hash-table))
</pre></div></div><p>
Phase 2: In this phase we perform the linking from parent blocks to child
blocks.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">lilac-publish-modify-HTML-2</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac-publish-modify-HTML-2">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac-publish-modify-HTML-2">(org-export-filter-src-block-functions
 '(lilac-link-to-children-from-parent-body
   lilac-prettify-source-code-captions))
(org-export-filter-final-output-functions
 '(lilac-replace-org_ids-with-human_ids))
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Miscellaneous-export-settings" class="outline-4">
<h4 id="h-Miscellaneous-export-settings"><span class="section-number-4">5.4.3.</span> Miscellaneous export settings</h4>
<div class="outline-text-4" id="text-h-Miscellaneous-export-settings">
<p>
Do not hardcode colors into the HTML. Instead refer to CSS class names, to be
stylized by an external CSS file.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">lilac-publish-use-css</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac-publish-use-css">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac-publish-use-css">(org-html-htmlize-output-type 'css)
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Org-modifications" class="outline-3">
<h3 id="h-Org-modifications"><span class="section-number-3">5.5.</span> Org modifications</h3>
<div class="outline-text-3" id="text-h-Org-modifications">
</div>

<div id="outline-container-h-Give-all-source-code-blocks-a----name-------field--HTML-ID" class="outline-4">
<h4 id="h-Give-all-source-code-blocks-a----name-------field--HTML-ID"><span class="section-number-4">5.5.1.</span> Give all source code blocks a <code>#+name: ...</code> field (HTML ID)</h4>
<div class="outline-text-4" id="text-h-Give-all-source-code-blocks-a----name-------field--HTML-ID">
<p>
Only source code blocks that have a <code>#+name: ...</code> field (org name field) get an
HTML ID (org ID) assigned to it. The problem with polyblocks is that they are
not assigned an org name field by default.
</p>

<p>
Of course, we still want all polyblock to have an HTML ID, which can then be
extracted by <a href="#coderef-lilac-get-src-block-HTML_ID" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-lilac-get-src-block-HTML_ID');" onmouseout="CodeHighlightOff(this, 'coderef-lilac-get-src-block-HTML_ID');"><code>lilac-get-src-block-HTML_ID</code></a> to build up the
<code>child-HTML_ID-hash-table</code> in <a href="#h-Link-noweb-references--link-to-child-block-from-parent-block">5.6.3</a>. If we don't do this then parent source code blocks won't be
able to link to the polyblock at all (or vice versa).
</p>

<p>
Monoblocks with a <code>#+name: ...</code> field get a unique HTML ID assigned to it in
the form <code>orgN</code> where <code>N</code> is a hexadecimal number. By default Org generates a
random number for <code>N</code>, but we use a simple counter that increments, starting
from 0 (see <a href="#h-Do-not-use-random-numbers-for-the-HTML---id---attribute">5.3.3</a>).
</p>

<p>
Some source code blocks may not even be monoblocks, because a <code>#+name: ...</code>
field may simply be missing.
</p>

<p>
What we can do is inject a <code>#+name: ___anonymous-src-block-N</code> line (where <code>N</code> is
an incrementing number) into the beginning of the source code section of all
source code blocks that need it. Then we can construct an HTML link to any
source code block.
</p>

<p>
Note that the actual name <code>__anonymous-src-block-N</code> is not important, because it
gets erased and replaced with an <code>orgN</code> ID during HTML export. At that point we
make these <code>orgN</code> strings human-readable in <a href="#h-Use-human-readable-HTML-IDs-for-source-code-links">5.6.1</a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">UID-for-all-src-blocks</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__UID-for-all-src-blocks">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__UID-for-all-src-blocks">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-UID-for-all-src-blocks</span> (_backend)
  (<span class="org-keyword">let*</span> ((all-src-blocks
           <span class="lilac-child-link-from-parent"><a href="#__NREF__all-src-blocks">all-src-blocks</a></span>)
         (counter 0)
         (auto-names
           (-remove 'null
             (<span class="org-keyword">cl-loop</span> for src-block in all-src-blocks collect
               (<span class="org-keyword">let*</span> ((pos (org-element-property <span class="org-builtin">:begin</span> src-block))
                      (parent-name-struct (lilac-get-src-block-name src-block))
                      (direct-name (org-element-property <span class="org-builtin">:name</span> src-block))
                      (no-direct-name (s-blank? direct-name))
                      (prefix
                        (<span class="org-keyword">cond</span> ((s-blank? (car parent-name-struct))
                               <span class="org-string">"___anonymous-src-block"</span>)
                              (t
                               (car parent-name-struct))))
                      (name-final
                       (format <span class="org-string">"#+name: %s-%x\n"</span> prefix counter)))
                 (<span class="org-keyword">setq</span> counter (1+ counter))
                 (<span class="org-keyword">when</span> no-direct-name
                   (cons pos name-final)))))))
    (lilac-insert-strings-into-buffer auto-names)))
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Automatic-captions-for-Noweb-source-code-blocks" class="outline-4">
<h4 id="h-Automatic-captions-for-Noweb-source-code-blocks"><span class="section-number-4">5.5.2.</span> Automatic captions for Noweb source code blocks</h4>
<div class="outline-text-4" id="text-h-Automatic-captions-for-Noweb-source-code-blocks">
<p>
For the parent/child source code blocks, we simply build these up by having
blocks named <code>#+name: __NREF__foo</code> or <code>#+header: :noweb-ref __NREF__foo</code>. Each
of these blocks can also reference other blocks by having a line <code>__NREF__bar</code>
inside its body. When defining such blocks, we really don't want to define the
<code>#+caption: ...</code> part manually because it gets tedious rather quickly. Yet we
still have to have these <code>#+caption: ...</code> bits (<i>for every <code>__NREF__...</code>
block!</i>) because that's the only way that Org's HTML exporter knows how to label
these blocks.
</p>

<p>
The code in this section automatically generates <code>#+caption: ...</code> text for these
<code>__NREF__...</code> blocks.
</p>

<p>
We want each <code>#+caption: ...</code> text to have the following items:
</p>

<dl class="org-dl">
<dt><a href="#coderef-NSCB_NAME" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-NSCB_NAME');" onmouseout="CodeHighlightOff(this, 'coderef-NSCB_NAME');"><code>NSCB_NAME</code></a></dt><dd>name of the Noweb source code block,</dd>
<dt><a href="#coderef-NSCB_POLYBLOCK_INDICATOR" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-NSCB_POLYBLOCK_INDICATOR');" onmouseout="CodeHighlightOff(this, 'coderef-NSCB_POLYBLOCK_INDICATOR');"><code>NSCB_POLYBLOCK_INDICATOR</code></a></dt><dd>an indicator to show whether this block is
broken up over multiple blocks, and</dd>
<dt><a href="#coderef-NSCB_LINKS_TO_PARENTS" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-NSCB_LINKS_TO_PARENTS');" onmouseout="CodeHighlightOff(this, 'coderef-NSCB_LINKS_TO_PARENTS');"><code>NSCB_LINKS_TO_PARENTS</code></a></dt><dd>a link back up to a parent block (if any) where
this block is used; can contain more than 1 parent if multiple parents refer
to this same child block</dd>
</dl>

<p>
<i>NSCB</i> here means <i>Noweb source code block</i>. We loop through every source code
block and insert a <code>#+caption: ...</code> text into the buffer. This modified buffer
(with the three bits of information from above) is what is sent down the
pipeline for final export to HTML (i.e., the buffer modification does not affect
the actual buffer (<code>*.org</code> file)).
</p>

<p>
So assume that we already have the smart captions in a sorted <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html">association list</a>
(aka alist), where the KEY is the integer buffer position where this caption
should be inserted, and the VALUE is the caption itself (a string), like this:
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Caption locations</label><span class="lilac-caption-link-symbol"><a href="#Caption-locations">&#x1f517;</a></span></div><pre class="src src-elisp" id="Caption-locations">'((153  . <span class="org-string">"#+caption: ..."</span>)
  (384  . <span class="org-string">"#+caption: ..."</span>)
  (555  . <span class="org-string">"#+caption: ..."</span>)
  (684  . <span class="org-string">"#+caption: ..."</span>)
  (1051 . <span class="org-string">"#+caption: ..."</span>))
</pre></div></div><p>
We can use the KEY to go to that buffer position and insert the caption. However
the insertion operation mutates the buffer. This means if we perform the
insertions top-to-bottom, the subsequent KEY values will become obsolete. The
trick then is to just do the insertions in reverse order (bottom-to-top), so
that the remaining KEY values remain valid. This is what we do below, where
<code>smart-captions</code> is an alist like the one just described.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">smart-source-code-block-captions</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-insert-noweb-source-code-block-captions</span> (_backend)
  (<span class="org-keyword">let*</span> ((parent-blocks
           <span class="lilac-child-link-from-parent"><a href="#__NREF__parent-blocks">parent-blocks</a></span>)
         (child-parents-hash-table
           <span class="lilac-child-link-from-parent"><a href="#__NREF__child-parents-hash-table">child-parents-hash-table</a></span>)
         (all-src-blocks
           <span class="lilac-child-link-from-parent"><a href="#__NREF__all-src-blocks">all-src-blocks</a></span>)
         (smart-captions
           <span class="lilac-child-link-from-parent"><a href="#__NREF__smart-captions">smart-captions</a></span>))
    (lilac-insert-strings-into-buffer smart-captions)))

<span class="lilac-child-link-from-parent"><a href="#__NREF__smart-source-code-block-captions-helpers-1">smart-source-code-block-captions-helpers</a></span>
</pre></div></div><p>
(We'll get to the helper functions <code>smart-source-code-block-captions-helpers</code>
later as they obscure the big picture.)
</p>

<p>
Now we just have to construct <code>smart-captions</code>. The main difficulty is the
construction of <a href="#coderef-NSCB_LINKS_TO_PARENTS" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-NSCB_LINKS_TO_PARENTS');" onmouseout="CodeHighlightOff(this, 'coderef-NSCB_LINKS_TO_PARENTS');"><code>NSCB_LINKS_TO_PARENTS</code></a>, so most of the code will be concerned
about child-parent associations.
</p>

<p>
Why do we even need these source code blocks to link back to their parents? The
point is to make things easier to navigate. For example, if we have
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Sample Org-mode Noweb-style references</label><span class="lilac-caption-link-symbol"><a href="#Sample-Org-mode-Noweb-style-references-2">&#x1f517;</a></span></div><pre class="src src-org" id="Sample-Org-mode-Noweb-style-references-2"><span class="org-org-meta-line">#+name: parent-block</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"Hello from the parent block"</span></span>
<span class="org-org-block">__NREF__child-block-1</span>
<span class="org-org-block">__NREF__child-block-2</span>
<span class="org-org-block-end-line">#+end_src</span>

...

<span class="org-org-meta-line">#+name: __NREF__child-block-1</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"I am child 1"</span></span>
<span class="org-org-block-end-line">#+end_src</span>

...

<span class="org-org-meta-line">#+header: :noweb-ref __NREF__child-block-2</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> -n </span><span class="org-org-block"><span class="org-string">"I am "</span></span>
<span class="org-org-block-end-line">#+end_src</span>

<span class="org-org-meta-line">#+header: :noweb-ref __NREF__child-block-2</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"child 2"</span></span>
<span class="org-org-block-end-line">#+end_src</span>
</pre></div></div><p>
and we export this to HTML, ideally we would want both <code>__NREF__child-block-1</code>
and each of the <code>__NREF__child-block-2</code> blocks to include an HTML link back up
to <code>parent-block</code>. This would make it easier to skim the document and not get
too lost (any time you are looking at any particular source code block, you
would be able to just click on the link back to the parent (if there is one) to
see a higher-level view).
</p>

<p>
The key idea here is to build a hash table (<code>child-parents-hash-table</code>) where
the KEY is a child source code block and the VALUE is the parent block(s). Then
in order to construct <a href="#coderef-NSCB_LINKS_TO_PARENTS" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-NSCB_LINKS_TO_PARENTS');" onmouseout="CodeHighlightOff(this, 'coderef-NSCB_LINKS_TO_PARENTS');"><code>NSCB_LINKS_TO_PARENTS</code></a> we just do a lookup against this
hash table to find the parent(s), if any.
</p>

<p>
The first thing we need is a list of parent source code blocks. We consider a
source code block a parent block if it has any Noweb references within its body.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">parent-blocks</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__parent-blocks">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__parent-blocks">(lilac-get-parent-blocks)
</pre></div></div><p>
Then we construct the <code>child-parents-hash-table</code>. For each parent block, we get
all of its children (<code>child-names</code>), and use this data to construct a
child-parent association. Note that we use <code>cl-pushnew</code> instead of <code>push</code> to
deduplicate parents (i.e., when a single parent refers to the same child more
than once we do not want to link back to this same parent more than once from
the child block's caption).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">child-parents-hash-table</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__child-parents-hash-table">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__child-parents-hash-table">(lilac-mk-child-parents-hash-table parent-blocks)
</pre></div></div><p>
Now that we have the child-parent associations, we have to look at all source
code blocks and check if
</p>

<ol class="org-ol">
<li>this source code block's name shows up at all in <code>child-parents-hash-table</code>,
and if so</li>
<li>add a link to the parent (<a href="#coderef-NSCB_LINKS_TO_PARENTS" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-NSCB_LINKS_TO_PARENTS');" onmouseout="CodeHighlightOff(this, 'coderef-NSCB_LINKS_TO_PARENTS');"><code>NSCB_LINKS_TO_PARENTS</code></a>).</li>
</ol>

<p>
Let's grab all source code blocks:
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__UID-for-all-src-blocks">all-src-blocks</a></span><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">2</a></span><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions-helpers-4">3</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__all-src-blocks">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__all-src-blocks">(org-element-map (org-element-parse-buffer) 'src-block 'identity)
</pre></div></div><p>
And now we can finally construct <code>smart-captions</code>:
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-captions</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__smart-captions">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-captions">(lilac-mk-smart-captions child-parents-hash-table)
</pre></div></div><p>
We used some helper functions up in <a href="#__NREF__smart-source-code-block-captions"><code>__NREF__smart-source-code-block-captions</code></a>;
let's examine them now.
</p>

<p>
<code>lilac-is-parent-block</code> checks whether a source code block is a parent (contains
noweb references to other child blocks in the form <code>__NREF__child-name</code>).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions-helpers</a></span>(1/9) <span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions-helpers-1">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions-helpers-1">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-is-parent-block</span> (src-block)
  (<span class="org-keyword">let</span> ((body (org-element-property <span class="org-builtin">:value</span> src-block)))
    (lilac-get-noweb-children body)))
</pre></div></div><p>
<code>lilac-get-parent-blocks</code> retrieves all source code blocks that are parents
(which have <code>__NREF__...</code> references).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions-helpers</a></span>(2/9) <span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions-helpers-2">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions-helpers-2">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-get-parent-blocks</span> ()
  (org-element-map (org-element-parse-buffer) 'src-block
    (<span class="org-keyword">lambda</span> (src-block)
       (<span class="org-keyword">if</span> (lilac-is-parent-block src-block) src-block))))
</pre></div></div><p>
<code>lilac-mk-child-parents-hash-table</code> takes all parent source code blocks and
generates a hash table where the KEY is the child block name and the VALUE is
the list of parents that refer to the child. When we loop through
<code>parent-blocks</code> below, we have to first <code>reverse</code> it because the function
<code>cl-pushnew</code> grows the list by prepending to it.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions-helpers</a></span>(3/9) <span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions-helpers-3">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions-helpers-3">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-mk-child-parents-hash-table</span> (parent-blocks)
  (<span class="org-keyword">let</span> ((hash-table (make-hash-table <span class="org-builtin">:test</span> 'equal)))
    (mapc
     (<span class="org-keyword">lambda</span> (parent-block)
      (<span class="org-keyword">let*</span> ((parent-name (org-element-property <span class="org-builtin">:name</span> parent-block))
             (parent-body (org-element-property <span class="org-builtin">:value</span> parent-block))
             (child-names (lilac-get-noweb-children parent-body)))
        (mapc (<span class="org-keyword">lambda</span> (child-name)
                (<span class="org-keyword">let*</span> ((parents (gethash child-name hash-table)))
                  (<span class="org-keyword">if</span> parents
                    (puthash child-name (<span class="org-keyword">cl-pushnew</span> parent-name parents) hash-table)
                    (puthash child-name (list parent-name) hash-table))))
              child-names)))
     (reverse parent-blocks))
    hash-table))
</pre></div></div><p>
<code>lilac-mk-smart-captions</code> generates an alist of buffer positions (positive
integer) and the literal <code>#+caption: ...</code> text that needs to be inserted back
into the buffer.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions-helpers</a></span>(4/9) <span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions-helpers-4">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions-helpers-4">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-mk-smart-captions</span> (child-parents-hash-table)
  (-remove 'null
    (<span class="org-keyword">cl-loop</span> for src-block in <span class="lilac-child-link-from-parent"><a href="#__NREF__all-src-blocks">all-src-blocks</a></span> collect
      (<span class="org-keyword">let*</span> ((child (lilac-get-src-block-name src-block))
             (child-name (car child))
<span id="coderef-NSCB_NAME" class="coderef-off">             (NSCB_NAME (format <span class="org-string">"=%s= "</span> child-name))</span>
<span id="coderef-NSCB_POLYBLOCK_INDICATOR" class="coderef-off">             (NSCB_POLYBLOCK_INDICATOR</span>
               (<span class="org-keyword">if</span> (lilac-get-noweb-ref-polyblock-name src-block)
                   <span class="org-string">"(polyblock)"</span>
                 <span class="org-string">""</span>))
             (polyblock-counter (gethash child-name lilac-polyblock-names-totals 0))
             (polyblock-counter-incremented
              (puthash child-name (+ 1 polyblock-counter)
                       lilac-polyblock-names-totals))
             (parents (gethash child-name child-parents-hash-table))
             (parents-zipped (lilac-enumerate parents))
             (pos (org-element-property <span class="org-builtin">:begin</span> src-block))
<span id="coderef-NSCB_LINKS_TO_PARENTS" class="coderef-off">             (NSCB_LINKS_TO_PARENTS</span>
              (mapconcat (<span class="org-keyword">lambda</span> (parent-with-idx)
                           (format <span class="org-string">" [[%s][%d]]"</span>
                                   (nth 1 parent-with-idx)
                                   (+ 1 (nth 0 parent-with-idx))))
                         parents-zipped <span class="org-string">" "</span>))
             (smart-caption
              (concat
                <span class="org-string">"#+caption: "</span>
                NSCB_NAME
                NSCB_POLYBLOCK_INDICATOR
                NSCB_LINKS_TO_PARENTS
                <span class="org-string">"\n"</span>)))
        (<span class="org-keyword">when</span> parents (cons pos smart-caption))))))
</pre></div></div><p>
<code>lilac-insert-strings-into-buffer</code> takes an alist of buffer positions and
strings and inserts them all into the buffer.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions-helpers</a></span>(5/9) <span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions-helpers-5">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions-helpers-5">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-insert-strings-into-buffer</span> (pos-strings)
  (<span class="org-keyword">cl-loop</span> for pos-string in (reverse pos-strings) do
        (<span class="org-keyword">let</span> ((pos (car pos-string))
              (str (cdr pos-string)))
          (goto-char pos)
          (insert str))))
</pre></div></div><p>
<code>lilac-get-noweb-children</code> extracts all Noweb references in the form
"<code>__NREF__foo</code>" from a given multiline string, returning a list of all such
references. This function expects at most 1 Noweb reference per line. The return
type is a list of strings.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions-helpers</a></span>(6/9) <span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions-helpers-6">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions-helpers-6">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-get-noweb-children</span> (s)
  (<span class="org-keyword">let*</span> ((lines (split-string s <span class="org-string">"\n"</span>))
         (refs (-remove 'null
                 (mapcar
                  (<span class="org-keyword">lambda</span> (line)
                   (<span class="org-keyword">if</span> (string-match (lilac-nref-rx nil) line)
                       (match-string-no-properties 1 line)))
                  lines))))
    refs))
</pre></div></div><p>
<code>lilac-get-noweb-ref-polyblock-name</code> gets the string <code>__NREF__foo</code> in a
<code>#+header: :noweb-ref __NREF__foo</code> line for a source code block.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions-helpers</a></span>(7/9) <span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions-helpers-7">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions-helpers-7">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-get-noweb-ref-polyblock-name</span> (source-code-block)
  (<span class="org-keyword">let*</span> ((headers (org-element-property <span class="org-builtin">:header</span> source-code-block))
         (noweb-ref-name
          (nth 0
           (-remove 'null
            (mapcar
             (<span class="org-keyword">lambda</span> (header)
               (<span class="org-keyword">if</span> (string-match <span class="org-string">":noweb-ref </span><span class="org-string"><span class="org-regexp-grouping-backslash">\\</span></span><span class="org-string"><span class="org-regexp-grouping-construct">(</span></span><span class="org-string">.+</span><span class="org-string"><span class="org-regexp-grouping-backslash">\\</span></span><span class="org-string"><span class="org-regexp-grouping-construct">)</span></span><span class="org-string">"</span> header)
                   (match-string-no-properties 1 header)))
             headers)))))
    noweb-ref-name))
</pre></div></div><p>
Note that a child source block can have two ways of defining its name. The first
is with the direct <code>#+name: __NREF__foo</code> style (<a href="#org0000004">monoblock</a>), and the second way
is with a line like <code>#+header: :noweb-ref __NREF__foo</code> (<a href="#org0000006">polyblock</a>). Here
<code>lilac-get-src-block-name</code> grabs the name of a (child) source code block, taking
into account these two styles. For polyblock names, we mark it as such with a
<code>(polyblock)</code> string, which is used later for the <a href="#coderef-NSCB_POLYBLOCK_INDICATOR" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-NSCB_POLYBLOCK_INDICATOR');" onmouseout="CodeHighlightOff(this, 'coderef-NSCB_POLYBLOCK_INDICATOR');"><code>NSCB_POLYBLOCK_INDICATOR</code></a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions-helpers</a></span>(8/9) <span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions-helpers-8">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions-helpers-8">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-get-src-block-name</span> (src-block)
  (<span class="org-keyword">let*</span> ((name-direct (org-element-property <span class="org-builtin">:name</span> src-block))
         (name-indirect (lilac-get-noweb-ref-polyblock-name src-block)))
    (<span class="org-keyword">if</span> name-indirect
        `(,name-indirect <span class="org-string">"(polyblock)"</span>)
        `(,name-direct <span class="org-string">""</span>))))
</pre></div></div><p>
Next we have some helpers to enumerate through a list just like in Python. The
index starts at 0 (same as Python).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__smart-source-code-block-captions">smart-source-code-block-captions-helpers</a></span>(9/9) <span class="lilac-caption-link-symbol"><a href="#__NREF__smart-source-code-block-captions-helpers-9">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__smart-source-code-block-captions-helpers-9">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-enumerate</span> (lst <span class="org-type">&amp;optional</span> start)
  (<span class="org-keyword">let</span> ((ret ()))
    (<span class="org-keyword">cl-loop</span> for index from (<span class="org-keyword">if</span> start start 0)
           for item in lst
           do (<span class="org-keyword">push</span> (list index item) ret))
    (reverse ret)))

<span class="org-comment-delimiter">; </span><span class="org-comment">See https://emacs.stackexchange.com/a/7150.</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-matches</span> (regexp s <span class="org-type">&amp;optional</span> group)
  <span class="org-doc">"Get a list of all regexp matches in a string"</span>
  (<span class="org-keyword">if</span> (= (length s) 0)
      ()
      (<span class="org-keyword">save-match-data</span>
        (<span class="org-keyword">let</span> ((pos 0)
              (matches ()))
          (<span class="org-keyword">while</span> (string-match regexp s pos)
            (<span class="org-keyword">push</span> (match-string (<span class="org-keyword">if</span> group group 0) s) matches)
            (<span class="org-keyword">setq</span> pos (match-end 0)))
          (reverse matches)))))
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Human-readable-UIDs--Headings--aka-headlines" class="outline-4">
<h4 id="h-Human-readable-UIDs--Headings--aka-headlines"><span class="section-number-4">5.5.3.</span> Human-readable UIDs (Headings, aka headlines)</h4>
<div class="outline-text-4" id="text-h-Human-readable-UIDs--Headings--aka-headlines">
<p>
By default Org does a terrible job of naming HTML <code>id</code> fields for headings. By
default it uses a randomly-generated number. In <a href="#h-Do-not-use-random-numbers-for-the-HTML---id---attribute">5.3.3</a> we tweak this behavior to use a deterministic,
incrementing number starting from 0. However while this solution gets rid of the
nondeterminism, it still results in human-unfriendly <code>id</code> attributes because
they are all numeric (e.g. <code>org00000a1</code>, <code>org00000f3</code>, etc).
</p>

<p>
For headings, we can do better because in practice they already mostly have
unique contents, which should work most of the time to act as an <code>id</code>. In other
words, we want all headings to have HTML IDs that are patterned after their
contents. This way we can have IDs like <code>some-heading-name-1</code> (where the
trailing <code>-1</code> is only used to disambiguate against another heading of the same
name) instead of <code>org00000a1</code> (numeric hex).
</p>

<p>
For each heading, we insert a <code>CUSTOM_ID</code> property. This makes Org refer to this
<code>CUSTOM_ID</code> instead of the numeric <code>org...</code> link names. We append this headline
property just below every headline we find in the buffer. The actual
construction of the <code>CUSTOM_ID</code> (<code>headline-UID</code> in the code below) is done by
<code>lilac-get-unique-id</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">UID-for-all-headlines</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__UID-for-all-headlines">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__UID-for-all-headlines">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-UID-for-all-headlines</span> (_backend)
  (<span class="org-keyword">let*</span> ((all-headlines
           (org-element-map (org-element-parse-buffer) 'headline 'identity))

         (headline-uid-hash-table (make-hash-table <span class="org-builtin">:test</span> 'equal))
         (headline-UIDs
           (-remove 'null
             (<span class="org-keyword">cl-loop</span> for headline in all-headlines collect
               (<span class="org-keyword">let*</span> ((headline-UID
                       (lilac-get-unique-id headline headline-uid-hash-table))
                      <span class="org-comment-delimiter">;; </span><span class="org-comment">Get the position just a</span>
                      <span class="org-comment-delimiter">;; </span><span class="org-comment">fter the headline (just underneath it).</span>
                      (pos (<span class="org-keyword">progn</span>
                             (goto-char (org-element-property <span class="org-builtin">:begin</span> headline))
                             (re-search-forward <span class="org-string">"\n"</span>))))
                 (cons pos (concat
                            <span class="org-string">":PROPERTIES:\n"</span>
                            <span class="org-string">":CUSTOM_ID: "</span> headline-UID <span class="org-string">"\n"</span>
                            <span class="org-string">":END:\n"</span>)))))))
    (lilac-insert-strings-into-buffer headline-UIDs)))

<span class="lilac-child-link-from-parent"><a href="#__NREF__get-unique-id">get-unique-id</a></span>
</pre></div></div><p>
<code>lilac-get-unique-id</code> converts a given headline to its canonical form (every
non-word character converted to a dash) and performs a lookup against the hash
table. If the entry exists, it looks up a <code>entry-N</code> value in a loop with <code>N</code>
increasing until it sees that no such key exists (at which point we know that we
have a unique ID).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__UID-for-all-headlines">get-unique-id</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__get-unique-id">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__get-unique-id">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-get-unique-id</span> (headline hash-table)
  (<span class="org-keyword">let*</span> ((name (org-element-property <span class="org-builtin">:raw-value</span> headline))
         (disambiguation-number 0)
         (key (concat <span class="org-string">"h-"</span> (lilac-normalize-string name)))
         (val (gethash key hash-table)))
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Discard the key if a value already exists. This drives up the</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">disambiguation number.</span>
    (<span class="org-keyword">while</span> val
      (<span class="org-keyword">setq</span> disambiguation-number (+ 1 disambiguation-number))
      (<span class="org-keyword">setq</span> key (concat <span class="org-string">"h-"</span>
                        (lilac-normalize-string
                         (format <span class="org-string">"%s-%s"</span> name disambiguation-number))))
      (<span class="org-keyword">setq</span> val (gethash key hash-table)))
    (puthash key t hash-table)
    key))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-normalize-string</span> (s)
  (string-trim
    (replace-regexp-in-string <span class="org-string">"[</span><span class="org-string"><span class="org-negation-char">^</span></span><span class="org-string">A-Za-z0-9]"</span> <span class="org-string">"-"</span> s)
    <span class="org-string">"-"</span>
    <span class="org-string">"-"</span>))
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-HTML-modifications" class="outline-3">
<h3 id="h-HTML-modifications"><span class="section-number-3">5.6.</span> HTML modifications</h3>
<div class="outline-text-3" id="text-h-HTML-modifications">
</div>

<div id="outline-container-h-Use-human-readable-HTML-IDs-for-source-code-links" class="outline-4">
<h4 id="h-Use-human-readable-HTML-IDs-for-source-code-links"><span class="section-number-4">5.6.1.</span> Use human-readable HTML IDs for source code links</h4>
<div class="outline-text-4" id="text-h-Use-human-readable-HTML-IDs-for-source-code-links">
<p>
Recall that there are 2 types of source code blocks: <a href="#org0000004">monoblocks</a> and <a href="#org0000006">polyblocks</a>.
</p>

<p>
Polyblocks do get a name field attached to them during the <a href="#h-Give-all-source-code-blocks-a----name-------field--HTML-ID">Org
modification stage</a>, in the format <code>___anonymous-src-block-N</code>. These names are
for HTML link generation only, because the user won't see them &#x2014; they will
instead just see <code>org000012</code> or some such. In fact, all monoblocks are also
given these random-looking (and unstable) <code>org...</code> HTML IDs.
</p>

<p>
And therein lies the problem: if a user decides to bookmark a particular source
code block, whether a monoblock or polyblock, they will link to an
<code>org...</code>-style ID and chances are that this link will break over time.
</p>

<p>
This is exactly the same problem we have for headlines. For headlines we solved
the problem with a <a href="#h-Human-readable-UIDs--Headings--aka-headlines">hash table</a>, and we need to do the same thing here. The major
difference, though, is that unlike headlines which can accept a <code>CUSTOM_ID</code> Org
property, source code blocks have no such facility. So instead of modifying the
buffer (as we do for headlines), we have to modify the final HTML output
instead.
</p>

<p>
The solution is to simply look at all source code block links, then modify the
<code>id=...</code> part so that it looks like a more human-readable ID. We can extract the
human-readable ID by looking at the smart captions inside the
<code>&lt;label&gt;...&lt;/label&gt;</code> area for both monoblocks and polyblocks. And then it's just
a matter of doing a basic search-and-replace across the entire buffer (HTML
file).
</p>

<p>
We have to do a search-and-replace across the entire file because we may also
have manual links to source code blocks (although &#x2014; maybe it's just not worth
it because we can't refer to polyblocks anyway by name).
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">lilac-human-readable-src-block-ids</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac-human-readable-src-block-ids">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac-human-readable-src-block-ids"><span class="org-comment-delimiter">; </span><span class="org-comment">Define a global hash table for mapping Org-mode-generated ids (that look like</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">"org00012") for source code blocks to a more human-readable ID.</span>
(<span class="org-keyword">setq</span> lilac-org_id-human_id-hash-table (make-hash-table <span class="org-builtin">:test</span> 'equal))
(<span class="org-keyword">setq</span> lilac-human_id-count-hash-table (make-hash-table <span class="org-builtin">:test</span> 'equal))
(<span class="org-keyword">setq</span> lilac-human_id-org_id-hash-table (make-hash-table <span class="org-builtin">:test</span> 'equal))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-populate-org_id-human_id-hash-table</span> (src-block-html backend info)
  (<span class="org-keyword">when</span> (org-export-derived-backend-p backend 'html)
    (<span class="org-keyword">let*</span> ((block-name (lilac-get-src-block-name-from-html src-block-html))
           (block-name-count (gethash block-name
                                      lilac-human_id-count-hash-table
                                      0))
           (orgid (lilac-get-src-block-HTML_ID src-block-html)))
      (<span class="org-keyword">when</span> orgid
        (puthash block-name
                 (1+ block-name-count)
                 lilac-human_id-count-hash-table)
        (<span class="org-keyword">cond</span> ((= block-name-count 0)
                (<span class="org-keyword">progn</span>
                  (puthash orgid
                           block-name
                           lilac-org_id-human_id-hash-table)
                  (puthash block-name
                           orgid
                           lilac-human_id-org_id-hash-table)))
              ((= block-name-count 1)
                (<span class="org-keyword">let*</span> ((orgid-first-block
                        (gethash block-name lilac-human_id-org_id-hash-table)))
                  (puthash orgid-first-block
                           (format <span class="org-string">"%s-1"</span> block-name)
                           lilac-org_id-human_id-hash-table)
                  (puthash orgid
                           (format <span class="org-string">"%s-%d"</span> block-name (1+ block-name-count))
                           lilac-org_id-human_id-hash-table)))
              (t
                 (puthash orgid
                          (format <span class="org-string">"%s-%d"</span> block-name (1+ block-name-count))
                          lilac-org_id-human_id-hash-table))))
      src-block-html)))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-replace-org_ids-with-human_ids</span> (entire-html backend info)
  (<span class="org-keyword">when</span> (org-export-derived-backend-p backend 'html)
    (<span class="org-keyword">let</span> ((html-oneline (lilac-to-single-line entire-html)))
      (maphash
       (<span class="org-keyword">lambda</span> (k v)
        (<span class="org-keyword">when</span> (<span class="org-keyword">and</span> k v)
         (<span class="org-keyword">setq</span> html-oneline
               (replace-regexp-in-string
                (rx-to-string `(<span class="org-keyword">and</span> <span class="org-string">" id="</span> (* (not <span class="org-string">"\""</span>)) <span class="org-string">"\""</span> ,k <span class="org-string">"\""</span>))
                (format <span class="org-string">" id=\"%s\""</span> v) html-oneline))
         (<span class="org-keyword">setq</span> html-oneline
               (replace-regexp-in-string
                (rx-to-string `(<span class="org-keyword">and</span> <span class="org-string">" href="</span> (* (not <span class="org-string">"\""</span>)) <span class="org-string">"\"#"</span> ,k <span class="org-string">"\""</span>))
                (format <span class="org-string">" href=\"#%s\""</span> v) html-oneline))))
       lilac-org_id-human_id-hash-table)
      (lilac-to-multi-line html-oneline))))
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Pretty-source-code-captions" class="outline-4">
<h4 id="h-Pretty-source-code-captions"><span class="section-number-4">5.6.2.</span> Pretty source code captions</h4>
<div class="outline-text-4" id="text-h-Pretty-source-code-captions">
<p>
Here there are basically 3 things we have to keep track of:
</p>

<ol class="org-ol">
<li>the outer <code>&lt;div&gt;</code> that encloses the entire source code block,</li>
<li>the <code>&lt;label&gt;</code>, if any (it may not exist), and</li>
<li>the <code>&lt;pre&gt;</code> content.</li>
</ol>

<p>
We only care about source code blocks with a <code>&lt;label&gt;</code> because that determines
whether we have a "Listing: &#x2026;" or not. We just need to save the 3 bits of
information, and then:
</p>

<ol class="org-ol">
<li>print the outer <code>&lt;div ...&gt;</code>,</li>
<li>print the <code>&lt;pre&gt;</code> content, and</li>
<li>print the <code>&lt;label&gt;</code> content but as a <code>&lt;div&gt;</code>.</li>
</ol>

<p>
For the last step, we want to additionally parse the inner "Listing N &#x2026; 0 [1 2
3 &#x2026;]" text and transform it with reordering and also additional metadata
information such as <code>&lt;span class="..."&gt;</code> tags.
</p>

<p>
We also save the <code>NSCB_POLYBLOCK_INDICATOR</code> with the <code>polyblock-indicator</code>
variable and display it.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">lilac-prettify-source-code-captions</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac-prettify-source-code-captions">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac-prettify-source-code-captions">(<span class="org-keyword">setq</span> lilac-polyblock-names (make-hash-table <span class="org-builtin">:test</span> 'equal))
(<span class="org-keyword">setq</span> lilac-polyblock-names-totals (make-hash-table <span class="org-builtin">:test</span> 'equal))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-prettify-source-code-captions</span> (src-block-html backend info)
  (<span class="org-keyword">when</span> (org-export-derived-backend-p backend 'html)
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Break up source block into 3 subparts --- the leading &lt;div ...&gt;, the</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">&lt;label ...&gt;&lt;/label&gt; (if any) and &lt;pre ...&gt;&lt;/pre&gt;.</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Then run the linkifying logic against only the body, and then return the</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">original label and new body.</span>
    (<span class="org-keyword">let*</span> ((div-caption-body (lilac-get-source-block-html-parts-without-newlines
                              src-block-html))
           (leading-div (nth 0 div-caption-body))
           (body (nth 2 div-caption-body))
           (pre-id-match
             (string-match
               (rx-to-string
                 '(and
                       <span class="org-string">"&lt;pre "</span>
                       (* (not <span class="org-string">"&gt;"</span>))
                       <span class="org-string">"id=\""</span>
                       (group (+ (not <span class="org-string">"\""</span>)))))
               body))
           (pre-id
             (<span class="org-keyword">if</span> pre-id-match
                 (match-string-no-properties 1 body)
                 <span class="org-string">"#deadlink"</span>))
           (body-with-newlines
            (lilac-to-multi-line body))
           (caption (nth 1 div-caption-body))
           <span class="org-comment-delimiter">; </span><span class="org-comment">caption-parts just captures whatever substring is inside the</span>
           <span class="org-comment-delimiter">; </span><span class="org-comment">&lt;label&gt; tags.</span>
           (caption-parts
             (<span class="org-keyword">let*</span> ((caption-match
                      (string-match <span class="org-string">"&lt;label [</span><span class="org-string"><span class="org-negation-char">^</span></span><span class="org-string">&gt;]+&gt;</span><span class="org-string"><span class="org-regexp-grouping-backslash">\\</span></span><span class="org-string"><span class="org-regexp-grouping-construct">(</span></span><span class="org-string">.*?</span><span class="org-string"><span class="org-regexp-grouping-backslash">\\</span></span><span class="org-string"><span class="org-regexp-grouping-construct">)</span></span><span class="org-string">&lt;/label&gt;"</span> caption)))
               (<span class="org-keyword">if</span> caption-match
                   (match-string-no-properties 1 caption)
                   <span class="org-string">""</span>)))
           (source-block-name-match
             (string-match
               (rx-to-string
                 '(and
                       <span class="org-string">"&lt;code&gt;"</span>
                       (group (+ (not <span class="org-string">"&lt;"</span>)))
                       <span class="org-string">"&lt;/code&gt;"</span>))
               caption-parts))
           <span class="org-comment-delimiter">;; </span><span class="org-comment">A source code block is anonymous if: (1) it does not have a</span>
           <span class="org-comment-delimiter">;; </span><span class="org-comment">"#+name: ..." line, or (2) it does not have a "#+header:</span>
           <span class="org-comment-delimiter">;; </span><span class="org-comment">:noweb-ref ..." line.</span>
           (source-block-name
             (<span class="org-keyword">if</span> source-block-name-match
                 (match-string-no-properties 1 caption-parts)
                 <span class="org-string">"anonymous"</span>))
           <span class="org-comment-delimiter">;; </span><span class="org-comment">This is just used for the side effect of recording the</span>
           <span class="org-comment-delimiter">;; </span><span class="org-comment">source-block-name, to be used for the fallback-id.</span>
           (source-block-counter
            (gethash source-block-name lilac-polyblock-names 0))
           (source-block-counter-incremented
            (puthash source-block-name (+ 1 source-block-counter)
                     lilac-polyblock-names))
           (source-block-name-styled
             (<span class="org-keyword">cond</span> ((string-prefix-p <span class="org-string">"__NREF__"</span> source-block-name)
                    (concat
                      <span class="org-string">"&lt;span class=\"lilac-caption-source-code-block-name\"&gt;"</span>
                      (string-remove-prefix <span class="org-string">"__NREF__"</span> source-block-name)
                      <span class="org-string">"&lt;/span&gt;"</span>))
                   (t
                    (concat
                      <span class="org-string">"&lt;span class=\"lilac-caption-source-code-block-name\"&gt;"</span>
                      <span class="org-string">"&amp;#x1f4c4; "</span>
                      source-block-name
                      <span class="org-string">"&lt;/span&gt;"</span>))))
           (polyblock-chain-total
            (gethash source-block-name lilac-polyblock-names-totals 0))
           (polyblock-chain-location
            (<span class="org-keyword">if</span> (= polyblock-chain-total 0)
                <span class="org-string">""</span>
              (format <span class="org-string">"(%s/%s) "</span>
                      source-block-counter-incremented polyblock-chain-total)))
           (polyblock-indicator
             (<span class="org-keyword">if</span> (string-match <span class="org-string">"</span><span class="org-string"><span class="org-warning">\</span></span><span class="org-string">(polyblock</span><span class="org-string"><span class="org-warning">\</span></span><span class="org-string">)"</span> caption-parts)
                 polyblock-chain-location <span class="org-string">""</span>))
           (parent-id-regexp
               (rx-to-string
                 '(and
                       <span class="org-string">" &lt;a href=\""</span>
                       (group (+ (not <span class="org-string">"\""</span>))))))
           (parent-ids-with-idx
            (lilac-enumerate
             (lilac-matches parent-id-regexp caption-parts 1) 1))
           (parent-links
             (mapconcat (<span class="org-keyword">lambda</span> (parent-id-with-idx)
                          (<span class="org-keyword">let</span> ((parent-id (car (cdr parent-id-with-idx)))
                                (idx (car parent-id-with-idx)))
                             (format (concat
                                      <span class="org-string">"&lt;span class="</span>
                                      <span class="org-string">"\"lilac-caption-parent-link\"&gt;"</span>
                                      <span class="org-string">"&lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/span&gt;"</span>)
                               parent-id
                               (<span class="org-keyword">if</span> (= idx 1)
                                   (string-remove-prefix
                                    <span class="org-string">"__NREF__"</span> source-block-name)
                                 idx))))
                        parent-ids-with-idx <span class="org-string">""</span>))
           <span class="org-comment-delimiter">;; </span><span class="org-comment">For polyblocks, only the first (head) block gets an id field for a</span>
           <span class="org-comment-delimiter">;; </span><span class="org-comment">&lt;pre&gt; tag. The rest (tail) don't have this field so they would</span>
           <span class="org-comment-delimiter">;; </span><span class="org-comment">normally get assigned a deadlink. To avoid this, use a counter for</span>
           <span class="org-comment-delimiter">;; </span><span class="org-comment">the parent-id, because this parent-id is shared across all</span>
           <span class="org-comment-delimiter">;; </span><span class="org-comment">polyblocks. Then use this with the parent-id to generate an</span>
           <span class="org-comment-delimiter">;; </span><span class="org-comment">alternate, fallback-id. This way the tail polyblocks get assigned</span>
           <span class="org-comment-delimiter">;; </span><span class="org-comment">a unique (meaningful) ID and not just "##deadlink".</span>
           (fallback-id
             (<span class="org-keyword">if</span> (string= pre-id <span class="org-string">"#deadlink"</span>)
                 (format <span class="org-string">"%s-%s"</span>
                         source-block-name
                         source-block-counter-incremented)
                 pre-id))
           (pre-tag-match
             (string-match
               (rx-to-string
                 '(and
                       <span class="org-string">"&lt;pre "</span>
                       (group (* (not <span class="org-string">"&gt;"</span>)))
                       <span class="org-string">"&gt;"</span>))
               body))
           (pre-tag-entire (match-string-no-properties 0 body))
           (pre-tag-contents (match-string-no-properties 1 body))
           (body-with-replaced-pre
             (<span class="org-keyword">if</span> pre-id-match
                 body-with-newlines
                 (string-replace pre-tag-entire
                                 (concat <span class="org-string">"&lt;pre "</span> pre-tag-contents
                                         (format <span class="org-string">" id=\"%s\""</span> fallback-id) <span class="org-string">"&gt;"</span>)
                                 body-with-newlines)))
           (link-symbol
             (format (concat <span class="org-string">"&lt;span class=\"lilac-caption-link-symbol\"&gt;"</span>
                             <span class="org-string">"&lt;a href=\"#%s\"&gt;&amp;#x1f517;&lt;/a&gt;&lt;/span&gt;"</span>)
               fallback-id))
           (caption-without-listing-prefix
            (replace-regexp-in-string <span class="org-string">"&lt;span.+?span&gt;"</span> <span class="org-string">""</span> caption))
           (caption-text
            (<span class="org-keyword">if</span> (&gt; (length parent-links) 0)
                (concat
                  <span class="org-string">"&lt;div class=\"lilac-caption\"&gt;"</span>
                    parent-links
                    polyblock-indicator
                    link-symbol
                  <span class="org-string">"&lt;/div&gt;"</span>)
                (concat
                  <span class="org-string">"&lt;div class=\"lilac-caption\"&gt;"</span>
                    caption-without-listing-prefix
                    link-symbol
                  <span class="org-string">"&lt;/div&gt;"</span>)))
           )
      (<span class="org-keyword">if</span> (s-blank? caption)
       src-block-html
       (concat
        leading-div
          <span class="org-string">"&lt;div class=\"lilac-pre-with-caption\"&gt;"</span>
            caption-text
            body-with-replaced-pre
          <span class="org-string">"&lt;/div&gt;"</span>
        <span class="org-string">"&lt;/div&gt;"</span>)))))

<span class="lilac-child-link-from-parent"><a href="#__NREF__lilac-get-source-block-html-parts-without-newlines">lilac-get-source-block-html-parts-without-newlines</a></span>
</pre></div></div><p>
This is a helper function to parse the HTML output for a source code block.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac-prettify-source-code-captions">lilac-get-source-block-html-parts-without-newlines</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac-get-source-block-html-parts-without-newlines">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac-get-source-block-html-parts-without-newlines">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-get-source-block-html-parts-without-newlines</span> (src-block-html)
    (<span class="org-keyword">let*</span> ((one-line (lilac-to-single-line src-block-html))
           (leading-div
             (<span class="org-keyword">let</span> ((div-match
                    (string-match <span class="org-string">"&lt;div [</span><span class="org-string"><span class="org-negation-char">^</span></span><span class="org-string">&gt;]+&gt;"</span> one-line)))
               (match-string-no-properties 0 one-line)))
           (caption
             (<span class="org-keyword">let*</span> ((caption-match
                      (string-match <span class="org-string">"&lt;label [</span><span class="org-string"><span class="org-negation-char">^</span></span><span class="org-string">&gt;]+&gt;.*?&lt;/label&gt;"</span> one-line)))
               (<span class="org-keyword">if</span> caption-match
                   (match-string-no-properties 0 one-line)
                   <span class="org-string">""</span>)))
           (body (<span class="org-keyword">progn</span> (string-match <span class="org-string">"&lt;pre [</span><span class="org-string"><span class="org-negation-char">^</span></span><span class="org-string">&gt;]+&gt;.*?&lt;/pre&gt;"</span> one-line)
                        (match-string-no-properties 0 one-line))))
      `(,leading-div ,caption ,body)))
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Link-noweb-references--link-to-child-block-from-parent-block" class="outline-4">
<h4 id="h-Link-noweb-references--link-to-child-block-from-parent-block"><span class="section-number-4">5.6.3.</span> Link noweb references (link to child block from parent block)</h4>
<div class="outline-text-4" id="text-h-Link-noweb-references--link-to-child-block-from-parent-block">
<p>
Consider the following code:
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">Sample Org-mode Noweb-style references</label><span class="lilac-caption-link-symbol"><a href="#Sample-Org-mode-Noweb-style-references-3">&#x1f517;</a></span></div><pre class="src src-org" id="Sample-Org-mode-Noweb-style-references-3"><span class="org-org-meta-line">#+name: parent-block</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"Hello from the parent block"</span></span>
<span class="org-org-block">__NREF__child-block-1</span>
<span class="org-org-block">__NREF__child-block-2</span>
<span class="org-org-block-end-line">#+end_src</span>

...

<span class="org-org-meta-line">#+name: __NREF__child-block-1</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"I am child 1"</span></span>
<span class="org-org-block-end-line">#+end_src</span>

...

<span class="org-org-meta-line">#+header: :noweb-ref __NREF__child-block-2</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> -n </span><span class="org-org-block"><span class="org-string">"I am "</span></span>
<span class="org-org-block-end-line">#+end_src</span>

<span class="org-org-meta-line">#+header: :noweb-ref __NREF__child-block-2</span>
<span class="org-org-block-begin-line">#+begin_src bash</span>
<span class="org-org-block"><span class="org-builtin">echo</span></span><span class="org-org-block"> </span><span class="org-org-block"><span class="org-string">"child 2"</span></span>
<span class="org-org-block-end-line">#+end_src</span>
</pre></div></div><p>
What we want to do is to make the <code>__NREF__child-block-1</code> and
<code>__NREF__child-block-2</code> references inside <code>parent-block</code> to link to their
definitions, so that the reader can just click on them to go to see how they're
defined. Unfortunately Org mode doesn't do this by default so we have to do this
ourselves.
</p>

<p>
In the case of <code>__NREF__child-block-2</code>, it is defined in multiple blocks so we
would want to link to the very first block.
</p>

<p>
We cannot use a <code>org-export-before-parsing-hook</code> like we did in
<a href="#__NREF__lilac-publish-modify-org"><code>__NREF__lilac-publish-modify-org</code></a> because at that stage of processing, we are
dealing with Org mode syntax. Any modifications we make to the parent source
code block will be treated as text upon HTML export. Thankfully Org mode allows
customizations on generated HTML through the
<code>org-export-filter-src-block-functions</code> variable. This variable is analogous to
<code>org-export-before-parsing-hook</code>, but operates at the HTML level (not at the Org
syntax level) for source code blocks, which is exactly what we need.
</p>

<p>
So we have to craft valid HTML links (not Org links) to the child source code
blocks. For this we need the actual <code>id</code> part of the HTML <code>&lt;pre&gt;...</code> block that
will hold the source code. That is, the algorithm should be something like:
</p>

<ol class="org-ol">
<li>for every parent source code block,</li>
<li>for every child block (noweb) referenced in the body, insert an HTML link to
the child block (lookup in <code>child-HTML_ID-hash-table</code>).</li>
</ol>

<p>
The only thing remaining is the construction of <code>child-HTML_ID-hash-table</code>. We
can construct this by mapping through all source code blocks and getting the
name which can be just drawn from the <code>&lt;label ...&gt;</code> HTML tag, thanks to the
smart captions we inserted for all child blocks earlier in <a href="#h-Automatic-captions-for-Noweb-source-code-blocks">5.5.2</a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-lilac-publish">lilac-html-filter-src-blocks</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac-html-filter-src-blocks">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac-html-filter-src-blocks"><span class="org-comment-delimiter">; </span><span class="org-comment">Define a global hash table for mapping child source block names to their HTML</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">IDs.</span>
(<span class="org-keyword">setq</span> lilac-child-HTML_ID-hash-table (make-hash-table <span class="org-builtin">:test</span> 'equal))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-populate-child-HTML_ID-hash-table</span> (src-block-html backend info)
  (<span class="org-keyword">when</span> (org-export-derived-backend-p backend 'html)
    (<span class="org-keyword">let*</span> ((child-name (lilac-get-src-block-name-from-html src-block-html))
           (child-HTML_ID (lilac-get-src-block-HTML_ID src-block-html))
           (child-HTML_ID-exists-already
            (gethash child-name lilac-child-HTML_ID-hash-table nil)))
      <span class="org-comment-delimiter">; </span><span class="org-comment">Skip blocks that lack an HTML ID.</span>
      (<span class="org-keyword">if</span> (<span class="org-keyword">and</span> child-HTML_ID (not child-HTML_ID-exists-already))
        (puthash child-name child-HTML_ID lilac-child-HTML_ID-hash-table))
      <span class="org-comment-delimiter">; </span><span class="org-comment">Return src-block-html as-is (no modifications).</span>
      src-block-html)))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-get-src-block-name-from-html</span> (src-block-html)
  (<span class="org-keyword">let*</span> ((match-nref (string-match
                      (concat
                       <span class="org-string">"&lt;label.+?&lt;code&gt;"</span>
                       (lilac-nref-rx nil)
                       <span class="org-string">"&lt;/code&gt;"</span>)
                      src-block-html))
         (match-raw (<span class="org-keyword">if</span> (not match-nref)
                        (string-match
                         (rx-to-string
                          '(and
                            <span class="org-string">"&lt;label"</span>
                            (+ (not <span class="org-string">"&gt;"</span>))
                            <span class="org-string">"&gt;"</span>
                            (group (*? anychar))
                            <span class="org-string">"&lt;/label&gt;"</span>))
                         src-block-html)))
         (matched-contents (match-string-no-properties 1 src-block-html)))
    (<span class="org-keyword">if</span> match-nref
        matched-contents
        (<span class="org-keyword">if</span> match-raw
            (lilac-clean-up-match-raw matched-contents)))))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-clean-up-match-raw</span> (s)
  (<span class="org-keyword">let*</span> ((normalized (lilac-normalize-string s))
         (rx (rx-to-string
                '(and
                  <span class="org-string">"Listing-"</span>
                  (+ (any digit))
                  (+ <span class="org-string">"-"</span>)
                  <span class="org-string">"span"</span>
                  (* <span class="org-string">"-"</span>)
                  (group (+ anychar)))))
         (match (string-match rx normalized)))
    (<span class="org-keyword">if</span> match
        (match-string-no-properties 1 normalized)
        normalized)))

<span id="coderef-lilac-get-src-block-HTML_ID" class="coderef-off"></span>
(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-get-src-block-HTML_ID</span> (src-block-html)
  (<span class="org-keyword">let</span> ((match (string-match <span class="org-string">"&lt;pre [</span><span class="org-string"><span class="org-negation-char">^</span></span><span class="org-string">&gt;]+?id=\"</span><span class="org-string"><span class="org-regexp-grouping-backslash">\\</span></span><span class="org-string"><span class="org-regexp-grouping-construct">(</span></span><span class="org-string">[</span><span class="org-string"><span class="org-negation-char">^</span></span><span class="org-string">\"]+</span><span class="org-string"><span class="org-regexp-grouping-backslash">\\</span></span><span class="org-string"><span class="org-regexp-grouping-construct">)</span></span><span class="org-string">\"&gt;"</span> src-block-html)))
    (<span class="org-keyword">if</span> match (match-string-no-properties 1 src-block-html))))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-link-to-children-from-parent-body</span> (src-block-html backend info)
  (<span class="org-keyword">when</span> (org-export-derived-backend-p backend 'html)
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Break up source block into 3 subparts --- the leading &lt;div ...&gt;, the</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">&lt;label ...&gt;&lt;/label&gt; (if any) and &lt;pre ...&gt;&lt;/pre&gt;.</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">Then run the linkifying logic against only the body, and then return the</span>
    <span class="org-comment-delimiter">;; </span><span class="org-comment">original label and new body.</span>
    (<span class="org-keyword">let*</span> ((div-caption-body (lilac-get-source-block-html-parts-without-newlines
                              src-block-html))
           (leading-div (nth 0 div-caption-body))
           (caption (nth 1 div-caption-body))
           (body (nth 2 div-caption-body))
           (body-linkified-without-newlines
            (replace-regexp-in-string
             (lilac-nref-rx nil)
             (<span class="org-keyword">lambda</span> (child-name-text)
                 (<span class="org-keyword">let*</span> ((HTML_ID (gethash child-name-text
                                          lilac-child-HTML_ID-hash-table)))
                  (<span class="org-keyword">if</span> HTML_ID
                      (concat <span class="org-string">"&lt;span class=\"lilac-child-link-from-parent\"&gt;"</span>
                              <span class="org-string">"&lt;a href=\"#"</span> HTML_ID <span class="org-string">"\"&gt;"</span>
                              (string-remove-prefix <span class="org-string">"__NREF__"</span> child-name-text)
                              <span class="org-string">"&lt;/a&gt;&lt;/span&gt;"</span>)
                      child-name-text)))
             body))
           (body-linkified-with-newlines
            (lilac-to-multi-line body-linkified-without-newlines)))
      (concat leading-div caption body-linkified-with-newlines <span class="org-string">"&lt;/div&gt;"</span>))))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-to-single-line</span> (s)
  (replace-regexp-in-string <span class="org-string">"\n"</span> <span class="org-string">"&lt;&lt;&lt;NEWLINE&gt;&gt;&gt;"</span> s))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-to-multi-line</span> (s)
  (replace-regexp-in-string <span class="org-string">"&lt;&lt;&lt;NEWLINE&gt;&gt;&gt;"</span> <span class="org-string">"\n"</span> s))

<span class="lilac-child-link-from-parent"><a href="#__NREF__custom-noweb-delimiters">custom-noweb-delimiters</a></span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Custom-Noweb-delimiters" class="outline-4">
<h4 id="h-Custom-Noweb-delimiters"><span class="section-number-4">5.6.4.</span> Custom Noweb delimiters</h4>
<div class="outline-text-4" id="text-h-Custom-Noweb-delimiters">
<p>
Note that we need to evaluate this lisp code if we want to run <code>C-c C-v t</code> to
tangle code blocks properly in an interactive manner from an Emacs editing
session.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac-html-filter-src-blocks">custom-noweb-delimiters</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__custom-noweb-delimiters">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__custom-noweb-delimiters">(<span class="org-keyword">setq</span> org-babel-noweb-wrap-start <span class="org-string">"__NREF__"</span>)
(<span class="org-keyword">setq</span> org-babel-noweb-wrap-end <span class="org-string">""</span>)

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-nref-rx</span> (match-optional-params)
  (rx-to-string
   (lilac-nref-rx-primitive match-optional-params)))

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-nref-rx-primitive</span> (match-optional-params)
  (<span class="org-keyword">if</span> match-optional-params
   `(group
           <span class="org-string">"__NREF__"</span>
          <span class="org-comment-delimiter">;; </span><span class="org-comment">Noweb reference must start with a letter...</span>
          (any alpha)
          <span class="org-comment-delimiter">;; </span><span class="org-comment">...and must be followed by</span>
          <span class="org-comment-delimiter">;; </span><span class="org-comment">letters,numbers,dashes,underscores,periods...</span>
          (* (<span class="org-keyword">or</span> (any alnum) <span class="org-string">"-"</span> <span class="org-string">"_"</span> <span class="org-string">"."</span>))
          <span class="org-comment-delimiter">;; </span><span class="org-comment">...and may terminate with a "(...)" where the "..." may be an empty</span>
          <span class="org-comment-delimiter">;; </span><span class="org-comment">string, or some other argument.</span>
          (* (<span class="org-keyword">or</span> <span class="org-string">"()"</span>
                 (<span class="org-keyword">and</span> <span class="org-string">"("</span>
                      (* (not <span class="org-string">")"</span>))
                      <span class="org-string">")"</span>))))
   `(group
          <span class="org-string">"__NREF__"</span>
          (any alpha)
          (* (<span class="org-keyword">or</span> (any alnum) <span class="org-string">"-"</span> <span class="org-string">"_"</span> <span class="org-string">"."</span>)))))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Customize noweb delimiters. Unlike traditional &lt;&lt; and &gt;&gt; delimiters, we just</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">use the "__NREF__" prefix as our only delimiter. This has the advantage of</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">being encoded the same way into HTML, which makes our HTML modifications</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">easier and more consistent across different source code languages.</span>
<span class="org-comment-delimiter">;; </span><span class="org-comment">See https://emacs.stackexchange.com/a/73720/13006.</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">org-babel-noweb-wrap</span> (<span class="org-type">&amp;optional</span> regexp)
  <span class="org-doc">"Return regexp matching a Noweb reference.</span>

<span class="org-doc">Match any reference, or only those matching REGEXP, if non-nil.</span>
<span class="org-doc">When matching, reference is stored in match group 1."</span>
  (lilac-nref-rx t))
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Autogenerate-CSS-for-syntax-highlighting-of-source-code-blocks" class="outline-3">
<h3 id="h-Autogenerate-CSS-for-syntax-highlighting-of-source-code-blocks"><span class="section-number-3">5.7.</span> Autogenerate CSS for syntax highlighting of source code blocks</h3>
<div class="outline-text-3" id="text-h-Autogenerate-CSS-for-syntax-highlighting-of-source-code-blocks">
<p>
See <a href="https://emacs.stackexchange.com/questions/31439/how-to-get-colored-syntax-highlighting-of-code-blocks-in-asynchronous-org-mode-e">this</a>, specifically <a href="https://emacs.stackexchange.com/a/36759">https://emacs.stackexchange.com/a/36759</a>.
</p>

<p>
Generate <code>syntax-highlighting.css</code> and quit emacs. This function is designed to
be run from the command line on a fresh emacs instance (dedicated OS process).
Unfortunately, by itself it is almost useless (see
<a href="#__NREF__enable-syntax-highlighting-from-batch-mode"><code>__NREF__enable-syntax-highlighting-from-batch-mode</code></a>), because there appears to
be a <a href="https://debbugs.gnu.org/cgi/bugreport.cgi?bug=61521">bug</a> in Emacs 28 which <a href="https://emacs.stackexchange.com/questions/75814/org-html-htmlize-generate-css-not-generating-styles">breaks</a> <code>org-html-htmlize-generate-css</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-autogenerate-css</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-autogenerate-css">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-autogenerate-css">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-gen-css-and-exit</span> ()
  (font-lock-flush)
  (font-lock-fontify-buffer)
  (org-html-htmlize-generate-css)
  (<span class="org-keyword">with-current-buffer</span> <span class="org-string">"*html*"</span>
    (write-file <span class="org-string">"syntax-highlighting.css"</span>))
  (kill-emacs))

<span class="org-comment-delimiter">;; </span><span class="org-comment">Without this, batch-org-gen-css-and-exit produces a near-empty CSS file.</span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__enable-syntax-highlighting-from-batch-mode">enable-syntax-highlighting-from-batch-mode</a></span>
</pre></div></div><p>
Sadly, <code>lilac-gen-css-and-exit</code> by itself generates a near-blank CSS file.
So we have to use code from <a href="https://emacs.stackexchange.com/questions/38437/org-mode-batch-export-missing-syntax-highlighting">here</a>:
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#__NREF__lilac_dot_el-autogenerate-css">enable-syntax-highlighting-from-batch-mode</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__enable-syntax-highlighting-from-batch-mode">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__enable-syntax-highlighting-from-batch-mode">(<span class="org-keyword">require</span> '<span class="org-constant">font-lock</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">subr-x</span>) <span class="org-comment-delimiter">;; </span><span class="org-comment">for `</span><span class="org-comment"><span class="org-constant">when-let</span></span><span class="org-comment">'</span>

(<span class="org-keyword">unless</span> (boundp 'maximal-integer)
  (<span class="org-keyword">defconst</span> <span class="org-variable-name">maximal-integer</span> (lsh -1 -1)
    <span class="org-doc">"Maximal integer value representable natively in emacs lisp."</span>))

(<span class="org-keyword">defun</span> <span class="org-function-name">face-spec-default</span> (spec)
  <span class="org-doc">"Get list containing at most the default entry of face SPEC.</span>
<span class="org-doc">Return nil if SPEC has no default entry."</span>
  (<span class="org-keyword">let*</span> ((first (car-safe spec))
     (display (car-safe first)))
    (<span class="org-keyword">when</span> (eq display 'default)
      (list (car-safe spec)))))

(<span class="org-keyword">defun</span> <span class="org-function-name">face-spec-min-color</span> (display-atts)
  <span class="org-doc">"Get min-color entry of DISPLAY-ATTS pair from face spec."</span>
  (<span class="org-keyword">let*</span> ((display (car-safe display-atts)))
    (<span class="org-keyword">or</span> (car-safe (cdr (assoc 'min-colors display)))
    maximal-integer)))

(<span class="org-keyword">defun</span> <span class="org-function-name">face-spec-highest-color</span> (spec)
  <span class="org-doc">"Search face SPEC for highest color.</span>
<span class="org-doc">That means the DISPLAY entry of SPEC</span>
<span class="org-doc">with class 'color and highest min-color value."</span>
  (<span class="org-keyword">let</span> ((color-list (cl-remove-if-not
             (<span class="org-keyword">lambda</span> (display-atts)
               (<span class="org-keyword">when-let</span> ((display (car-safe display-atts))
                  (class (<span class="org-keyword">and</span> (listp display)
                          (assoc 'class display)))
                  (background (assoc 'background display)))
             (<span class="org-keyword">and</span> (member 'light (cdr background))
                  (member 'color (cdr class)))))
             spec)))
    (cl-reduce (<span class="org-keyword">lambda</span> (display-atts1 display-atts2)
         (<span class="org-keyword">if</span> (&gt; (face-spec-min-color display-atts1)
            (face-spec-min-color display-atts2))
             display-atts1
           display-atts2))
           (cdr color-list)
           <span class="org-builtin">:initial-value</span> (car color-list))))

(<span class="org-keyword">defun</span> <span class="org-function-name">face-spec-t</span> (spec)
  <span class="org-doc">"Search face SPEC for fall back."</span>
  (cl-find-if (<span class="org-keyword">lambda</span> (display-atts)
        (eq (car-safe display-atts) t))
          spec))

<span class="org-comment-delimiter">; </span><span class="org-comment">This is slightly tweaked from the original, because the incoming "face" value</span>
<span class="org-comment-delimiter">; </span><span class="org-comment">can look like (fixed-pitch face-name) --- so we take the second element.</span>
(<span class="org-keyword">defun</span> <span class="org-function-name">my-face-attribute</span> (face attribute <span class="org-type">&amp;optional</span> frame inherit)
  <span class="org-doc">"Get FACE ATTRIBUTE from `</span><span class="org-doc"><span class="org-constant">face-user-default-spec</span></span><span class="org-doc">' and not from</span>
<span class="org-doc">`</span><span class="org-doc"><span class="org-constant">face-attribute</span></span><span class="org-doc">'."</span>
  (<span class="org-keyword">let*</span>
    ((face-spec (face-user-default-spec (<span class="org-keyword">if</span> (listp face)
                                            (car (cdr face))
                                          face)))
     (display-attr (<span class="org-keyword">or</span> (face-spec-highest-color face-spec)
               (face-spec-t face-spec)))
     (attr (cdr display-attr))
     (val (<span class="org-keyword">or</span> (plist-get attr attribute)
              (car-safe (cdr (assoc attribute attr))))))
    (<span class="org-keyword">when</span> (<span class="org-keyword">and</span> (null (eq attribute <span class="org-builtin">:inherit</span>))
           (null val))
      (<span class="org-keyword">let</span> ((inherited-face (my-face-attribute face <span class="org-builtin">:inherit</span>)))
    (<span class="org-keyword">when</span> (<span class="org-keyword">and</span> inherited-face
           (null (eq inherited-face 'unspecified)))
      (<span class="org-keyword">setq</span> val (my-face-attribute inherited-face attribute)))))
    (<span class="org-keyword">or</span> val 'unspecified)))

(advice-add 'face-attribute <span class="org-builtin">:override</span> #'my-face-attribute)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Misc-settings" class="outline-3">
<h3 id="h-Misc-settings"><span class="section-number-3">5.8.</span> Misc settings</h3>
<div class="outline-text-3" id="text-h-Misc-settings">
</div>

<div id="outline-container-h-Use-HTML5-export--not-XML--to-un-break-MathJax" class="outline-4">
<h4 id="h-Use-HTML5-export--not-XML--to-un-break-MathJax"><span class="section-number-4">5.8.1.</span> Use HTML5 export, not XML (to un-break MathJax)</h4>
<div class="outline-text-4" id="text-h-Use-HTML5-export--not-XML--to-un-break-MathJax">
<p>
By default on Org 9.6, MathJax settings (JavaScript snippet) gets wrapped in a
CDATA tag, and we run into the same problem described on this email that has
gone unanswered:
<a href="https://www.mail-archive.com/emacs-orgmode@gnu.org/msg140821.html">https://www.mail-archive.com/emacs-orgmode@gnu.org/msg140821.html</a>. It appears
that this is because the document is exported as XML, not HTMl. Setting the
document type to <code>html5</code>, as below, appears to make the CDATA tag magically
disappear.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-misc</a></span>(1/4) <span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-misc-1">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-misc-1">(<span class="org-keyword">setq</span> org-html-doctype <span class="org-string">"html5"</span>)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Preserve-leading-whitespace-characters-on-export" class="outline-4">
<h4 id="h-Preserve-leading-whitespace-characters-on-export"><span class="section-number-4">5.8.2.</span> Preserve leading whitespace characters on export</h4>
<div class="outline-text-4" id="text-h-Preserve-leading-whitespace-characters-on-export">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-misc</a></span>(2/4) <span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-misc-2">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-misc-2">(<span class="org-keyword">setq</span> org-src-preserve-indentation t)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Disable-backups" class="outline-4">
<h4 id="h-Disable-backups"><span class="section-number-4">5.8.3.</span> Disable backups</h4>
<div class="outline-text-4" id="text-h-Disable-backups">
<p>
Disable backup files for <code>lilac.el</code> (that look like <code>lilac.el~</code>) when we invoke
Emacs from the <a href="#Makefile">Makefile</a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-misc</a></span>(3/4) <span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-misc-3">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-misc-3">(<span class="org-keyword">setq</span> make-backup-files nil)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Profiling" class="outline-4">
<h4 id="h-Profiling"><span class="section-number-4">5.8.4.</span> Profiling</h4>
<div class="outline-text-4" id="text-h-Profiling">
<p>
We don't use this very often, but it's mainly for determining cost centers for
weaving and tangling.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-misc</a></span>(4/4) <span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-misc-4">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-misc-4">(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-publish-profile</span> ()
  (<span class="org-keyword">interactive</span>)
  (profiler-start 'cpu)
  (lilac-publish)
  (profiler-stop)
  (profiler-report)
  (profiler-report-write-profile <span class="org-string">"emacs-profile-weave.txt"</span>) t)

(<span class="org-keyword">defun</span> <span class="org-function-name">lilac-tangle-profile</span> ()
  (<span class="org-keyword">interactive</span>)
  (profiler-start 'cpu)
  (org-babel-tangle)
  (profiler-stop)
  (profiler-report)
  (profiler-report-write-profile <span class="org-string">"emacs-profile-tangle.txt"</span>) t)
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Automatically-link-headlines--h2-to-h6" class="outline-3">
<h3 id="h-Automatically-link-headlines--h2-to-h6"><span class="section-number-3">5.9.</span> Automatically link headlines (h2 to h6)</h3>
<div class="outline-text-3" id="text-h-Automatically-link-headlines--h2-to-h6">
<p>
Every HTML element <code>h2</code> to <code>h6</code> (which encode the Org mode headlines) already
come with a unique ID, but they are only ever linked from the Table of Contents.
The code here makes it so that the headlines are linked to themselves, which
makes it easy for users to link to them directly when they're reading the page.
</p>

<p>
The JavaScript below is taken from <a href="https://github.com/listx/listx_blog/blame/8e6e7b533d89f77a6939e5eda9fd9d990d25a7a9/misc.js#L1">here</a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">misc.js</label><span class="lilac-caption-link-symbol"><a href="#misc-js">&#x1f517;</a></span></div><pre class="src src-js" id="misc-js">$(<span class="org-keyword">function</span>() {
    $(<span class="org-string">"h2,h3,h4,h5,h6"</span>).each(<span class="org-keyword">function</span>() {
        <span class="org-keyword">var</span> <span class="org-variable-name">$this</span> = $(<span class="org-constant">this</span>);
        <span class="org-keyword">var</span> <span class="org-variable-name">href</span> = $this.attr(<span class="org-string">"id"</span>);
        $this.wrapInner(
            $(<span class="org-string">"&lt;a/&gt;"</span>).attr(<span class="org-string">"href"</span>, <span class="org-string">'#'</span> + href)
                     .addClass(<span class="org-string">"section-heading"</span>));
    });
});
</pre></div></div><p>
Now we just have to refer to the above in the snippet below, to be included in <a href="#h-Create--lilac-theme--file"><code>lilac.theme</code></a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-theme">automatically_link_headlines</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__automatically_link_headlines">&#x1f517;</a></span></div><pre class="src src-org" id="__NREF__automatically_link_headlines"><span class="org-comment"># Automatically link headlines.</span>
<span class="org-org-meta-line">#+HTML_HEAD: &lt;script src="<a href="https://code.jquery.com/jquery-3.6.4.min.js">https://code.jquery.com/jquery-3.6.4.min.js</a>"&gt;&lt;/script&gt;</span>
<span class="org-org-meta-line">#+HTML_HEAD: &lt;script src="misc.js"&gt;&lt;/script&gt;</span>
</pre></div></div><p>
Linkifying itself makes all the headlines blue (the default color for links).
This is a bit distracting, so make them black.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#style-css">css-source-code-section-headlines</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__css-source-code-section-headlines">&#x1f517;</a></span></div><pre class="src src-css" id="__NREF__css-source-code-section-headlines"><span class="org-css-selector">a.section-heading </span>{
    <span class="org-css-property">color</span>: <span class="custom">black</span>;
    <span class="org-css-property">text-decoration</span>: none;
}

<span class="org-css-selector">a.section-heading:hover::after </span>{
    <span class="org-css-property">float</span>: left;
    <span class="org-css-property">margin-left</span>: -1.3em;
    <span class="org-css-property">content</span>: <span class="org-string">"\1f517"</span>;
}
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Imports" class="outline-3">
<h3 id="h-Imports"><span class="section-number-3">5.10.</span> Imports</h3>
<div class="outline-text-3" id="text-h-Imports">
<p>
If we want syntax-highlighting to work for a code block, that code block's major
mode (language) must be loaded in here.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-el">lilac_dot_el-imports</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__lilac_dot_el-imports">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__lilac_dot_el-imports"><span class="org-comment-delimiter">;; </span><span class="org-comment">Built-in packages (distributed with Emacs).</span>
(<span class="org-keyword">require</span> '<span class="org-constant">elisp-mode</span>)

<span class="org-comment-delimiter">;; </span><span class="org-comment">Third-party packages (checked in as Git submodules)</span>
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/s.el"</span>))
(<span class="org-keyword">require</span> '<span class="org-constant">s</span>)
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/compat.el"</span>))
(<span class="org-keyword">require</span> '<span class="org-constant">compat</span>)
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/dash.el"</span>))
(<span class="org-keyword">require</span> '<span class="org-constant">dash</span>)
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/dr-qubit.org"</span>))
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/f.el"</span>))
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/parsebib"</span>))
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/citeproc-el"</span>))
(<span class="org-keyword">require</span> '<span class="org-constant">citeproc</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">oc-csl</span>)
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/emacs-htmlize"</span>))
(<span class="org-keyword">require</span> '<span class="org-constant">htmlize</span>)
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/magit/lisp"</span>))
(<span class="org-keyword">require</span> '<span class="org-constant">magit-section</span>)
(add-to-list 'load-path (concat (getenv <span class="org-string">"PWD"</span>) <span class="org-string">"/deps/elisp/nix-mode"</span>))
(<span class="org-keyword">require</span> '<span class="org-constant">nix-mode</span>)
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Additional--hand-tweaked--CSS" class="outline-3">
<h3 id="h-Additional--hand-tweaked--CSS"><span class="section-number-3">5.11.</span> Additional (hand-tweaked) CSS</h3>
<div class="outline-text-3" id="text-h-Additional--hand-tweaked--CSS">
<p>
We add some additional CSS tweaks on top of what we get from Org.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">style.css</label><span class="lilac-caption-link-symbol"><a href="#style-css">&#x1f517;</a></span></div><pre class="src src-css" id="style-css"><span class="org-css-selector">a </span>{
    <span class="org-css-property">color</span>: <span class="custom-2">#0000ff</span>;
}

<span class="org-css-selector">body </span>{
    <span class="org-css-property">font-size</span>: 1.5em;
    <span class="org-css-property">width</span>: 1000px;
    <span class="org-css-property">margin</span>: auto;
}

<span class="org-css-selector">body, p, li, h1, h2, h3, h4, h5, h6, legend </span>{
    <span class="org-css-property">font-family</span>: <span class="org-string">"Source Serif Pro"</span>, serif;
}

<span class="org-css-selector">p, li </span>{
    <span class="org-css-property">line-height</span>: 1.2em;
}

<span class="org-css-selector">p, ol, ul </span>{
    <span class="org-css-property">margin-bottom</span>: 0.5em;
}

<span class="org-css-selector">li </span>{
    <span class="org-css-property">margin-bottom</span>: 0;
}

<span class="org-css-selector">table </span>{
    <span class="org-css-property">margin</span>: 1em auto 0em auto;
    <span class="org-css-property">border-spacing</span>: 0;
    <span class="org-css-property">border-radius</span>: 4px;
    <span class="org-css-property">border</span>: 1px solid <span class="custom-1">#777</span>;
    <span class="org-css-property">border-collapse</span>: unset;
}

<span class="org-css-selector">th, td </span>{
    <span class="org-css-property">padding</span>: 3px 6px;
    <span class="org-css-property">border-right</span>: 1px solid <span class="custom-1">#777</span>;
    <span class="org-css-property">border-bottom</span>: 1px solid <span class="custom-1">#777</span>;
}

<span class="org-css-selector">th:last-child, td:last-child  </span>{
    <span class="org-css-property">border-right</span>: none;
}

<span class="org-css-selector">tr:last-child td </span>{
    <span class="org-css-property">border-bottom</span>: none;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">Center all images.</span><span class="org-comment-delimiter"> */</span>
<span class="org-css-selector">img </span>{
    <span class="org-css-property">display</span>: block;
    <span class="org-css-property">margin</span>: 0 auto;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">Increase text size for smaller sections.</span><span class="org-comment-delimiter"> */</span>
<span class="org-css-selector">h3, h4, h5, h6 </span>{
    <span class="org-css-property">margin-top</span>: 1em;
    <span class="org-css-property">margin-bottom</span>: 1em;
}
<span class="org-css-selector">h7 </span>{
    <span class="org-css-property">font-weight</span>: bold;
    <span class="org-css-property">font-size</span>: 18pt;
}
<span class="org-css-selector">.outline-7 </span>{
    <span class="org-css-property">margin-top</span>: 1em;
}

<span class="org-css-selector">code </span>{
    <span class="org-css-property">background</span>: <span class="custom">#eee</span>;
    <span class="org-css-property">padding-left</span>: 5px;
    <span class="org-css-property">padding-right</span>: 5px;
    <span class="org-css-property">white-space</span>: nowrap;
    <span class="org-css-property">border-radius</span>: 4px;
    <span class="org-css-property">border-style</span>: solid;
    <span class="org-css-property">border-width</span>: 1px;
    <span class="org-css-property">border-color</span>: <span class="custom-1">#777</span>;
}

<span class="org-css-selector">thead </span>{
    <span class="org-css-property">background</span>: <span class="custom">#eee</span>;
}

<span class="org-css-selector">pre </span>{
    <span class="org-css-property">font-size</span>: 0.8em;
    <span class="org-css-property">border-top-left-radius</span>: 0;
    <span class="org-css-property">border-top-right-radius</span>: 0;
    <span class="org-css-property">border-bottom-left-radius</span>: 5px;
    <span class="org-css-property">border-bottom-right-radius</span>: 5px;
}

<span class="lilac-child-link-from-parent"><a href="#__NREF__css-source-code-section-headlines">css-source-code-section-headlines</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__css-source-code-block-body">css-source-code-block-body</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__css-source-code-block-captions">css-source-code-block-captions</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__css-source-code-block-child-link-from-parent">css-source-code-block-child-link-from-parent</a></span>
</pre></div></div>
</div>

<div id="outline-container-h-Source-code-block-body" class="outline-4">
<h4 id="h-Source-code-block-body"><span class="section-number-4">5.11.1.</span> Source code block body</h4>
<div class="outline-text-4" id="text-h-Source-code-block-body">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#style-css">css-source-code-block-body</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__css-source-code-block-body">&#x1f517;</a></span></div><pre class="src src-css" id="__NREF__css-source-code-block-body"><span class="org-css-selector">.org-src-container </span>{
    <span class="org-css-property">margin</span>: 1em 0;
}

<span class="org-css-selector">.org-src-container pre </span>{
    <span class="org-css-property">margin</span>: 0;
    <span class="org-css-property">font-family</span>: <span class="org-string">"Source Code Pro"</span>, monospace;
    <span class="org-css-property">border-width</span>: 0;
    <span class="org-css-property">scroll-margin-top</span>: 100px;
    <span class="org-css-property">border-style</span>: solid;
    <span class="org-css-property">border-width</span>: 2px;
    <span class="org-css-property">border-color</span>: <span class="custom-1">#999</span>;
    <span class="org-css-property">border-radius</span>: 5px;
}

<span class="org-comment-delimiter">/* </span><span class="org-comment">Source code block body.</span><span class="org-comment-delimiter"> */</span>
<span class="org-css-selector">.org-src-container pre.src </span>{
    <span class="org-css-property">background-color</span>: <span class="custom">#f3f3f3</span>;
}

</pre></div></div>
</div>
</div>

<div id="outline-container-h-Source-code-block-captions" class="outline-4">
<h4 id="h-Source-code-block-captions"><span class="section-number-4">5.11.2.</span> Source code block captions</h4>
<div class="outline-text-4" id="text-h-Source-code-block-captions">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#style-css">css-source-code-block-captions</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__css-source-code-block-captions">&#x1f517;</a></span></div><pre class="src src-css" id="__NREF__css-source-code-block-captions"><span class="org-css-selector">.lilac-caption </span>{
    <span class="org-css-property">font-family</span>: <span class="org-string">"Source Code Pro"</span>, monospace;
    <span class="org-css-property">text-align</span>: right;
    <span class="org-css-property">border-top-left-radius</span>: 5px;
    <span class="org-css-property">border-top-right-radius</span>: 5px;
    <span class="org-css-property">padding-top</span>: 2px;
    <span class="org-css-property">padding-bottom</span>: 5px;
}

<span class="org-css-selector">.lilac-caption label </span>{
    <span class="org-css-property">margin-right</span>: 10px;
    <span class="org-css-property">padding-left</span>: 10px;
    <span class="org-css-property">padding-right</span>: 10px;
    <span class="org-css-property">padding-bottom</span>: 10px;
    <span class="org-css-property">border-radius</span>: 5px;
    <span class="org-css-property">border-style</span>: solid;
    <span class="org-css-property">border-bottom-style</span>: none;
    <span class="org-css-property">border-bottom-left-radius</span>: 0;
    <span class="org-css-property">border-bottom-right-radius</span>: 0;
    <span class="org-css-property">background-color</span>: <span class="custom-6">#ddd</span>;
    <span class="org-css-property">border-color</span>: <span class="custom-5">#999</span>;
}

<span class="org-css-selector">.lilac-caption-source-code-block-name </span>{
    <span class="org-css-property">color</span>: <span class="custom-4">#444444</span>;
    <span class="org-css-property">font-weight</span>: bold;
    <span class="org-css-property">margin-right</span>: 5px;
}

<span class="org-css-selector">.lilac-caption-parent-link </span>{
    <span class="org-css-property">margin-top</span>: 5px;
    <span class="org-css-property">margin-right</span>: 5px;
    <span class="org-css-property">padding-left</span>: 5px;
    <span class="org-css-property">padding-right</span>: 5px;
    <span class="org-css-property">font-weight</span>: bold;
}
<span class="org-css-selector">.lilac-caption-parent-link a </span>{
    <span class="org-css-property">padding-left</span>: 10px;
    <span class="org-css-property">padding-right</span>: 10px;
    <span class="org-css-property">padding-bottom</span>: 10px;
    <span class="org-css-property">color</span>: <span class="custom-3">#21618c</span>;
    <span class="org-css-property">background-color</span>: <span class="custom-2">#d8f6ff</span>;
    <span class="org-css-property">border-radius</span>: 5px;
    <span class="org-css-property">border-style</span>: solid;
    <span class="org-css-property">border-bottom-style</span>: none;
    <span class="org-css-property">border-bottom-left-radius</span>: 0;
    <span class="org-css-property">border-bottom-right-radius</span>: 0;
}
<span class="org-css-selector">.lilac-caption-parent-link a:hover </span>{
    <span class="org-css-property">color</span>: <span class="custom-1">#7d3c98</span>;
    <span class="org-css-property">background-color</span>: <span class="custom">#f8e9ff</span>;
    <span class="org-css-property">text-decoration</span>: none;
}

<span class="org-css-selector">.lilac-caption-link-symbol a </span>{
    <span class="org-css-property">margin-right</span>: 5px;
}
<span class="org-css-selector">.lilac-caption-link-symbol a:hover </span>{
    <span class="org-css-property">text-decoration</span>: none;
}

<span class="org-css-selector">.lilac-caption-listing-number </span>{
    <span class="org-css-property">margin-right</span>: 5px;
}
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Links-to-child-source-block-from-parent" class="outline-4">
<h4 id="h-Links-to-child-source-block-from-parent"><span class="section-number-4">5.11.3.</span> Links to child source block from parent</h4>
<div class="outline-text-4" id="text-h-Links-to-child-source-block-from-parent">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#style-css">css-source-code-block-child-link-from-parent</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__css-source-code-block-child-link-from-parent">&#x1f517;</a></span></div><pre class="src src-css" id="__NREF__css-source-code-block-child-link-from-parent"><span class="org-css-selector">.lilac-child-link-from-parent </span>{
    <span class="org-css-property">font-weight</span>: bold;
}
<span class="org-css-selector">.lilac-child-link-from-parent a </span>{
    <span class="org-css-property">color</span>: <span class="custom-3">#21618c</span>;
    <span class="org-css-property">background-color</span>: <span class="custom-2">#d8f6ff</span>;
    <span class="org-css-property">border-radius</span>: 5px;
    <span class="org-css-property">border-style</span>: solid;
    <span class="org-css-property">margin</span>: 5px 0;
    <span class="org-css-property">padding</span>: 2px 5px;
    <span class="org-css-property">display</span>: inline-block;
}
<span class="org-css-selector">.lilac-child-link-from-parent a:hover </span>{
    <span class="org-css-property">color</span>: <span class="custom-1">#7d3c98</span>;
    <span class="org-css-property">background-color</span>: <span class="custom">#f8e9ff</span>;
    <span class="org-css-property">text-decoration</span>: none;
}
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Create--lilac-theme--file" class="outline-3">
<h3 id="h-Create--lilac-theme--file"><span class="section-number-3">5.12.</span> Create <code>lilac.theme</code> file</h3>
<div class="outline-text-3" id="text-h-Create--lilac-theme--file">
<p>
Allow HTML exports of Org files (inluding this one) to pull in CSS and
JavaScript that we've defined for Lilac by referring to a single theme file. The
inspiration for this setup comes from <a href="https://gitlab.com/OlMon/org-themes">https://gitlab.com/OlMon/org-themes</a>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">lilac.theme</label><span class="lilac-caption-link-symbol"><a href="#lilac-theme">&#x1f517;</a></span></div><pre class="src src-org" id="lilac-theme"><span class="org-comment"># Include additional CSS styles.</span>
<span class="org-org-meta-line">#+HTML_HEAD: &lt;link rel="stylesheet" type="text/css" href="syntax-highlighting.css"/&gt;</span>
<span class="org-org-meta-line">#+HTML_HEAD: &lt;link rel="stylesheet" type="text/css" href="style.css" /&gt;</span>
<span class="org-org-meta-line">#+HTML_HEAD: &lt;link rel="stylesheet" href="<a href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro&amp;family=Source+Code+Pro">https://fonts.googleapis.com/css2?family=Source+Serif+Pro&amp;family=Source+Code+Pro</a>"&gt;</span>

<span class="lilac-child-link-from-parent"><a href="#__NREF__automatically_link_headlines">automatically_link_headlines</a></span>
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Ignore-woven-HTML-from--git-diff" class="outline-3">
<h3 id="h-Ignore-woven-HTML-from--git-diff"><span class="section-number-3">5.13.</span> Ignore woven HTML from <code>git diff</code></h3>
<div class="outline-text-3" id="text-h-Ignore-woven-HTML-from--git-diff">
<p>
Typically we only need to look at the rendered HTML output in a web browser as
the raw HTML diff output is extremely difficult to parse as a human. So by
default we ask Git to exclude it from <code>git diff</code> by treating them as binary
data.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">.gitattributes</label><span class="lilac-caption-link-symbol"><a href="#gitattributes">&#x1f517;</a></span></div><pre class="src src-gitattributes" id="gitattributes">* -diff
**/*.org diff
**/.gitattributes diff
**/.gitmodules diff
**/.gitignore diff
package/nix/sources.json diff
package/nix/sources.nix diff
</pre></div></div><p>
In order to still show the HTML textual diff, we can run <code>git diff --text</code>.
</p>
</div>

<div id="outline-container-h-git-add--p" class="outline-4">
<h4 id="h-git-add--p"><span class="section-number-4">5.13.1.</span> <code>git add -p</code></h4>
<div class="outline-text-4" id="text-h-git-add--p">
<p>
Note that the above setting to treat HTML files as binary data prevents them
from being considered for <code>git add -p</code>. In order to add them, use <code>git add -u</code>
instead.
</p>
</div>
</div>
</div>

<div id="outline-container-h-gitignore" class="outline-3">
<h3 id="h-gitignore"><span class="section-number-3">5.14.</span> gitignore</h3>
<div class="outline-text-3" id="text-h-gitignore">
<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">.gitignore</label><span class="lilac-caption-link-symbol"><a href="#gitignore">&#x1f517;</a></span></div><pre class="src src-gitignore" id="gitignore">**/*.auctex-auto
tangle
update-deps
weave
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Tangling--generating-the-source-code" class="outline-2">
<h2 id="h-Tangling--generating-the-source-code"><span class="section-number-2">6.</span> Tangling (generating the source code)</h2>
<div class="outline-text-2" id="text-h-Tangling--generating-the-source-code">
<p>
Tangling is simply the act of collecting the <code>#+begin_src ... #+end_src</code> blocks
and arranging them into the various target (source code) files. Every source
code block is given a unique name.
</p>

<p>
We simply tangle the <code>README.org</code> file (this file) to get all the code we need.
</p>
</div>
</div>

<div id="outline-container-h-Development-environment--Nix-shell" class="outline-2">
<h2 id="h-Development-environment--Nix-shell"><span class="section-number-2">7.</span> Development environment (Nix shell)</h2>
<div class="outline-text-2" id="text-h-Development-environment--Nix-shell">
<p>
This is the main development shell and brings in all of our dependencies to
build all of our code. Taken from <a href="https://github.com/tweag/haskell-stack-nix-example/blob/b9383e35416a2b0e21fbc97ed079538f9f395b6a/shell.nix#L1">here</a>. The <code>Makefile</code> is meant to be executed
from within this environment.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">shell.nix</label><span class="lilac-caption-link-symbol"><a href="#shell-nix">&#x1f517;</a></span></div><pre class="src src-nix" id="shell-nix"><span class="org-nix-keyword">let</span>
  <span class="org-comment"># Nixpkgs snapshot.</span>
  <span class="org-nix-attribute">sources</span> = <span class="org-nix-builtin">import</span> <span class="org-nix-constant">./package/nix/sources.nix</span>;
  <span class="org-comment"># The final "pkgs" attribute.</span>
  <span class="org-nix-attribute">pkgs</span> = <span class="org-nix-builtin">import</span> sources.nixpkgs {};
<span class="org-nix-keyword">in</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">This is our development shell.</span>
pkgs.mkShell ({
  <span class="org-nix-attribute">buildInputs</span> = [
    <span class="org-comment"># Tangling and weaving for Literate Programming.</span>
    pkgs.emacs

    <span class="org-comment"># Update Nix dependencies in package/nix/sources.nix.</span>
    pkgs.niv

    <span class="org-comment"># Misc.</span>
    pkgs.git
    pkgs.less
  ];
})
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Tests" class="outline-2">
<h2 id="h-Tests"><span class="section-number-2">8.</span> Tests</h2>
<div class="outline-text-2" id="text-h-Tests">
<p>
We use <a href="https://www.gnu.org/software/emacs/manual/ert.html">ERT, the Emacs Lisp Regression Testing tool</a> for our unit tests. Pure
functions that take all of their inputs explicitly ("dependency-injected") are
easy to test because we just provide the various inputs and expect the function
to produce certain outputs. For functions that operate on an Emacs buffer, we
use <code>with-temp-buffer</code> to create a temporary buffer first before invoking the
functions under test.
</p>

<p>
Some functions we test expect Org mode to be active (so that certain Org mode
functions are available), so we turn it on here by calling <code>(org-mode)</code>.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><label class="org-src-name">lilac-tests.el</label><span class="lilac-caption-link-symbol"><a href="#lilac-tests-el">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="lilac-tests-el">(<span class="org-keyword">require</span> '<span class="org-constant">ert</span>)
(<span class="org-keyword">require</span> '<span class="org-constant">lilac</span>)

(org-mode)

<span class="lilac-child-link-from-parent"><a href="#__NREF__t-helpers">t-helpers</a></span>
<span class="lilac-child-link-from-parent"><a href="#__NREF__t-smart-caption-generation-1">t-smart-caption-generation</a></span>

(<span class="org-keyword">provide</span> '<span class="org-constant">lilac-tests</span>)
</pre></div></div>
</div>

<div id="outline-container-h-Test-helpers" class="outline-3">
<h3 id="h-Test-helpers"><span class="section-number-3">8.1.</span> Test helpers</h3>
<div class="outline-text-3" id="text-h-Test-helpers">
<p>
Note that we cannot write <code>__NREF__foo</code> directly in the test code here, because
when this Org file is tangled, the references will be detected and Org mode will
try to replace them with a monoblock or polyblock elsewhere in this file named
<code>__NREF__foo</code>. So we have to go in "stealth mode" by writing the <code>__NREF__</code>
prefix indirectly with the <code>(nref)</code> helper function.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-tests-el">t-helpers</a></span><span class="lilac-caption-link-symbol"><a href="#__NREF__t-helpers">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__t-helpers">(<span class="org-keyword">defun</span> <span class="org-function-name">nref</span> (s) (concat <span class="org-string">"__NREF__"</span> s))
</pre></div></div>
</div>
</div>

<div id="outline-container-h-Smart-source-code-block-caption-helpers" class="outline-3">
<h3 id="h-Smart-source-code-block-caption-helpers"><span class="section-number-3">8.2.</span> Smart source code block caption helpers</h3>
<div class="outline-text-3" id="text-h-Smart-source-code-block-caption-helpers">
<p>
<code>lilac-get-noweb-children</code> should return a list of Noweb references (child block
names) found in a source code block.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-tests-el">t-smart-caption-generation</a></span>(1/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__t-smart-caption-generation-1">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__t-smart-caption-generation-1">(<span class="org-keyword">ert-deftest</span> <span class="org-function-name">t-lilac-get-noweb-children</span> ()
  (<span class="org-keyword">let</span> ((body
         (concat
          <span class="org-string">"#+name: foo\n"</span>
          <span class="org-string">"#+caption: foo\n"</span>
          <span class="org-string">"#+begin_src emacs-lisp\n"</span>
          <span class="org-string">"; foo\n"</span>
          <span class="org-string">"#+end_src\n"</span>)))
    (<span class="org-keyword">should</span> (equal (lilac-get-noweb-children body)
                   ())))
  (<span class="org-keyword">let</span> ((body
         (concat
          <span class="org-string">"#+name: parent\n"</span>
          <span class="org-string">"#+caption: parent\n"</span>
          <span class="org-string">"#+begin_src emacs-lisp\n"</span>
          <span class="org-string">"; foo\n"</span>
          (nref <span class="org-string">"one"</span>) <span class="org-string">"\n"</span>
          <span class="org-string">"; bar\n"</span>
          (nref <span class="org-string">"two"</span>) <span class="org-string">"\n"</span>
          <span class="org-string">"#+end_src\n"</span>)))
    (<span class="org-keyword">should</span> (equal (lilac-get-noweb-children body)
                   `(,(nref <span class="org-string">"one"</span>) ,(nref <span class="org-string">"two"</span>))))))
</pre></div></div><p>
<code>lilac-is-parent-block</code> depends on <code>lilac-get-noweb-children</code>. We tested the
latter already above, but we test the former anyway for completeness.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-tests-el">t-smart-caption-generation</a></span>(2/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__t-smart-caption-generation-2">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__t-smart-caption-generation-2">(<span class="org-keyword">ert-deftest</span> <span class="org-function-name">t-lilac-is-parent-block</span> ()
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: parent\n"</span>)
    (insert <span class="org-string">"#+caption: parent\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (goto-char (point-min))
    (<span class="org-keyword">let</span> ((src-block (org-element-at-point)))
      (<span class="org-keyword">should-not</span> (equal nil (lilac-is-parent-block src-block))))))
</pre></div></div><p>
Here we test whether we can automatically insert captions for child blocks.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-tests-el">t-smart-caption-generation</a></span>(3/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__t-smart-caption-generation-3">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__t-smart-caption-generation-3">(<span class="org-keyword">ert-deftest</span> <span class="org-function-name">t-lilac-insert-noweb-source-code-block-captions</span> ()
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: parent\n"</span>)
    (insert <span class="org-string">"#+caption: parent\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert (concat (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: "</span> (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; bar\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: "</span> (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; baz\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (lilac-insert-noweb-source-code-block-captions nil)
    (goto-char (point-min))
    (<span class="org-keyword">should</span> (search-forward
             (concat <span class="org-string">"#+caption: ="</span> (nref <span class="org-string">"child1"</span>) <span class="org-string">"=  [[parent][1]]"</span>)
             nil t))
    (<span class="org-keyword">should</span> (search-forward
             (concat <span class="org-string">"#+caption: ="</span> (nref <span class="org-string">"child2"</span>) <span class="org-string">"=  [[parent][1]]"</span>)
             nil t)))
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: parent1\n"</span>)
    (insert <span class="org-string">"#+caption: parent1\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert (concat (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: "</span> (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; bar\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: "</span> (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; baz\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: parent2\n"</span>))
    (insert <span class="org-string">"#+caption: parent2\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (lilac-insert-noweb-source-code-block-captions nil)
    (goto-char (point-min))
    (<span class="org-keyword">should</span> (search-forward
             (concat <span class="org-string">"#+caption: ="</span> (nref <span class="org-string">"child1"</span>) <span class="org-string">"=  [[parent1][1]]  [[parent2][2]]"</span>)
             nil t))
    (<span class="org-keyword">should</span> (search-forward
             (concat <span class="org-string">"#+caption: ="</span> (nref <span class="org-string">"child2"</span>) <span class="org-string">"=  [[parent1][1]]"</span>)
             nil t))))
</pre></div></div><p>
Here we test retrieval of parent source code blocks.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-tests-el">t-smart-caption-generation</a></span>(4/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__t-smart-caption-generation-4">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__t-smart-caption-generation-4">(<span class="org-keyword">ert-deftest</span> <span class="org-function-name">t-lilac-get-parent-blocks</span> ()
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: foo\n"</span>)
    (insert <span class="org-string">"#+caption: foo\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert <span class="org-string">"#+name: bar\n"</span>)
    (insert <span class="org-string">"#+caption: bar\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; bar\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (<span class="org-keyword">should-not</span> (lilac-get-parent-blocks)))
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: parent1\n"</span>)
    (insert <span class="org-string">"#+caption: parent1\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert <span class="org-string">"#+name: parent2\n"</span>)
    (insert <span class="org-string">"#+caption: parent2\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; bar\n"</span>)
    (insert (concat (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (<span class="org-keyword">should</span> (lilac-get-parent-blocks))))
</pre></div></div><p>
Here we test generating the child-to-parents hash table.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-tests-el">t-smart-caption-generation</a></span>(5/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__t-smart-caption-generation-5">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__t-smart-caption-generation-5">(<span class="org-keyword">ert-deftest</span> <span class="org-function-name">t-lilac-mk-child-parents-hash-table</span> ()
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: foo\n"</span>)
    (insert <span class="org-string">"#+caption: foo\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert <span class="org-string">"#+name: bar\n"</span>)
    (insert <span class="org-string">"#+caption: bar\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; bar\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (<span class="org-keyword">let*</span> ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks)))
      (<span class="org-keyword">should</span> (equal (hash-table-count child-parents-hash-table) 0))))
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: parent1\n"</span>)
    (insert <span class="org-string">"#+caption: parent1\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert <span class="org-string">"#+name: parent2\n"</span>)
    (insert <span class="org-string">"#+caption: parent2\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; bar\n"</span>)
    (insert (concat (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (<span class="org-keyword">let*</span> ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks)))
      (<span class="org-keyword">should</span> (equal (hash-table-count child-parents-hash-table) 2)))))
</pre></div></div><p>
Here we test the construction of smart captions.
</p>

<div class="org-src-container"><div class="lilac-pre-with-caption"><div class="lilac-caption"><span class="lilac-caption-parent-link"><a href="#lilac-tests-el">t-smart-caption-generation</a></span>(6/6) <span class="lilac-caption-link-symbol"><a href="#__NREF__t-smart-caption-generation-6">&#x1f517;</a></span></div><pre class="src src-emacs-lisp" id="__NREF__t-smart-caption-generation-6">(<span class="org-keyword">ert-deftest</span> <span class="org-function-name">t-lilac-mk-smart-captions</span> ()
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: parent1\n"</span>)
    (insert <span class="org-string">"#+caption: parent1\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert <span class="org-string">"#+name: parent2\n"</span>)
    (insert <span class="org-string">"#+caption: parent2\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; bar\n"</span>)
    (insert (concat (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (<span class="org-keyword">let*</span> ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (<span class="org-keyword">should</span> (equal smart-captions nil))))
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: parent1\n"</span>)
    (insert <span class="org-string">"#+caption: parent1\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert <span class="org-string">"#+name: parent2\n"</span>)
    (insert <span class="org-string">"#+caption: parent2\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; bar\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: "</span> (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; child1\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (<span class="org-keyword">let*</span> ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (<span class="org-keyword">should</span> (equal smart-captions
       `((181 . ,(concat <span class="org-string">"#+caption: ="</span>
                         (nref <span class="org-string">"child1"</span>)
                         <span class="org-string">"=  [[parent1][1]]  [[parent2][2]]\n"</span>)))))))
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: parent1\n"</span>)
    (insert <span class="org-string">"#+caption: parent1\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert <span class="org-string">"#+name: parent2\n"</span>)
    (insert <span class="org-string">"#+caption: parent2\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; bar\n"</span>)
    (insert (concat (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: "</span> (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; child1\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: "</span> (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; child2\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (<span class="org-keyword">let*</span> ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (<span class="org-keyword">should</span> (equal smart-captions
       `((181 . ,(concat <span class="org-string">"#+caption: ="</span>
                         (nref <span class="org-string">"child1"</span>)
                         <span class="org-string">"=  [[parent1][1]]\n"</span>))
         (247 . ,(concat <span class="org-string">"#+caption: ="</span>
                         (nref <span class="org-string">"child2"</span>)
                         <span class="org-string">"=  [[parent2][1]]\n"</span>)))))))
  (<span class="org-keyword">with-temp-buffer</span>
    (insert <span class="org-string">"#+name: parent1\n"</span>)
    (insert <span class="org-string">"#+caption: parent1\n"</span>)
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; foo\n"</span>)
    (insert (concat (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: "</span> (nref <span class="org-string">"child1"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; child1\n"</span>)
    (insert (concat (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+end_src\n"</span>)
    (insert <span class="org-string">"\n"</span>)
    (insert (concat <span class="org-string">"#+name: "</span> (nref <span class="org-string">"child2"</span>) <span class="org-string">"\n"</span>))
    (insert <span class="org-string">"#+begin_src emacs-lisp\n"</span>)
    (insert <span class="org-string">"; child2\n"</span>)
    (insert <span class="org-string">"#+end_src\n"</span>)
    (<span class="org-keyword">let*</span> ((parent-blocks (lilac-get-parent-blocks))
           (child-parents-hash-table
             (lilac-mk-child-parents-hash-table parent-blocks))
           (smart-captions (lilac-mk-smart-captions
                            child-parents-hash-table)))
      (<span class="org-keyword">should</span> (equal smart-captions
       `((91 . ,(concat <span class="org-string">"#+caption: ="</span>
                         (nref <span class="org-string">"child1"</span>)
                         <span class="org-string">"=  [[parent1][1]]\n"</span>))
         (172 . ,(concat <span class="org-string">"#+caption: ="</span>
                         (nref <span class="org-string">"child2"</span>)
                         <span class="org-string">"=  [["</span>
                         (nref <span class="org-string">"child1"</span>)
                         <span class="org-string">"][1]]\n"</span>))))))))
</pre></div></div>
</div>
</div>
</div>

<div id="outline-container-h-Glossary" class="outline-2">
<h2 id="h-Glossary"><span class="section-number-2">9.</span> Glossary</h2>
<div class="outline-text-2" id="text-h-Glossary">
<dl class="org-dl">
<dt><a id="org0000004"></a> <b>monoblock</b></dt><dd>an Org mode source code block with a <code>#+name:
  ...</code> field. This block is an independent block and there are no other blocks
with the same name.</dd>
<dt><b>Noweb</b></dt><dd>A literate programming tool from 1989 that still works and from
which <a href="#org0000098">Org mode</a> borrows heavily using <a href="#org000009a">Noweb-style references</a>. See <a href="https://en.wikipedia.org/wiki/Noweb">Wikipedia</a>.</dd>
<dt><a id="org000009a"></a> <b>noweb-ref</b></dt><dd>aka "Noweb-style reference". A Noweb-style
reference is just a name (string) that refers to a monoblock or polyblock. See
<a href="https://orgmode.org/manual/Noweb-Reference-Syntax.html">the Org manual</a>.</dd>
<dt><a id="org0000098"></a> <b>Org mode</b></dt><dd>An Emacs major mode for <code>*.org</code> files, where "major
mode" means that it provides things like syntax highlighting and keyboard
shortcuts for <code>*.org</code> text files if you are using Emacs. For Lilac, the
important thing is that we use Org mode as a literate programming tool. See
<a href="https://orgmode.org/">Org mode</a>.</dd>
<dt><a id="org0000006"></a> <b>polyblock</b></dt><dd>an Org mode source code block without a <code>#+name:
  ...</code> field, but which has a <code>#+header: :noweb-ref ...</code> field. Other blocks
with the same Noweb-ref name are concatenated together when they are tangled.
Polyblocks are used in cases where we would like to break up a single block
into smaller pieces for explanatory purposes. In all other cases, monoblocks
are preferable, unless the source code block is not to be tangled and is only
for explanatory purposes in the woven output.</dd>
<dt><b>source code block</b></dt><dd>An Org mode facility that allows you to enclose a
multiline piece of text with <code>#+begin_src ...</code> and <code>#+end_src</code> lines.</dd>
</dl>
</div>
</div>

<div id="outline-container-h-References" class="outline-2">
<h2 id="h-References"><span class="section-number-2">10.</span> References</h2>
<div class="outline-text-2" id="text-h-References">
<style>.csl-left-margin{float: left; padding-right: 1em;}
 .csl-right-inline{margin: 0 0 0 2em;}</style><div class="csl-bib-body">
  <div class="csl-entry"><a id="citeproc_bib_item_1"></a>
    <div class="csl-left-margin">[1]</div><div class="csl-right-inline">N. Ramsey, “Literate programming simplified,” <i>Ieee software</i>, vol. 11, no. 5, pp. 97–105, Sep. 1994, doi: <a href="https://doi.org/10.1109/52.311070">10.1109/52.311070</a>.</div>
  </div>
  <div class="csl-entry"><a id="citeproc_bib_item_2"></a>
    <div class="csl-left-margin">[2]</div><div class="csl-right-inline">D. E. Knuth, “Literate programming,” <i>The computer journal</i>, vol. 27, no. 2, pp. 97–111, Feb. 1984, doi: <a href="https://doi.org/10.1093/comjnl/27.2.97">10.1093/comjnl/27.2.97</a>.</div>
  </div>
</div>
</div>
</div>
</div>
</body>
</html>
